<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Creating a model · Muscade.jl</title><meta name="title" content="Creating a model · Muscade.jl"/><meta property="og:title" content="Creating a model · Muscade.jl"/><meta property="twitter:title" content="Creating a model · Muscade.jl"/><meta name="description" content="Documentation for Muscade.jl."/><meta property="og:description" content="Documentation for Muscade.jl."/><meta property="twitter:description" content="Documentation for Muscade.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Muscade.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="Theory.html">Theory</a></li><li><span class="tocitem">User manual</span><ul><li class="is-active"><a class="tocitem" href="Modelling.html">Creating a model</a><ul class="internal"><li><a class="tocitem" href="#Script-as-input"><span>Script as input</span></a></li><li><a class="tocitem" href="#Model-definition"><span>Model definition</span></a></li><li><a class="tocitem" href="#Built-in-elements"><span>Built-in elements</span></a></li><li><a class="tocitem" href="#Running-the-analysis"><span>Running the analysis</span></a></li><li><a class="tocitem" href="#Extracting-results"><span>Extracting results</span></a></li><li><a class="tocitem" href="#Units"><span>Units</span></a></li><li><a class="tocitem" href="#Drawing"><span>Drawing</span></a></li></ul></li><li><a class="tocitem" href="Solvers.html">Solvers</a></li><li><a class="tocitem" href="Elements.html">Implementing new elements</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="StaticBeamAnalysis.html">Static analysis of a beam</a></li><li><a class="tocitem" href="ModalBeamAnalysis.html">Modal analysis of a beam</a></li><li><a class="tocitem" href="DynamicBeamAnalysis.html">Dynamic analysis of a beam</a></li><li><a class="tocitem" href="DecayAnalysis.html">Estimating model parameters</a></li><li><a class="tocitem" href="DryFriction.html">DryFriction</a></li></ul></li><li><a class="tocitem" href="Diagnostic.html">Diagnostic</a></li><li><a class="tocitem" href="reference.html">Reference</a></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="TypeStable.html">Type-stability</a></li><li><a class="tocitem" href="Memory.html">Memory management</a></li><li><a class="tocitem" href="Adiff.html">Automatic differentiation</a></li><li><a class="tocitem" href="litterature.html">Literature</a></li></ul></li><li><a class="tocitem" href="LICENSE.html">MIT License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User manual</a></li><li class="is-active"><a href="Modelling.html">Creating a model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Modelling.html">Creating a model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SINTEF/Muscade.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SINTEF/Muscade.jl/blob/main/docs/src/Modelling.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Creating-a-model"><a class="docs-heading-anchor" href="#Creating-a-model">Creating a model</a><a id="Creating-a-model-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-model" title="Permalink"></a></h1><h2 id="Script-as-input"><a class="docs-heading-anchor" href="#Script-as-input">Script as input</a><a id="Script-as-input-1"></a><a class="docs-heading-anchor-permalink" href="#Script-as-input" title="Permalink"></a></h2><p><code>Muscade</code> being a framework for the development of optimization-FEM applications, it does not provide the elements needed to treat any specific application. It only provides a limited number of generic modeling capabilities, like fixing degrees of freedom (dofs) to describe boundary conditions, introducing holonomic constraints or costs on either dofs, or element-results (see <a href="Modelling.html#Built-in-elements">Built-in elements</a>).</p><p>Hence to create a model, one will typicaly be <code>using</code> both <code>Muscade</code> and another package that provides a <code>Muscade</code>-based application (app).  The app provides specific elements for domains like continuum mechanics, marine structures, hydrogen diffusion etc.</p><p>Input to such an app is provided in the form of a Julia script containing instructions (calls to <code>Muscade</code>, using elements provided by the app) to define the model, execute analyses, and extract and process analysis results.  In other words, scripting a series of analyses, or some specific pre or postprocessing is simply done in the same script, and app developpers do not have to write code pertaining to a user interface. That being said, an app could introduce a GUI that would itself do the calls to <code>Muscade</code>.</p><p>Here is a simple example of analysis:</p><pre><code class="language-julia hljs">using Muscade
using StaticArrays

model           = Model(:TestModel)
n1              = addnode!(model,[0.]) 
n2              = addnode!(model,[1.])
e1              = addelement!(model,Hold,[n1];field=:tx1)                       # Hold first node
@functor with() load(t) = 3t
e2              = addelement!(model,DofLoad,[n2];field=:tx1,value=load)        # Increase load on second node
@functor with() res(X,X′,X″,t)  = 12SVector(X[1]-X[2],X[2]-X[1])
e3              = addelement!(model,QuickFix,[n1,n2];inod=(1,2),field=(:tx1,:tx1),
                              res=res)  # Linear elastic spring with stiffness 12
initialstate    = initialize!(model)
state           = solve(SweepX{0};initialstate,time=[0.,1.],verbose=false)      # Solve the problem
tx1             = getdof(state[2],field=:tx1,nodID=[n2])                        # Extract the displacement of the free node
req             = @request F                                                    # Extract internal results from the spring element
eleres          = getresult(state,req,[e2]) 
iele,istep      = 1,2
force           = eleres[iele,istep].F
@show tx1
@show force</code></pre><h2 id="Model-definition"><a class="docs-heading-anchor" href="#Model-definition">Model definition</a><a id="Model-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Model-definition" title="Permalink"></a></h2><p>The definition of a model is done in three phases:</p><ol><li>Creating a blank model, with <a href="reference.html#Muscade.Model"><code>Model</code></a>.</li><li>Adding nodes and elements, with <a href="reference.html#Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t&lt;:Real}"><code>addnode!</code></a> and <a href="reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, AbstractMatrix{Muscade.NodID}}} where T&lt;:AbstractElement"><code>addelement!</code></a>. One can however add an element to the model <em>after</em> all the nodes of the element have been added to the model.</li><li>Initialising the model with <a href="reference.html#Muscade.initialize!-Tuple{Model}"><code>initialize!</code></a>.  Once this is done, one can no longer add nodes or elements to the model. <a href="reference.html#Muscade.initialize!-Tuple{Model}"><code>initialize!</code></a> hashes some tables and generates an initial &quot;as meshed&quot; state of the system. Typicaly (but this depends on the app), all dofs are set to zero. The resulting variable, here called <code>initialstate</code> contains a pointer to the model: passing a state to a solver makes the model available to the solver. </li></ol><p><a href="reference.html#Muscade.setdof!-Tuple{Muscade.State, Vector{Float64}}"><code>setdof!</code></a> can be used to set the value of specific dofs for more specific initial conditions.</p><p><code>Muscade</code> does not provide a mesher. There are some general purposes meshers with Julia API, which outputs could be used to generate calls to <a href="reference.html#Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t&lt;:Real}"><code>addnode!</code></a> and <a href="reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, AbstractMatrix{Muscade.NodID}}} where T&lt;:AbstractElement"><code>addelement!</code></a>.</p><p>Note that two <code>Function</code>s, <code>load</code> and <code>res</code> are defined in the script, and then passed as argument to element constructors. Elements require that the function has been defined by using the macro <a href="reference.html#Muscade.@functor-Tuple{Any, Any}"><code>@functor</code></a>.  The first argument is a list of parameters captured by the function. The macro ensures that the <em>values</em> of the parameters are captured. The second argument is the function definition.  The macro prevents the function to be re-parsed if unchanged, which in turn prevents unnecessary recompilations of Muscade when the script is runned multiple times in a session. </p><p>The model - either finitialized or under construction, can be examined using <a href="reference.html#Muscade.describe-Tuple{Model, Muscade.EleID}"><code>Muscade.describe</code></a> and <a href="reference.html#Muscade.getndof-Tuple{DataType}"><code>getndof</code></a>.  </p><p>Optionaly, one can also use <a href="reference.html#Muscade.setscale!-Tuple{Model}"><code>setscale!</code></a> (with the help of <a href="reference.html#Muscade.study_scale-Tuple{Muscade.State}"><code>Muscade.study_scale</code></a>) to scale the variables and thus improve the conditioning of the problem. </p><p>Information on commands provided by Julia and packages (including <span>$Muscade$</span>) can be obtained from the help mode in the REPL.  Make sure the command is available by <code>using Muscade</code>, then activate the help mode by pressing <code>?</code>. </p><pre><code class="language-julia hljs">help?&gt; Hold

  Hold &lt;: AbstractElement


  An element to set a single X-dof to zero.

  Named arguments to the constructor
  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

    •  field::Symbol. The field of the X-dof to constraint.

    •  λfield::Symbol=Symbol(:λ,field). The field of the Lagrange multiplier.  
(...)</code></pre><h2 id="Built-in-elements"><a class="docs-heading-anchor" href="#Built-in-elements">Built-in elements</a><a id="Built-in-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-elements" title="Permalink"></a></h2><p>With a few exceptions for testing and demonstration, <code>Muscade</code> does not provide physical elements.  However, it provides several general purpose elements  to introduce loads, costs or  constraints.</p><p><a href="reference.html#Muscade.DofLoad"><code>DofLoad</code></a> adds a time-varying load on a single <span>$X$</span>-dof.  Elements for more general loads, in particular, consistent loads on element boundaries or domain, or follower loads, need to be implemented if required.</p><p><a href="reference.html#Muscade.DofCost"><code>DofCost</code></a> adds a cost per unit of time, as a function of either <span>$X$</span>-dofs ,<span>$U$</span>-dofs (and/or their derivatives), <span>$A$</span>-dofs and time. Elements for costs on unknown distributed load <em>fields</em> (over boundary or domain) must be provided by apps if required.</p><p><a href="reference.html#Muscade.SingleDofCost"><code>SingleDofCost</code></a> provides a simplified syntax for costs on a single dof.</p><p><a href="reference.html#Muscade.Acost"><code>Acost</code></a> adds a once-off cost, as a function of <span>$A$</span>-dofs. </p><p><a href="reference.html#Muscade.SingleAcost"><code>SingleAcost</code></a> provides a simplified syntax for A once-off cost on a single <span>$A$</span>-dof.</p><p><a href="reference.html#Muscade.SingleUdof"><code>SingleUdof</code></a> allows to define an unknown external nodal load and apply a cost to it.</p><p><a href="reference.html#Muscade.ElementCost"><code>ElementCost</code></a> adds a cost per unti of time on a combination of one element&#39;s dofs and element-results.</p><p><a href="reference.html#Muscade.DofConstraint"><code>DofConstraint</code></a> adds a constraint to a combination of <em>values</em> (no time derivatives) of dofs. The constraints can switch over time between equality, inequality and &quot;off&quot;. Inequality constraints are handled using a modified interior point method.</p><p><a href="reference.html#Muscade.ElementConstraint"><code>ElementConstraint</code></a> adds a constraint to a function of internal results from one element. The constraints can switch over time between equality, inequality and &quot;off&quot;. Inequality constraints are handled using a modified interior point method.</p><p><a href="reference.html#Muscade.Hold"><code>Hold</code></a> provides a simplified syntax to set a single <span>$X$</span>-dof to zero.</p><p><a href="reference.html#Muscade.QuickFix"><code>QuickFix</code></a> allows to rapidly create a simple element, with limitations in functionality. </p><p>When using <code>xxxCost</code> elements to introduce measured time series, consider using <a href="https://github.com/SciML/DataInterpolations.jl"><code>DataInterpolations.jl</code></a>.</p><h2 id="Running-the-analysis"><a class="docs-heading-anchor" href="#Running-the-analysis">Running the analysis</a><a id="Running-the-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-analysis" title="Permalink"></a></h2><p><a href="reference.html#Muscade.solve-Tuple{Type{&lt;:Muscade.AbstractSolver}}"><code>solve</code></a> is then called with the name of the solver to be used (here <a href="reference.html#Muscade.SweepX"><code>SweepX{0}</code></a>), and any named parameters required by the solver. The return value <code>state</code> can have different structures, depending on the solver.  For <a href="reference.html#Muscade.SweepX"><code>SweepX{0}</code></a>, <code>state</code> is a vector (over the time steps) of <code>State</code>s.</p><p><a href="reference.html#Muscade.describe-Tuple{Model, Muscade.EleID}"><code>Muscade.describe</code></a> can also be used to inspect <code>State</code>s.</p><p>Analyses may fail due to singular matrix.  The source of the singularity can be challenging to diagnose. <a href="reference.html#Muscade.study_singular-Tuple{Muscade.State}"><code>Muscade.study_singular</code></a> can help determine the null-space of an incremental matrix, for small problems.</p><h2 id="Extracting-results"><a class="docs-heading-anchor" href="#Extracting-results">Extracting results</a><a id="Extracting-results-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-results" title="Permalink"></a></h2><p><code>State</code>s (returned by <a href="reference.html#Muscade.initialize!-Tuple{Model}"><code>initialize!</code></a> and <a href="reference.html#Muscade.solve-Tuple{Type{&lt;:Muscade.AbstractSolver}}"><code>solve</code></a>). are variables which contents are private (not part of the API, and subject to change), but can be accessed using <a href="reference.html#Muscade.getdof-Tuple{Muscade.State}"><code>getdof</code></a> and <a href="reference.html#Muscade.getresult-Union{Tuple{S}, Tuple{Vector{S}, Any, Vector{Muscade.EleID}}} where S&lt;:Muscade.State"><code>getresult</code></a>.</p><p><a href="reference.html#Muscade.getdof-Tuple{Muscade.State}"><code>getdof</code></a> allows to obtain dofs which are directly stored in <code>state</code>, by specifying class, field and node.</p><p><a href="reference.html#Muscade.getresult-Union{Tuple{S}, Tuple{Vector{S}, Any, Vector{Muscade.EleID}}} where S&lt;:Muscade.State"><code>getresult</code></a> (used in combination with <a href="reference.html#Muscade.@request-Tuple{Any}"><code>Muscade.@request</code></a>) allows to obtain &quot;element-results&quot;.  Element-results are intermediate values that are computed within <a href="reference.html#Muscade.lagrangian-Tuple{}"><code>Muscade.lagrangian</code></a> or <a href="reference.html#Muscade.residual-Tuple{}"><code>Muscade.residual</code></a>, but are (generaly) not returned, because the API for these functions does not open for this.  In mechanics,  <a href="reference.html#Muscade.residual-Tuple{}"><code>Muscade.residual</code></a> would take displacements as inputs (<span>$X$</span>-dofs) and from them compute the forces that must act on the element to cause these displacements. Element-results woudl then include quantities such as stresses and strains.  To be requestable, a variable must be tagged in <a href="reference.html#Muscade.lagrangian-Tuple{}"><code>Muscade.lagrangian</code></a> or <a href="reference.html#Muscade.residual-Tuple{}"><code>Muscade.residual</code></a>, prefixing its name with <code>☼</code> (<code>\sun</code>) at the right hand of an assigment.</p><p>These element-results are not stored in the <code>State</code>, and tagging variables does not result in either increase storage or computing time: <a href="reference.html#Muscade.getresult-Union{Tuple{S}, Tuple{Vector{S}, Any, Vector{Muscade.EleID}}} where S&lt;:Muscade.State"><code>getresult</code></a> will compute requested values on the fly by calling a modified version of <a href="reference.html#Muscade.lagrangian-Tuple{}"><code>Muscade.lagrangian</code></a> or <a href="reference.html#Muscade.residual-Tuple{}"><code>Muscade.residual</code></a> generated by <a href="reference.html#Muscade.@espy-Tuple{Any}"><code>@espy</code></a>.  This also implies that one does not need to decide on what variables to store before an anlysis, a great advantage for heavy analyses.</p><h2 id="Units"><a class="docs-heading-anchor" href="#Units">Units</a><a id="Units-1"></a><a class="docs-heading-anchor-permalink" href="#Units" title="Permalink"></a></h2><p><code>Muscade</code> provides functionality to transform quantities to and from basic SI units.</p><pre><code class="language-julia hljs">using Muscade, Printf
using Muscade: m, kg, pound, foot
rho          = 3←(pound/foot^3)                      # convert to SI
vieuxquintal = 1000*pound                            # define new unit
@printf(&quot;Density [pound/foot^3] %f&quot;,rho→pound/foot^3) # convert from SI</code></pre><p>Arrays can be converted in the same way: <code>[200,300,24]←mm</code>.</p><p>A guideline for handling units without <a href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter">problems</a> is:</p><ul><li><strong>Element developers</strong> assume inputs with consistent units, and thus never make unit conversions.</li><li><strong>Element developers</strong> do not assume that the input are expressed in base SI units, and thus require all necessary dimensional constants (acceleration of gravity, gas constant...) as user input.</li><li><strong>Users</strong> convert all their input values as they define them in the input <code>rho = 3 ← pound/foot^3</code>.</li><li><strong>Users</strong> convert Muscade outputs just before printing them out <code>printf(&quot;stress [MPa] %f&quot;,stress → MPa)</code>.</li></ul><p>Excellent packages exist for the handling of units (<a href="https://painterqubits.github.io/Unitful.jl/stable/"><code>Unitful.jl</code></a> ).  These packages have zero runtime overhead, and allow to verify code for unit consistency (<code>Muscade</code> does not provide this). However, it is arguably not possible to make these packages work with <code>Muscade</code>: In <code>Muscade</code>, <code>3←(pound/foot^3)</code> is of type <code>Float64</code>.  A comparable operation in <a href="https://painterqubits.github.io/Unitful.jl/stable/"><code>Unitful.jl</code></a> would output a variable with a <em>type</em> containing data about dimensionality. <code>Muscade</code> handles various arrays of quantities with different dimensionality: such a solution would result in arrays of heterogeneous types. <code>Muscade</code> does not allow this, as this would result in catastrophic loss of performance due to <a href="TypeStable.html#typestab">type instability</a>.</p><h2 id="Drawing"><a class="docs-heading-anchor" href="#Drawing">Drawing</a><a id="Drawing-1"></a><a class="docs-heading-anchor-permalink" href="#Drawing" title="Permalink"></a></h2><h3 id="Generating-figures-with-Draw!"><a class="docs-heading-anchor" href="#Generating-figures-with-Draw!">Generating figures with <code>Draw!</code></a><a id="Generating-figures-with-Draw!-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-figures-with-Draw!" title="Permalink"></a></h3><p>To create a snapshot of a <code>State</code>, either the initialised model, or a step from an analysis, one can use <a href="reference.html#Muscade.draw!-Tuple{Any, Muscade.State, Vector{Muscade.EleID}}"><code>draw!</code></a>:</p><pre><code class="language-julia hljs">using GLMakie
fig     = Figure(size = (500,500))
axis    = Axis3(fig[1,1])
draw!(axis,state;kwargs...)</code></pre><p><a href="reference.html#Muscade.draw!-Tuple{Any, Muscade.State, Vector{Muscade.EleID}}"><code>draw!</code></a> calls methods <a href="reference.html#Muscade.allocate_drawing-Union{Tuple{E}, Tuple{Any, AbstractVector{E}}} where E&lt;:AbstractElement"><code>Muscade.allocate_drawing</code></a>, <a href="reference.html#Muscade.update_drawing-Union{Tuple{E}, Tuple{Any, AbstractVector{E}, Vararg{Any, 9}}} where E&lt;:AbstractElement"><code>Muscade.update_drawing</code></a> and <a href="reference.html#Muscade.display_drawing!-Union{Tuple{E}, Tuple{Any, Type{E}, Any, Any}} where E&lt;:AbstractElement"><code>Muscade.display_drawing!</code></a> for all (or specific) elements of the model.  </p><p>Elements that do not implement the above three methods simply have no graphic representation. <code>Muscade</code>&#39;s built-in elements, for example, do not implement such methods.  This is for two reasons.</p><p>First, <code>Muscade</code> is not written to serve a specific domain of physics.  How a <a href="reference.html#Muscade.DofConstraint"><code>DofConstraint</code></a> should be represented would be different in mechanics and chemical species diffusion.  Developers of <code>Muscade</code>-based application can create domain-specific drawing methods for specific elements.</p><p>Second, while <code>Muscade</code> is tested with <a href="https://docs.makie.org/"><code>GLMakie.jl</code></a>, it is intended to support other graphic engines.  For example, <code>fig</code> in the above example could be an opened <a href="https://www.paraview.org/"><code>Paraview</code></a> file (VTK file), and the drawing methods could be made to write to this file. <code>Muscade</code> itself only passes <code>fig</code> on to the drawing methods, with no form of type checking.</p><p><a href="reference.html#Muscade.draw!-Tuple{Any, Muscade.State, Vector{Muscade.EleID}}"><code>draw!</code></a> accepts a list of keywords argument (<code>kwargs...</code>) in the above example, which <code>Muscade</code> just passes on to the drawing methods of all elements. This is intended to provide the user control over what is drawn and how (choose which field to display, line thickness, surface color etc.).</p><h3 id="Interactive-exploration-with-GUI"><a class="docs-heading-anchor" href="#Interactive-exploration-with-GUI">Interactive exploration with <code>GUI</code></a><a id="Interactive-exploration-with-GUI-1"></a><a class="docs-heading-anchor-permalink" href="#Interactive-exploration-with-GUI" title="Permalink"></a></h3><p>The function <a href="reference.html#Muscade.GUI-Tuple{Any, Muscade.EigXUincrement}"><code>GUI</code></a> can be called with a <code>Vector</code> of <code>State</code>s.  This allows to explore a sequence of steps interactively, and allows to scale results for visualisation, </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Theory.html">« Theory</a><a class="docs-footer-nextpage" href="Solvers.html">Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 18 February 2026 13:03">Wednesday 18 February 2026</span>. Using Julia version 1.11.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
