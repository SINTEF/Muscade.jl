include("Rotations.jl")

# # Euler beam element

using StaticArrays, LinearAlgebra
using Muscade

# Data structure containing the cross section material properties
struct BeamCrossSection
    EA :: ùï£
    EI :: ùï£
    GJ :: ùï£
end
    # œÅ  :: ùï£ 
    # Œº  :: ùï£ 
    # Rotation about x.... moment of inertia?
    # Cd :: SVector{3,ùï£}
    # Ca :: SVector{3,ùï£}
    # A  :: SVector{3,ùï£}

BeamCrossSection(;EA=EA,EI=EI,GJ=GJ) = BeamCrossSection(EA,EI,GJ);

# Resultant function that computes the internal loads from the strains and curvatures, and external loads on the element. 
@espy function resultants(o::BeamCrossSection,Œµ,Œ∫,x,v‚Çõ‚Çò) 
    # WARNING: curvatures are defined as rate of rotation along the element, not second derivatives of deflection.  
    # Hence Œ∫[3]>0 implies +2 direction is inside curve, 
    #       Œ∫[2]>0 implies -3 direction is inside curve.
    ‚òºf‚ÇÅ = o.EA*‚àÇ0(Œµ)
    ‚òºm  = SVector(o.GJ*‚àÇ0(Œ∫)[1],o.EI*‚àÇ0(Œ∫)[2],o.EI*‚àÇ0(Œ∫)[3])# replace by Œ∫‚ÇÄ 
    ‚òºf‚Çë = SVector(0.,0.,0.) # external forces  at Gauss point. f‚Çë is in local coordinates # add inertia and drag
    ‚òºm‚Çë = SVector(0.,0.,0.) # external couples at Gauss point. m‚Çë is in local coordinates 
    return f‚ÇÅ,m,f‚Çë,m‚Çë
end;



## Static Euler beam element, with two nodes, two Gauss points and 12 degrees of freedom. 

const ngp        = 2
const ndim       = 3
const ndof       = 12
const nnod       = 2;

# Shape functions for a beam element with support Œ∂‚àà[-1/2,1/2]. Though the shape function matrices are sparse, do not "unroll" them.  That would be faster but considerably clutter the code                          
y‚Çê(Œ∂) =            2Œ∂       # differential axial displacement or roll field
y·µ§(Œ∂) =  -4Œ∂^3    +3Œ∂       # deflection due to differential nodal transverse translation
y·µ•(Œ∂) =        Œ∂^2   - 1/4  # deflection due to differenttial rotation (bending, not torsion)
Œ∫‚Çê(Œ∂) =                2    # torsion  . Œ∫‚Çê = y‚Çê‚Ä≤ . Divide by L .    
Œ∫·µ§(Œ∂) =  -24Œ∂               # curvature. Œ∫·µ§ = y·µ§‚Ä≤‚Ä≤. Divide by L¬≤.
Œ∫·µ•(Œ∂) =                2    # curvature. Œ∫·µ• = y·µ•‚Ä≤‚Ä≤. Divide by L .

# Data structure describing an EulerBeam3D element as meshed
struct EulerBeam3D{Mat} <: AbstractElement
    c‚Çò       :: SVector{3,ùï£}    # Position of the middle of the element
    r‚Çò       :: Mat33{ùï£}        # Orientation of the element (see code)
    Œ∂gp      :: SVector{ngp,ùï£}  # Location of the Gauss points for the normalized element with length 1
    Œ∂nod     :: SVector{nnod,ùï£} # Location of the nodes for the normalized element with length 1
    tg‚Çò      :: SVector{ndim,ùï£} # Vector connecting the nodes of the element in the global coordinate system
    tg‚Çë      :: SVector{ndim,ùï£} # Vector connecting the nodes of the element in the local coordinate system
    y‚Çê       :: SVector{ngp,ùï£}  # Value at gp of shape function for differential axial displacement or roll field
    y·µ§       :: SVector{ngp,ùï£}  # Value at gp of shape function for deflection due to differential nodal transverse translation
    y·µ•       :: SVector{ngp,ùï£}  # Value at gp of shape function for deflection due to differenttial rotation (bending, not torsion)
    Œ∫‚Çê       :: SVector{ngp,ùï£}  # Value at gp of shape function for torsion  . Œ∫‚Çê = y‚Çê‚Ä≤ . Divided by L .    
    Œ∫·µ§       :: SVector{ngp,ùï£}  # Value at gp of shape function for curvature. Œ∫·µ§ = y·µ§‚Ä≤‚Ä≤. Divided by L¬≤.
    Œ∫·µ•       :: SVector{ngp,ùï£}  # Value at gp of shape function for curvature. Œ∫·µ• = y·µ•‚Ä≤‚Ä≤. Divided by L .
    L        :: ùï£
    dL       :: SVector{ngp,ùï£}  # length associated to each Gauss point
    mat      :: Mat # Used to store material properties (BeamCrossSection, for example)
end

# Define nodes, classes, and field names of dofs
Muscade.doflist(::Type{<:EulerBeam3D}) = (inod = (1,1,1,1,1,1, 2,2,2,2,2,2), class= ntuple(i->:X,ndof), field= (:t1,:t2,:t3,:r1,:r2,:r3, :t1,:t2,:t3,:r1,:r2,:r3) )

# Define now the constructor for the EulerBeam3D element. Arguments: node coordinates and direction of the first bending axis in the global coordinate system.  
function EulerBeam3D(nod::Vector{Node};mat,orient2::SVector{ndim,ùï£}=SVector(0.,1.,0.))
    c       = coord(nod)
    ## Position of the middle of the element in the global coordinate system (as-meshed)
    c‚Çò      = SVector{ndim}((c[1]+c[2])/2)
    ## Length and tangential vector to the element in the global coordinate system  
    tg‚Çò     = SVector{ndim}( c[2]-c[1]   )
    L       = norm(tg‚Çò)
    t       = tg‚Çò/L
    ## Create t, n, b which are the longitudinal and two transverse unit vectors to the element (as-meshed). 
    ## NB: orient2, provided by the user, will define the first bending axis. 
    orient2/= norm(orient2)
    n       = orient2 - t*dot(orient2,t) 
    nn      = norm(n) 
    nn>1e-3 || muscadeerror("Provide a 'orient' input that is not nearly parallel to the element")
    n      /= nn
    b       = cross(t,n)
    r‚Çò      = SMatrix{ndim,ndim}(t...,n...,b...)
    ## Tangential vector and node coordinates in the local coordinate system
    tg‚Çë     = SVector{ndim}(L,0,0)
    ## Length associated to each Gauss point
    dL      = SVector{ngp }(L/2   , L/2 )
    ## Location of the Gauss points for a unit-length beam element, with nodes at ¬±1/2. 
    Œ∂gp     = SVector{ngp }(-1/2‚àö3,1/2‚àö3) # Œ∂‚àà[-1/2,1/2]
    Œ∂nod    = SVector{nnod}(-1/2  ,1/2  ) # Œ∂‚àà[-1/2,1/2]
    shapes  = (y‚Çê.(Œ∂gp), y·µ§.(Œ∂gp), y·µ•.(Œ∂gp), Œ∫‚Çê.(Œ∂gp)/L, Œ∫·µ§.(Œ∂gp)/L^2, Œ∫·µ•.(Œ∂gp)/L)
    return EulerBeam3D(c‚Çò,r‚Çò,Œ∂gp,Œ∂nod,tg‚Çò,tg‚Çë,shapes...,L,dL,mat)
end

# Define now the residual function for the EulerBeam3D element.

@espy function Muscade.residual(o::EulerBeam3D,   X,U,A,t,SP,dbg) 
    X‚ÇÄ          = ‚àÇ0(X)
    TX‚ÇÄ         = revariate{1}(X‚ÇÄ)
    Tgp,TŒµ,Tv‚Çõ‚Çò  = kinematics(o,TX‚ÇÄ)

    P,ND        = precedence(X‚ÇÄ),length(X)
    X_          = motion{P}(X)

    ‚òºŒµ          = motion‚Åª¬π{P,ND}(compose(value{P+1}( TŒµ  ),X_))
    ‚òºv‚Çõ‚Çò         = motion‚Åª¬π{P,ND}(compose(value{P+1}( TŒµ  ),X_))
    Œµ‚àÇX‚ÇÄ        =                compose(‚àÇ{P+1,ndof}(TŒµ  ),X‚ÇÄ )
    v‚Çõ‚Çò‚àÇX‚ÇÄ        =              compose(‚àÇ{P+1,ndof}(Tv‚Çõ‚Çò  ),X‚ÇÄ )
    gp          = ntuple(ngp) do igp
        Tx,TŒ∫   = Tgp[igp].x, Tgp[igp].Œ∫
        ‚òºx      = motion‚Åª¬π{P,ND}(compose(value{P+1}( Tx  ),X_))
        ‚òºŒ∫      = motion‚Åª¬π{P,ND}(compose(value{P+1}( TŒ∫  ),X_))
        x‚àÇX‚ÇÄ    =                compose(‚àÇ{P+1,ndof}(Tx  ),X‚ÇÄ )
        Œ∫‚àÇX‚ÇÄ    =                compose(‚àÇ{P+1,ndof}(TŒ∫  ),X‚ÇÄ )
        f‚ÇÅ,m·µ¢,f‚Çë,m‚Çë = ‚òºresultants(o.mat,Œµ,Œ∫,x,v‚Çõ‚Çò)          # call the "resultant" function to compute loads (local coordinates) from strains/curvatures/etc. using material properties. Note that output is dual of input. 
        R       = (f‚ÇÅ ‚àò‚ÇÄ Œµ‚àÇX‚ÇÄ + m·µ¢ ‚àò‚ÇÅ Œ∫‚àÇX‚ÇÄ + f‚Çë ‚àò‚ÇÅ x‚àÇX‚ÇÄ + m‚Çë ‚àò‚ÇÅ v‚Çõ‚Çò‚àÇX‚ÇÄ) * o.dL[igp]     # Contribution to the local nodal load of this Gauss point  [ndof] = scalar*[ndof] + [ndim]‚ãÖ[ndim,ndof] + [ndim]‚ãÖ[ndim,ndof]
        @named(R)
    end
    R               = sum(gp·µ¢.R for gp·µ¢‚ààgp) 
    return R,noFB  
end
function kinematics(o::EulerBeam3D,X‚ÇÄ)  
    c‚Çò,r‚Çò,tg‚Çò,tg‚Çë,Œ∂nod,Œ∂gp,L  = o.c‚Çò,o.r‚Çò,o.tg‚Çò,o.tg‚Çë,o.Œ∂nod,o.Œ∂gp,o.L   # As-meshed element coordinates and describing tangential vector

    # transformation to corotated system
    u·µß‚ÇÅ,v·µß‚ÇÅ,u·µß‚ÇÇ,v·µß‚ÇÇ  = SVector{3}(X‚ÇÄ[i] for i‚àà1:3), SVector{3}(X‚ÇÄ[i] for i‚àà4:6),SVector{3}(X‚ÇÄ[i] for i‚àà7:9),SVector{3}(X‚ÇÄ[i] for i‚àà10:12)
    v‚Çõ               = (v·µß‚ÇÅ+v·µß‚ÇÇ)/2
    r‚Çõ‚Çò              = Rodrigues(v‚Çõ) ‚àò‚ÇÅ o.r‚Çò
    v‚Çõ‚Çò              = Rodrigues‚Åª¬π(r‚Çõ‚Çò)
    c‚Çõ               = (u·µß‚ÇÅ+u·µß‚ÇÇ)/2
    u‚Çó‚ÇÇ              = r‚Çõ‚Çò'‚àò‚ÇÅ(u·µß‚ÇÇ+tg‚Çò*Œ∂nod[2]-c‚Çõ)-tg‚Çë*Œ∂nod[2]    #Local displacement of node 2
    v‚Çó‚ÇÇ              = Rodrigues‚Åª¬π(r‚Çõ‚Çò'‚àò‚ÇÅRodrigues(v·µß‚ÇÇ)‚àò‚ÇÅr‚Çò)     #Local rotation of node 2
    
    # interpolation
    Œµ               = ‚àö((u‚Çó‚ÇÇ[1]+L/2)^2+u‚Çó‚ÇÇ[2]^2+u‚Çó‚ÇÇ[3]^2)*2/L - 1.       
    gp              = ntuple(ngp) do igp
        y‚Çê,y·µ§,y·µ•,Œ∫‚Çê,Œ∫·µ§,Œ∫·µ• = o.y‚Çê[igp],o.y·µ§[igp],o.y·µ•[igp],o.Œ∫‚Çê[igp],o.Œ∫·µ§[igp],o.Œ∫·µ•[igp]
        Œ∫           = SVector(         Œ∫‚Çê*v‚Çó‚ÇÇ[1], Œ∫·µ§*u‚Çó‚ÇÇ[2]+Œ∫·µ•*v‚Çó‚ÇÇ[3], Œ∫·µ§*u‚Çó‚ÇÇ[3]-Œ∫·µ•*v‚Çó‚ÇÇ[2])  
        y           = SVector(y‚Çê*u‚Çó‚ÇÇ[1]         , y·µ§*u‚Çó‚ÇÇ[2]+y·µ•*v‚Çó‚ÇÇ[3], y·µ§*u‚Çó‚ÇÇ[3]-y·µ•*v‚Çó‚ÇÇ[2])                              
        x           = r‚Çõ‚Çò‚àò‚ÇÅ(tg‚Çë*Œ∂gp[igp]+y)+c‚Çõ+c‚Çò 
        (Œ∫=Œ∫,x=x)
    end
    return gp,Œµ,v‚Çõ‚Çò
end

