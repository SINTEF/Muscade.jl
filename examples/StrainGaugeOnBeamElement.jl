"""
    StrainGaugeOnEulerBeam3D

An element designed to wrap around an EulerBeam3D. The element makes no contribution 
to residual or Lagrangian besides the contribution made by the element it wraps.
`StrainGaugeOnEulerBeam3D` provides requestables allowing to model strain gauges. The
strain gauges are placed halfway along the `EulerBeam3D`. In an inverse analysis, the
`StrainGaugeOnEulerBeam3D` is itself wraped by an `ElementCost` element.

# Keyword arguments when adding elements:

- `P` `SMatrix{3,Nsensor,ùï£}`, giving the offset between the point on the axis of the 
   element halfway along its length. `P[1,:]` must be zero.
- `D` `SMatrix{3,Nsensor,ùï£}`, the orientation of a strain gauge. If multiple strain gauges 
   are present at the same position, one can repeat the columns of `P`.
- `ElementType=EulerBeam3D` the constructor to the wrapped element.  This is typicaly
   an `EulerBeam3D` but could be another element wrapping an `EulerBeam3D`.
- `elementkwargs` a `NamedTuple` with the keyword arguments to the wrapped element.  See [`EulerBeam3D`](@ref)   

# Requestables:

- `Œµ‚Çê‚Çì` (scalar), the axial strain at the middle of the element
- `Œ∫` a vector with elements: 
        `Œ∫[1]` the torsion at the middle of the element.
        `Œ∫[2]` the component of te curvature in `EulerBeam3D`'s direction 2.
        `Œ∫[3]` the component of te curvature in `EulerBeam3D`'s direction 3.
    Although a tri-vector that includes torsion may erroneously suggest 
    a rotation rate vector, the `Œ∫[2:3]` points to the inside of the curvature    
    and the unit is in `1/L` (not `rad/L`) where `L` is the unit of length of
    the model.
- `Œµ` a vector of length `Nsensor` containing the strain values defined by `P`
   and `D`.    

#Keyword arguments when drawing elements:

When calling `draw!`, instruction to `StrainGaugeOnEulerBeam3D` elements are given as in this example:

    draw!(axis,state>;StrainGaugeOnEulerBeam3D=(L= @SVector [0.1,0,0],point_size=10,accelerometer_color=:orange))`

The optional keword arguments and their default values are  
- `gauge_color = :blue`
- `expand      = 1.02` a multiplicative factor applied to `P` in the drawing only (not in strain calculation)
   to ensure the gauge is not hidden by a patch-drawing of the beam itself.
- `L           = SVector{Nsensor,ùï£}(norm(P)/5 for i=1:Nsensor)` the length of the strain gauge in the drawing  TODO

    
"""
struct StrainGaugeOnEulerBeam3D{Ngauge,Teleobj,Treq} <: AbstractElement
    eleobj   :: Teleobj
    req      :: Treq
    P        :: SMatrix{3,Ngauge,ùï£}  # P[1] must be zero
    D        :: SMatrix{3,Ngauge,ùï£}
    E        :: SVector{  Ngauge,ùï£} 
    K1       :: SVector{  Ngauge,ùï£}  
    K2       :: SVector{  Ngauge,ùï£}  
    K3       :: SVector{  Ngauge,ùï£}  
end
function StrainGaugeOnEulerBeam3D(nod::Vector{Node};P,D,ElementType=EulerBeam3D,elementkwargs)  # Teleobj because we may wrap wrapped beams
    req       = @request (Œµ,Œ∫)
    eleobj    = ElementType(nod;elementkwargs...)
    all(P[1,:].==0.) || muscadeerror("In arguments of StrainGaugeOnEulerBeam3D, P[1,:] must all be zero")
    E         =  D[1,:].^2
    K1        =  D[1,:].*(D[3,:].*P[2,:].-D[2,:].*P[3,:])  
    K2        = -D[1,:].^2 .*P[2,:]
    K3        = -D[1,:].^2 .*P[3,:]
    return StrainGaugeOnEulerBeam3D(eleobj,(strain=req,),P,D,E,K1,K2,K3)
end
Muscade.doflist( ::Type{<:StrainGaugeOnEulerBeam3D{Ngauge,Teleobj}}) where{Ngauge,Teleobj} = Muscade.doflist(Teleobj)
@espy function Muscade.residual(o::StrainGaugeOnEulerBeam3D, X,U,A,t,SP,dbg)
    req          = mergerequest(o.req) # @espy will generate req = merge(o.req,req) where req is the additional argument of lagrangian method generated by espy
    R,FB,‚òºeleres = Muscade.getresidual(o.eleobj,X,U,A,t,SP,(dbg...,via=StrainGaugeOnEulerBeam3D),req.strain) 
    ‚òºŒµ‚Çê‚Çì,‚òºŒ∫      = ‚àÇ0(eleres.Œµ), ‚àÇ0(eleres.Œ∫)   
    ‚òºŒµ           = o.E*Œµ‚Çê‚Çì .+ o.K1*Œ∫[1] .+o.K2*Œ∫[2] .+ o.K3*Œ∫[3] 
    return R,FB
end   
function Muscade.allocate_drawing(axis,o::AbstractVector{Gauge};kwargs...) where{Gauge<:StrainGaugeOnEulerBeam3D{Ngauge}} where{Ngauge}  
    mutt,optt    = Muscade.allocate_drawing(axis,[o·µ¢.eleobj for o·µ¢‚àào];kwargs...)
    args         = default{:StrainGaugeOnEulerBeam3D}(kwargs,(;)     ) 
    opt          = default(args,(gauge_color=:lightgreen,expand=1.02,target=optt,L=1.))
    nel          = length(o)
    x            = ùï£2(undef,3,3*Ngauge*nel)       # 3D, end1-end2-nan, ngauge, nel
    rx           = reshape(x,3,3,Ngauge,nel)
    rx[:,3,:,:] .= NaN
    mut          = (target=mutt, gauge=x)
    
    return mut,opt
end
function Muscade.update_drawing(  axis,o::AbstractVector{Gauge},oldmut,opt, Œõ,X,U,A,t,SP,dbg) where{Gauge<:StrainGaugeOnEulerBeam3D{Ngauge}} where{Ngauge} 
    X‚ÇÄ                   = ‚àÇ0(X)
    nel                  = length(o)
    rx                   = reshape(oldmut.gauge,3,3,Ngauge,nel)
    for (iel,o·µ¢) ‚àà enumerate(o)
        gp,Œµ,v‚Çõ‚Çò,r‚Çõ‚Çò,v‚Çó‚ÇÇ,u‚Çó‚ÇÇ,c‚Çõ‚Çò = kinematics(o·µ¢.eleobj,view(X‚ÇÄ,:,iel))
        rx[:,1,:,iel]    = r‚Çõ‚Çò ‚àò‚ÇÅ (o·µ¢.P*opt.expand .+ opt.L*o·µ¢.D) .+ c‚Çõ‚Çò
        rx[:,2,:,iel]    = r‚Çõ‚Çò ‚àò‚ÇÅ (o·µ¢.P*opt.expand .- opt.L*o·µ¢.D) .+ c‚Çõ‚Çò
    end
    mutt = Muscade.update_drawing(  axis,[e·µ¢.eleobj for e·µ¢‚àào],oldmut.target,opt.target, Œõ,X,U,A,t,SP,dbg) 
    mut  = (target=mutt,gauge = oldmut.gauge )
    return mut
end
function Muscade.display_drawing!(axis,::Type{<:StrainGaugeOnEulerBeam3D{Ngauge,Teleobj}},obs,opt) where{Ngauge,Teleobj}                         
    lines!(axis,obs.gauge,color = opt.gauge_color ,linewidth=3)
    Muscade.display_drawing!(axis,Teleobj,obs.target,opt.target)
end
