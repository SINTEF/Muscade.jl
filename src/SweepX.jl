### Assembler

mutable struct AssemblySweepX{ORDER,TŒª,TŒªx} <: Assembly
    # up
    LŒª        :: TŒª                
    LŒªx       :: TŒªx
    ming      :: ùï£
    minŒª      :: ùï£
    Œ£Œªg       :: ùï£
    npos      :: ùï´
    # down
    c         :: @NamedTuple{a‚ÇÅ::ùï£, a‚ÇÇ::ùï£, a‚ÇÉ::ùï£, b‚ÇÅ::ùï£, b‚ÇÇ::ùï£, b‚ÇÉ::ùï£}
    firstiter :: ùïì   
    line      :: ùïì
end   
function prepare(::Type{AssemblySweepX{ORDER}},model,dis) where{ORDER}
    Xdofgr             = allXdofs(model,dis)  # dis: the model's disassembler
    ndof               = getndof(Xdofgr)
    narray,neletyp     = 2,getneletyp(model)
    asm                = Matrix{ùï´2}(undef,narray,neletyp)  # asm[iarray,ieletyp][ieledof,iele]
    LŒª                 = asmvec!(view(asm,1,:),Xdofgr,dis) 
    LŒªx                = asmmat!(view(asm,2,:),view(asm,1,:),view(asm,1,:),ndof,ndof) 
    out                = AssemblySweepX{ORDER,typeof(LŒª),typeof(LŒªx)}(LŒª,LŒªx,‚àû,‚àû,0.,0,(a‚ÇÅ=0.,a‚ÇÇ=0.,a‚ÇÉ=0.,b‚ÇÅ=0.,b‚ÇÇ=0.,b‚ÇÉ=0.),false,false) 
    return out,asm,Xdofgr
end
function zero!(out::AssemblySweepX) 
    zero!(out.LŒª)
    zero!(out.LŒªx)
    out.ming = ‚àû    
    out.minŒª = ‚àû
    out.Œ£Œªg  = 0.
    out.npos = 0    
end
@inline function lineFB!(out,FB)
    if hasfield(typeof(FB),:mode) && FB.mode==:positive
        out.ming   = min(out.ming,VALUE(FB.g))
        out.minŒª   = min(out.minŒª,VALUE(FB.Œª))
        out.Œ£Œªg   += VALUE(FB.g)*VALUE(FB.Œª)
        out.npos  += 1
    end
end
function addin!(out::AssemblySweepX{ORDER},asm,iele,scale,eleobj::E,Œõ,X::NTuple{Nxder,<:SVector{Nx}},U,A,t,SP,dbg) where{ORDER,E,Nxder,Nx}
    if Nx==0; return end   
    a‚ÇÅ,a‚ÇÇ,a‚ÇÉ,b‚ÇÅ,b‚ÇÇ,b‚ÇÉ = out.c.a‚ÇÅ,out.c.a‚ÇÇ,out.c.a‚ÇÉ,out.c.b‚ÇÅ,out.c.b‚ÇÇ,out.c.b‚ÇÉ
    if ~out.line
        if ORDER==2 && out.firstiter
            i          = SVector{Nx}(1:Nx)
            Œ¥Xr        = Œ¥{1,Nx+1,ùï£}(SVector{Nx+1}(scale.X...,1.))      
            Œ¥X         = Œ¥Xr[i]        
            Œ¥r         = Œ¥Xr[Nx+1]     # Newmark-Œ≤ special: we need C‚ãÖa and M‚ãÖb
            x,x‚Ä≤,x‚Ä≥    = ‚àÇ0(X),‚àÇ1(X),‚àÇ2(X)
            a          = a‚ÇÇ*x‚Ä≤ + a‚ÇÉ*x‚Ä≥
            b          = b‚ÇÇ*x‚Ä≤ + b‚ÇÉ*x‚Ä≥
            vx         = x  +    Œ¥X
            vx‚Ä≤        = x‚Ä≤ + a‚ÇÅ*Œ¥X - a*Œ¥r 
            vx‚Ä≥        = x‚Ä≥ + b‚ÇÅ*Œ¥X - b*Œ¥r
            LŒª,FB      = getresidual(eleobj,(vx,vx‚Ä≤,vx‚Ä≥),U,A,t,SP,dbg)
            LŒª         = LŒª .* scale.X
            add_value!(out.LŒª ,asm[1],iele,LŒª             )
            add_‚àÇ!{1}( out.LŒª ,asm[1],iele,LŒª,ia=1:Nx,ida=(Nx+1,))  # rhs = R - C‚ãÖa - M‚ãÖb 
            add_‚àÇ!{1}( out.LŒªx,asm[2],iele,LŒª,ia=1:Nx,ida=1:Nx   )
        else
            Œ¥X         = Œ¥{1,Nx,ùï£}(scale.X)
            if     ORDER==0  LŒª,FB = getresidual(eleobj,(‚àÇ0(X)+Œ¥X,                         ),U,A,t,SP,dbg)
            elseif ORDER==1  LŒª,FB = getresidual(eleobj,(‚àÇ0(X)+Œ¥X, ‚àÇ1(X)+a‚ÇÅ*Œ¥X             ),U,A,t,SP,dbg)
            elseif ORDER==2  LŒª,FB = getresidual(eleobj,(‚àÇ0(X)+Œ¥X, ‚àÇ1(X)+a‚ÇÅ*Œ¥X, ‚àÇ2(X)+b‚ÇÅ*Œ¥X),U,A,t,SP,dbg)
            end
            LŒª         = LŒª .* scale.X
            add_value!(out.LŒª ,asm[1],iele,LŒª)
            add_‚àÇ!{1}( out.LŒªx,asm[2],iele,LŒª)
        end
    else # if out.line
        if ORDER==2 && out.firstiter
            Œ¥r         = Œ¥{1}()              # Newmark-Œ≤ special: we need C‚ãÖa and M‚ãÖb
            x,x‚Ä≤,x‚Ä≥    = ‚àÇ0(X),‚àÇ1(X),‚àÇ2(X)
            a          = a‚ÇÇ*x‚Ä≤ + a‚ÇÉ*x‚Ä≥
            b          = b‚ÇÇ*x‚Ä≤ + b‚ÇÉ*x‚Ä≥
            vx         = x 
            vx‚Ä≤        = x‚Ä≤ - a .*Œ¥r 
            vx‚Ä≥        = x‚Ä≥ - b .*Œ¥r 
            LŒª,FB      = getresidual(eleobj,promote(vx,vx‚Ä≤,vx‚Ä≥),U,A,t,SP,dbg)
            LŒª         = LŒª .* scale.X
            add_value!(out.LŒª ,asm[1],iele,LŒª)
            add_‚àÇ!{1}( out.LŒª ,asm[1],iele,LŒª)  # rhs = R - C‚ãÖa - M‚ãÖb 
            lineFB!(out,FB)
        else         
            LŒª,FB      = getresidual(eleobj,X,U,A,t,SP,dbg)
            LŒª         = LŒª .* scale.X
            add_value!(out.LŒª ,asm[1],iele,LŒª)
            lineFB!(out,FB)
        end
    end
end


"""
	SweepX{ORDER}

A non-linear, time domain solver, that solves the problem time-step by time-step.
Only the `X`-dofs of the model are solved for, while `U`-dofs and `A`-dofs are unchanged.

- `SweepX{0}` is Newton-Raphson, with feasibility line-search, to handle inequality constraints. 
- `SweepX{1}` is implicit Euler, with feasibility line-search. 
- `SweepX{2}` is Newmark-Œ≤, with Newton-Raphson iterations and feasibility line search

IMPORTANT NOTE: Muscade does not allow elements to have state variables, for example, plastic strain,
or shear-free position for dry friction.  Where the element implements such physics, this 
is implemented by introducing the state as a degree of freedom of the element, and solving
for its evolution, *even in a static problem*, requires the use of `ORDER‚â•1`

An analysis is carried out by a call with the following syntax:

```
initialstate    = initialize!(model)
setdof!(initialstate,1.;class=:U,field=:Œªcsr)
states           = solve(SweepX{2};initialstate=initialstate,time=0:10)
```
# Named arguments to `solve`:
- `dbg=(;)`           a named tuple to trace the call tree (for debugging)
- `verbose=true`      set to false to suppress printed output (for testing)
- `silenterror=false` set to true to suppress print out of error (for testing) 
- `initialstate`      a `State`, obtain from `√¨nitialize!` or `SweepX`.
- `time`              maximum number of Newton-Raphson iterations 
- `Œ≤=1/4`,`Œ≥=1/2`     parameters to the Newmark-Œ≤ algorithm. Dummy if `ORDER<2`
- `maxiter=50`        maximum number of equilibrium iterations at each step.
- `maxŒîx=1e-5`        convergence criteria: norm of `X`. D
- `maxLŒª=‚àû`           convergence criteria: norm of the residual. 
- `saveiter=false`    set to true so that output `states` contains the state
                      at the iteration of the last step analysed.  Useful to study
                      a step that fails to converge. 
- `maxLineIter=50`    Maximum number of iteration in the feasibility line search.
                      set to 0 to skip the line search (not recommended for models
                      with inequality constraints).
- `sfac=0.5`          Parameter in the line search for a feasible point. If a 
                      tentative result is not feasible, backtrack by a factor `sfac`.
                      If still not feasible, backtrack what is left by a factor `sfac`,
                      and so forth, up to `maxLineIter` times.
- `Œ≥fac=0.5`          Parameter for feasibility. For an inequality constraint `g(X)`
                      with reaction force `Œª`, require `g(X)*Œª==Œ≥`, and multiply
                      `Œ≥ *= Œ≥fac` at each iteration.                            

# Output

A vector of length equal to that of the named input argument `time` containing the states at the time steps.                       

See also: [`solve`](@ref), [`initialize!`](@ref), [`findlastassigned`](@ref), [`studysingular`](@ref), [`DirectXUA`](@ref), [`FreqXU`](@ref)  
"""
struct        SweepX{ORDER} <: AbstractSolver end
function solve(SX::Type{SweepX{ORDER}},pstate,verbose,dbg;
                    time::AbstractVector{ùï£},
                    initialstate::State,
                    Œ≤::ùï£=1/4,Œ≥::ùï£=1/2,
                    maxiter::‚Ñ§=50,maxŒîx::‚Ñù=1e-5,maxLŒª::‚Ñù=‚àû,
                    saveiter::ùîπ=false,
                    maxLineIter::‚Ñ§=50,sfac::ùï£=.5,Œ≥fac::ùï£=.5) where{ORDER}
    model,dis        = initialstate.model,initialstate.dis
    out,asm,Xdofgr   = prepare(AssemblySweepX{ORDER},model,dis)  
    ndof             = getndof(Xdofgr)
    if ORDER‚â•1    x‚Ä≤ = ùï£1(undef,ndof) end 
    if ORDER‚â•2    x‚Ä≥ = ùï£1(undef,ndof) end 
    citer            = 0
    cŒîx¬≤,cLŒª¬≤        = maxŒîx^2,maxLŒª^2
    state            = State{1,ORDER+1,1}(copy(initialstate,SP=(Œ≥=0.,))) 


    states           = allocate(pstate,Vector{typeof(state)}(undef,saveiter ? maxiter : length(time))) # states is not a return argument of this function.  Hence it is not lost in case of exception
    local facLŒªx 
    for (step,t)     ‚àà enumerate(time)
        oldt         = state.time
        state.time   = t
        Œît           = t-oldt
        Œît ‚â§ 0 && ORDER>0 && muscadeerror(@sprintf("Time step length not strictly positive at step=%3d",step))
        if     ORDER==0 out.c= (a‚ÇÅ=0.      , a‚ÇÇ=0. , a‚ÇÉ=0.         , b‚ÇÅ=0.        , b‚ÇÇ=0.      , b‚ÇÉ=0.  )
        elseif ORDER==1 out.c= (a‚ÇÅ=1/Œît    , a‚ÇÇ=0  , a‚ÇÉ=0.         , b‚ÇÅ=0.        , b‚ÇÇ=0.      , b‚ÇÉ=0.  )
        elseif ORDER==2 out.c= (a‚ÇÅ=Œ≥/(Œ≤*Œît), a‚ÇÇ=Œ≥/Œ≤, a‚ÇÉ=(Œ≥/2Œ≤-1)*Œît, b‚ÇÅ=1/(Œ≤*Œît^2), b‚ÇÇ=1/(Œ≤*Œît), b‚ÇÉ=1/2Œ≤) # Œ≥, as in Newmark's Œ≤ and Œ≥
        end
        state.time   = t
        out.firstiter= true
        out.line     = true
        assemble!(out,asm,dis,model,state,(dbg...,solver=:SweepX,phase=:preliminary,step=step))
        out.ming ‚â§ 0 && muscadeerror(@sprintf("Initial point is not strictly primal-feasible at step=%3d",step)) # This is going to suck
        out.minŒª ‚â§ 0 && muscadeerror(@sprintf("Initial point is not strictly dual-feasible at step=%3d"  ,step)) # This is going to suck
        state.SP     = (Œ≥=out.Œ£Œªg/out.npos * Œ≥fac,)   # Œ≥, is in interior point, g(X)*Œª=Œ≥
        for iiter    = 1:maxiter
            citer   += 1
            out.firstiter = firstiter = iiter==1
            out.line = false
            assemble!(out,asm,dis,model,state,(dbg...,solver=:SweepX,step=step,iiter=iiter))
            try if step==1 && firstiter  facLŒªx = lu(out.LŒªx) 
            else                         lu!(facLŒªx, out.LŒªx) 
            end catch; muscadeerror(@sprintf("matrix factorization failed at step=%i, iiter=%i",step,iiter)) end
            Œîx       = facLŒªx\out.LŒª
            Œîx¬≤,LŒª¬≤  = sum(Œîx.^2),sum(out.LŒª.^2)
            if     ORDER==0  decr0!(state,Œîx ,Xdofgr                      )
            elseif ORDER==1  decr1!(state,Œîx ,Xdofgr,out.c                )
            elseif ORDER==2  decr2!(state,Œîx ,Xdofgr,out.c,firstiter,x‚Ä≤,x‚Ä≥)
            end

            out.line = true    
            s = 1.    
            for iline = 1:maxLineIter
                assemble!(out,asm,dis,model,state,(dbg...,solver=:SweepX,phase=:linesearch,step=step,iiter=iiter,iline=iline))
                out.minŒª > 0 && out.ming > 0 &&  break
                iline==maxLineIter && muscadeerror(@sprintf("Line search failed at step=%3d, iiter=%3d, iline=%3d, s=%7.1e",step,iiter,iline,s))
                Œîs    = s*(sfac-1)
                s    += Œîs
                if     ORDER==0  decr0!(state,Œîs*Œîx ,Xdofgr                      )
                elseif ORDER==1  decr1!(state,Œîs*Œîx ,Xdofgr,out.c                )
                elseif ORDER==2  decr2!(state,Œîs*Œîx ,Xdofgr,out.c,firstiter,x‚Ä≤,x‚Ä≥)
                end
            end

            verbose && saveiter && @printf("        iteration %3d, Œ≥= %7.1e\n",iiter,Œ≥)
            saveiter && (states[iiter]=State(state.time,state.Œõ,deepcopy(state.X),state.U,state.A,state.SP,model,dis))
            if Œîx¬≤‚â§cŒîx¬≤ && LŒª¬≤‚â§cLŒª¬≤ 
                verbose && @printf "    step %3d converged in %3d iterations. |Œîx|=%7.1e |LŒª|=%7.1e\n" step iiter ‚àö(Œîx¬≤) ‚àö(LŒª¬≤)
                ~saveiter && (states[step]=State(state.time,state.Œõ,deepcopy(state.X),state.U,state.A,state.SP,model,dis))
                break#out of the iiter loop
            end
            iiter==maxiter && muscadeerror(@sprintf("no convergence of step %3d after %3d iterations |Œîx|=%g / %g, |LŒª|=%g / %g",step,iiter,‚àö(Œîx¬≤),maxŒîx,‚àö(LŒª¬≤)^2,maxLŒª))
            state.SP     = (Œ≥=state.SP.Œ≥*Œ≥fac,)
        end
    end
    verbose && @printf "\n    nel=%d, ndof=%d, nstep=%d, niter=%d, niter/nstep=%5.2f\n" getnele(model) getndof(Xdofgr) length(time) citer citer/length(time)
    return
end
function decr2!(state,Œîx ,Xdofgr,c,firstiter,x‚Ä≤,x‚Ä≥)
    a‚ÇÅ,a‚ÇÇ,a‚ÇÉ,b‚ÇÅ,b‚ÇÇ,b‚ÇÉ = c.a‚ÇÅ,c.a‚ÇÇ,c.a‚ÇÉ,c.b‚ÇÅ,c.b‚ÇÇ,c.b‚ÇÉ
    if firstiter
        getdof!(state,1,x‚Ä≤,Xdofgr) 
        getdof!(state,2,x‚Ä≥,Xdofgr) 
        a        = a‚ÇÇ*x‚Ä≤+a‚ÇÉ*x‚Ä≥
        b        = b‚ÇÇ*x‚Ä≤+b‚ÇÉ*x‚Ä≥
        Œîx‚Ä≤      = a‚ÇÅ*Œîx + a
        Œîx‚Ä≥      = b‚ÇÅ*Œîx + b
    else
        Œîx‚Ä≤      = a‚ÇÅ*Œîx 
        Œîx‚Ä≥      = b‚ÇÅ*Œîx 
    end
    decrement!(state,1,Œîx ,Xdofgr)
    decrement!(state,2,Œîx‚Ä≤,Xdofgr)
    decrement!(state,3,Œîx‚Ä≥,Xdofgr)
end
function decr1!(state,Œîx ,Xdofgr,c)
    Œîx‚Ä≤      = c.a‚ÇÅ*Œîx 
    decrement!(state,1,Œîx ,Xdofgr)
    decrement!(state,2,Œîx‚Ä≤,Xdofgr)
end
function decr0!(state,Œîx ,Xdofgr)
    decrement!(state,1,Œîx ,Xdofgr)
end
