<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Static analysis of a beam ¬∑ Muscade.jl</title><meta name="title" content="Static analysis of a beam ¬∑ Muscade.jl"/><meta property="og:title" content="Static analysis of a beam ¬∑ Muscade.jl"/><meta property="twitter:title" content="Static analysis of a beam ¬∑ Muscade.jl"/><meta name="description" content="Documentation for Muscade.jl."/><meta property="og:description" content="Documentation for Muscade.jl."/><meta property="twitter:description" content="Documentation for Muscade.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Muscade.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="Theory.html">Theory</a></li><li><span class="tocitem">User manual</span><ul><li><a class="tocitem" href="Modelling.html">Creating a model</a></li><li><a class="tocitem" href="Solvers.html">Solvers</a></li><li><a class="tocitem" href="Elements.html">Implementing new elements</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href="StaticBeamAnalysis.html">Static analysis of a beam</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#3D-rotations"><span>3D rotations</span></a></li><li class="toplevel"><a class="tocitem" href="#Euler-beam-element"><span>Euler beam element</span></a></li><li class="toplevel"><a class="tocitem" href="#Analysis"><span>Analysis</span></a></li><li class="toplevel"><a class="tocitem" href="#Fetch-and-display-results"><span>Fetch and display results</span></a></li></ul></li><li><a class="tocitem" href="DecayAnalysis.html">Estimating model parameters</a></li><li><a class="tocitem" href="DryFriction.html">DryFriction</a></li></ul></li><li><a class="tocitem" href="reference.html">Reference</a></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="TypeStable.html">Type-stability</a></li><li><a class="tocitem" href="Memory.html">Memory management</a></li><li><a class="tocitem" href="Adiff.html">Automatic differentiation</a></li><li><a class="tocitem" href="litterature.html">Literature</a></li></ul></li><li><a class="tocitem" href="LICENSE.html">MIT License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="StaticBeamAnalysis.html">Static analysis of a beam</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="StaticBeamAnalysis.html">Static analysis of a beam</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SINTEF/Muscade.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SINTEF/Muscade.jl/blob/main/examples/StaticBeamAnalysis.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Static-analysis-of-a-beam"><a class="docs-heading-anchor" href="#Static-analysis-of-a-beam">Static analysis of a beam</a><a id="Static-analysis-of-a-beam-1"></a><a class="docs-heading-anchor-permalink" href="#Static-analysis-of-a-beam" title="Permalink"></a></h1><pre><code class="language-julia hljs">using Muscade, StaticArrays, GLMakie</code></pre><h1 id="3D-rotations"><a class="docs-heading-anchor" href="#3D-rotations">3D rotations</a><a id="3D-rotations-1"></a><a class="docs-heading-anchor-permalink" href="#3D-rotations" title="Permalink"></a></h1><pre><code class="language-julia hljs">using LinearAlgebra

sinc1(x) = sinc(x/œÄ)
function sinc1‚Ä≤(x)
    if abs(x)&gt;1e-3
        s,c=sin(x),cos(x)
        c/x -s/x^2
    else
        x¬≤ = x*x
        x*(-1/3 +x¬≤/30)
    end
end
function sinc1‚Ä≥(x)
    if abs(x)&gt;1e-1
        s,c=sin(x),cos(x)
        -s/x -2c/x^2 +2s/x^3
    else
        x¬≤ = x*x
        -1/3 +x¬≤*(1/10 +x¬≤*(-1/168 +x¬≤*(1/6480)))
    end
end
function sinc1‚Ä¥(x)
    if abs(x)&gt;0.4
        s,c=sin(x),cos(x)
        -c/x +3s/x^2 +6c/x^3 -6s/x^4
    else
        x¬≤ = x*x
        x*(1/5 +x¬≤*(-1/42 +x¬≤*(1/1080 +x¬≤*(-1/55440 +x¬≤*(1/4717440)))))
    end
end
function sinc1‚Åó(x)
    x¬≤ = x*x
    1/5 +x¬≤*(-1/14 +x¬≤*(1/216 +x¬≤*(-1/7920 +x¬≤*(1/524160 +x¬≤*(-1/54432000 +x¬≤*(1/54432000 +x¬≤*(-1/8143027200 +x¬≤*(1/1656387532800))))))))
end
sinc1‚Åó‚Ä≤(x) = x*NaN
using Muscade
Muscade.@DiffRule1(sinc1,               sinc1‚Ä≤( a.x)                * a.dx )
Muscade.@DiffRule1(sinc1‚Ä≤,              sinc1‚Ä≥( a.x)                * a.dx )
Muscade.@DiffRule1(sinc1‚Ä≥,              sinc1‚Ä¥( a.x)                * a.dx )
Muscade.@DiffRule1(sinc1‚Ä¥,              sinc1‚Åó( a.x)                * a.dx )
Muscade.@DiffRule1(sinc1‚Åó,              sinc1‚Åó‚Ä≤(a.x)                * a.dx )


# sinc1(acos(x)), differentiable to fourth order over ]-1,1]

function scac(x)
    dx = x-1
    if abs(dx)&gt;1e-3
        sinc1(acos(x))
    else  # deliberately a long Taylor series (5th order): this function will be adiffed at least to 2nd order, up to 4th order
        y = 1 + dx*(1/3 + dx*(-2/90 + dx*(0.0052911879917544626 + dx*(-0.0016229317117234072 + dx*(0.0005625)))))
    end
end

const Mat33{R}   = SMatrix{3,3,R,9}
const Vec3{R}    = SVector{3,R}


spin(  v::Vec3 ) = SMatrix{3,3}(0,v[3],-v[2],-v[3],0,v[1],v[2],-v[1],0)

spin‚Åª¬π(m::Mat33) = SVector{3}(m[3,2]-m[2,3],m[1,3]-m[3,1],m[2,1]-m[1,2])/2

trace( m::Mat33) = m[1,1]+m[2,2]+m[3,3]

Rodrigues‚Åª¬π(m)   = spin‚Åª¬π(m)/scac((trace(m)-1)/2)   # NB: is necessarily singular for œÄ turn

function Rodrigues(v::Vec3)
    S = spin(v)
    Œ∏ = norm(v)
    return LinearAlgebra.I + sinc1(Œ∏)*S + sinc1(Œ∏/2)^2/2*S*S
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Rodrigues (generic function with 1 method)</code></pre><p>&quot;&quot;&quot;     v1 = BeamElements.normalize(v::SVector{3})</p><p>Compute a unit vector of same direction as <code>v</code>.  Fails if <code>|v|==0</code>. &quot;&quot;&quot; normalize(v)     = v/norm(v)</p><pre><code class="language-julia hljs"># create a rotation vector that acts on u to make it colinear with v.  Fails if |u|=0, |v|=0 or Œ∏=œÄ

function adjust(u::Vec3{R},v::Vec3{R}) where{R}
    u,v = normalize.((u,v))
    c,w = dot(u,v), cross(u,v)
    s   = norm(w)
    Œ∏   = atan(s,c)
    return w/sinc1(Œ∏)
end;</code></pre><h1 id="Euler-beam-element"><a class="docs-heading-anchor" href="#Euler-beam-element">Euler beam element</a><a id="Euler-beam-element-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-beam-element" title="Permalink"></a></h1><pre><code class="language-julia hljs">using StaticArrays, LinearAlgebra
using Muscade</code></pre><p>Data structure containing the cross section material properties</p><pre><code class="language-julia hljs">struct BeamCrossSection
    EA :: ùï£
    EI :: ùï£
    GJ :: ùï£
    # œÅ  :: ùï£
    # Œº  :: ùï£
    # Add moment of inertia about x for dynamic torque
    # Cd :: SVector{3,ùï£}
    # Ca :: SVector{3,ùï£}
    # A  :: SVector{3,ùï£}
end
BeamCrossSection(;EA=EA,EI=EI,GJ=GJ) = BeamCrossSection(EA,EI,GJ);</code></pre><p>Resultant function that computes the internal loads from the strains and curvatures, and external loads on the element.</p><pre><code class="language-julia hljs">@espy function resultants(o::BeamCrossSection,Œµ,Œ∫,x·µß,r‚Çõ‚Çò,v·µ¢)

    r‚ÇÄ  = ‚àÇ0(r‚Çõ‚Çò)  # orientation of the element&#39;s local refsys
    v·µ¢‚ÇÅ = ‚àÇ1(v·µ¢)  # intrinsic rotation rate         of the element&#39;s local refsys
    v·µ¢‚ÇÇ = ‚àÇ2(v·µ¢)  # intrinsic rotation acceleration of the element&#39;s local refsys
    ‚òºm‚Çë = SVector(0.,0.,0.) # external couples at Gauss point. m‚Çë is in local coordinates


    x·µß‚ÇÄ,x·µß‚ÇÅ,x·µß‚ÇÇ = ‚àÇ0(x·µß),‚àÇ1(x·µß),‚àÇ2(x·µß)
    x‚Çó‚ÇÅ          = x·µß‚ÇÅ ‚àò‚ÇÅ r‚ÇÄ
    x‚Çó‚ÇÇ          = x·µß‚ÇÇ ‚àò‚ÇÅ r‚ÇÄ
    # Compute drag force (hard-coded parameters so far)
    œÅ = 1025.0
    A  = SVector(0.0,1.0,1.0)
    Cd = SVector(0.0,1.0,1.0) # SVector(0.0,0.0,0.0)
    fd = .5 * œÅ * A .* Cd .* x‚Çó‚ÇÅ .* abs.(x‚Çó‚ÇÅ) #mind the sign: forces exerted by element on its environment
    # Compute inertia force (hard-coded parameter so far)
    Œº   = 1.0
    fi = Œº * x‚Çó‚ÇÇ
    # Compute added mass force (hard-coded parameter so far)
    Ca = SVector(0.0,1.0,1.0)
    fa = œÅ * Ca .* x‚Çó‚ÇÇ
    ‚òºf‚Çë = fd+fa+fi #SVector(0.,0.,0.) # external forces at Gauss point (no external moment/torque/... so far). f‚Çë is in local coordinates


    ‚òºf·µ¢ = o.EA*‚àÇ0(Œµ)


    # WARNING: curvatures are defined as rate of rotation along the element, not second derivatives of deflection.
    # Hence Œ∫[3]&gt;0 implies +2 direction is inside curve,
    #       Œ∫[2]&gt;0 implies -3 direction is inside curve.
    ‚òºm·µ¢  = SVector(o.GJ*‚àÇ0(Œ∫)[1],o.EI*‚àÇ0(Œ∫)[2],o.EI*‚àÇ0(Œ∫)[3])# replace by Œ∫‚ÇÄ


    return f·µ¢,m·µ¢,f‚Çë,m‚Çë
end;



# Static Euler beam element, with two nodes, two Gauss points and 12 degrees of freedom.

const ngp        = 2
const ndim       = 3
const ndof       = 12
const nnod       = 2;</code></pre><p>Shape functions for a beam element with support Œ∂‚àà[-1/2,1/2]. Though the shape function matrices are sparse, do not &quot;unroll&quot; them.  That would be faster but considerably clutter the code</p><pre><code class="language-julia hljs">y‚Çê(Œ∂) =            2Œ∂       # differential axial displacement or roll field
y·µ§(Œ∂) =  -4Œ∂^3    +3Œ∂       # deflection due to differential nodal transverse translation
y·µ•(Œ∂) =        Œ∂^2   - 1/4  # deflection due to differenttial rotation (bending, not torsion)
Œ∫‚Çê(Œ∂) =                2    # torsion  . Œ∫‚Çê = y‚Çê‚Ä≤ . Divide by L .
Œ∫·µ§(Œ∂) =  -24Œ∂               # curvature. Œ∫·µ§ = y·µ§‚Ä≤‚Ä≤. Divide by L¬≤.
Œ∫·µ•(Œ∂) =                2    # curvature. Œ∫·µ• = y·µ•‚Ä≤‚Ä≤. Divide by L .</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Œ∫·µ• (generic function with 1 method)</code></pre><p>Data structure describing an EulerBeam3D element as meshed</p><pre><code class="language-julia hljs">struct EulerBeam3D{Mat} &lt;: AbstractElement
    c‚Çò       :: SVector{3,ùï£}    # Position of the middle of the element, as meshed
    r‚Çò       :: Mat33{ùï£}        # Orientation of the element, as meshed, represented by a rotation matrix (from global to local)
    Œ∂gp      :: SVector{ngp,ùï£}  # Location of the Gauss points for the normalized element with length 1
    Œ∂nod     :: SVector{nnod,ùï£} # Location of the nodes for the normalized element with length 1
    tg‚Çò      :: SVector{ndim,ùï£} # Vector connecting the nodes of the element in the global coordinate system
    tg‚Çë      :: SVector{ndim,ùï£} # Vector connecting the nodes of the element in the local coordinate system
    y‚Çê       :: SVector{ngp,ùï£}  # Value at gp of shape function for differential axial displacement or roll field
    y·µ§       :: SVector{ngp,ùï£}  # Value at gp of shape function for deflection due to differential nodal transverse translation
    y·µ•       :: SVector{ngp,ùï£}  # Value at gp of shape function for deflection due to differenttial rotation (bending, not torsion)
    Œ∫‚Çê       :: SVector{ngp,ùï£}  # Value at gp of shape function for torsion  . Œ∫‚Çê = y‚Çê‚Ä≤ . Divided by L .
    Œ∫·µ§       :: SVector{ngp,ùï£}  # Value at gp of shape function for curvature. Œ∫·µ§ = y·µ§‚Ä≤‚Ä≤. Divided by L¬≤.
    Œ∫·µ•       :: SVector{ngp,ùï£}  # Value at gp of shape function for curvature. Œ∫·µ• = y·µ•‚Ä≤‚Ä≤. Divided by L .
    L        :: ùï£
    dL       :: SVector{ngp,ùï£}  # length associated to each Gauss point
    mat      :: Mat # used to store material properties (BeamCrossSection, for example)
end</code></pre><p>For performance, <code>residual</code> will only accept differentiation to first order</p><pre><code class="language-julia hljs">Muscade.nosecondorder(::Type{&lt;:EulerBeam3D}) = Val(true)</code></pre><p>Define nodes, classes, and field names of dofs</p><pre><code class="language-julia hljs">Muscade.doflist(     ::Type{&lt;:EulerBeam3D}) =
        (inod = (1,1,1,1,1,1, 2,2,2,2,2,2),
         class= ntuple(i-&gt;:X,ndof),
         field= (:t1,:t2,:t3,:r1,:r2,:r3, :t1,:t2,:t3,:r1,:r2,:r3) )</code></pre><p>Constructor for the EulerBeam3D element. Arguments: node list, material, and direction of the first bending axis in the global coordinate system.</p><pre><code class="language-julia hljs">function EulerBeam3D(nod::Vector{Node};mat,orient2::SVector{ndim,ùï£}=SVector(0.,1.,0.))
    c       = coord(nod)
    # Position of the middle of the element in the global coordinate system (as-meshed)
    c‚Çò      = SVector{ndim}((c[1]+c[2])/2)
    # Length and tangential vector to the element in the global coordinate system
    tg‚Çò     = SVector{ndim}( c[2]-c[1]   )
    L       = norm(tg‚Çò)
    t       = tg‚Çò/L
    # Create t, n, b which are the longitudinal and two transverse unit vectors to the element (as-meshed).
    # NB: orient2, provided by the user, will define the first bending axis.
    orient2/= norm(orient2)
    n       = orient2 - t*dot(orient2,t)
    nn      = norm(n)
    nn&gt;1e-3 || muscadeerror(&quot;Provide a &#39;orient&#39; input that is not nearly parallel to the element&quot;)
    n      /= nn
    b       = cross(t,n)
    r‚Çò      = SMatrix{ndim,ndim}(t...,n...,b...)
    # Tangential vector and node coordinates in the local coordinate system
    tg‚Çë     = SVector{ndim}(L,0,0)
    # Length associated to each Gauss point
    dL      = SVector{ngp }(L/2   , L/2 )
    # Location Œ∂gp of the Gauss points for a unit-length beam element, with nodes at Œ∂nod=¬±1/2.
    Œ∂gp     = SVector{ngp }(-1/2‚àö3,1/2‚àö3) # Œ∂‚àà[-1/2,1/2]
    Œ∂nod    = SVector{nnod}(-1/2  ,1/2  ) # Œ∂‚àà[-1/2,1/2]
    shapes  = (y‚Çê.(Œ∂gp), y·µ§.(Œ∂gp), y·µ•.(Œ∂gp), Œ∫‚Çê.(Œ∂gp)/L, Œ∫·µ§.(Œ∂gp)/L^2, Œ∫·µ•.(Œ∂gp)/L)
    return EulerBeam3D(c‚Çò,r‚Çò,Œ∂gp,Œ∂nod,tg‚Çò,tg‚Çë,shapes...,L,dL,mat)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.EulerBeam3D</code></pre><p>Define now the residual function for the EulerBeam3D element.</p><pre><code class="language-julia hljs">@espy function Muscade.residual(o::EulerBeam3D,   X,U,A,t,SP,dbg)
    X‚ÇÄ          = ‚àÇ0(X)
    TX‚ÇÄ         = revariate{1}(X‚ÇÄ)
    Tgp,TŒµ,Tv‚Çõ‚Çò,Tr‚Çõ‚Çò = kinematics(o,TX‚ÇÄ)

    P,ND        = constants(X,U,A,t),length(X)
    X_          = motion{P}(X)
    ‚òºŒµ ,Œµ‚àÇX‚ÇÄ    = composewithJacobian{P,ND,ndof}(TŒµ,X_)
    v‚Çõ‚Çò‚àÇX‚ÇÄ       =                    compose(‚àÇ{P,ndof}(Tv‚Çõ‚Çò  ),X‚ÇÄ )
    r‚Çõ‚Çò          = motion‚Åª¬π{P-1,ND  }(compose(value{P}(Tr‚Çõ‚Çò  ),X_))
    v·µ¢‚ÇÄ         = (SVector(0,0,0),)
    v·µ¢‚ÇÅ         = ND‚â•1 ? (v·µ¢‚ÇÄ...,   spin‚Åª¬π(‚àÇ0(r‚Çõ‚Çò)&#39; ‚àò‚ÇÅ ‚àÇ1(r‚Çõ‚Çò))) : v·µ¢‚ÇÄ
    v·µ¢          = ND‚â•2 ? (v·µ¢‚ÇÅ...,   spin‚Åª¬π(‚àÇ1(r‚Çõ‚Çò)&#39; ‚àò‚ÇÅ ‚àÇ1(r‚Çõ‚Çò) + ‚àÇ0(r‚Çõ‚Çò)&#39; ‚àò‚ÇÅ ‚àÇ2(r‚Çõ‚Çò))) : v·µ¢‚ÇÅ

    gp          = ntuple(ngp) do igp
        Tx,TŒ∫   = Tgp[igp].x, Tgp[igp].Œ∫
        ‚òºx ,x‚àÇX‚ÇÄ= composewithJacobian{P,ND,ndof}(Tx,X_)
        ‚òºŒ∫,Œ∫‚àÇX‚ÇÄ = composewithJacobian{P,ND,ndof}(TŒ∫,X_)
        f·µ¢,m·µ¢,f‚Çë,m‚Çë = ‚òºresultants(o.mat,Œµ,Œ∫,x,r‚Çõ‚Çò,v·µ¢)          # call the &quot;resultant&quot; function to compute loads (local coordinates) from strains/curvatures/etc. using material properties. Note that output is dual of input.
        R       = (f·µ¢ ‚àò‚ÇÄ Œµ‚àÇX‚ÇÄ + m·µ¢ ‚àò‚ÇÅ Œ∫‚àÇX‚ÇÄ + f‚Çë ‚àò‚ÇÅ x‚àÇX‚ÇÄ + m‚Çë ‚àò‚ÇÅ v‚Çõ‚Çò‚àÇX‚ÇÄ) * o.dL[igp]     # Contribution to the local nodal load of this Gauss point  [ndof] = scalar*[ndof] + [ndim]‚ãÖ[ndim,ndof] + [ndim]‚ãÖ[ndim,ndof]
        @named(R)
    end
    R               = sum(gp·µ¢.R for gp·µ¢‚ààgp)
    return R,noFB
end
function kinematics(o::EulerBeam3D,X‚ÇÄ)
    c‚Çò,r‚Çò,tg‚Çò,tg‚Çë,Œ∂nod,Œ∂gp,L  = o.c‚Çò,o.r‚Çò,o.tg‚Çò,o.tg‚Çë,o.Œ∂nod,o.Œ∂gp,o.L   # As-meshed element coordinates and describing tangential vector

    # transformation to corotated system
    u·µß‚ÇÅ,v·µß‚ÇÅ,u·µß‚ÇÇ,v·µß‚ÇÇ  = SVector{3}(X‚ÇÄ[i] for i‚àà1:3), SVector{3}(X‚ÇÄ[i] for i‚àà4:6),SVector{3}(X‚ÇÄ[i] for i‚àà7:9),SVector{3}(X‚ÇÄ[i] for i‚àà10:12)
    v‚Çó‚ÇÇ,r‚Çõ‚Çò,v‚Çõ‚Çò = fast(SVector(v·µß‚ÇÅ...,v·µß‚ÇÇ...)) do v
        v·µß‚ÇÅ,v·µß‚ÇÇ = SVector{3}(v[i] for i‚àà1:3), SVector{3}(v[i] for i‚àà4:6)
        r‚Çõ‚ÇÅ              = fast(Rodrigues,v·µß‚ÇÅ)
        r‚Çõ‚ÇÇ              = fast(Rodrigues,v·µß‚ÇÇ)
        v‚Çó‚ÇÇ              = 0.5*Rodrigues‚Åª¬π(r‚Çõ‚ÇÇ ‚àò‚ÇÅ r‚Çõ‚ÇÅ&#39;)
        r‚Çõ‚Çò              = fast(Rodrigues,v‚Çó‚ÇÇ) ‚àò‚ÇÅ r‚Çõ‚ÇÅ ‚àò‚ÇÅ o.r‚Çò
        v‚Çõ‚Çò              = Rodrigues‚Åª¬π(r‚Çõ‚Çò)
        return v‚Çó‚ÇÇ,r‚Çõ‚Çò,v‚Çõ‚Çò
    end
    c‚Çõ               = 0.5*(u·µß‚ÇÅ+u·µß‚ÇÇ)
    u‚Çó‚ÇÇ              = r‚Çõ‚Çò&#39;‚àò‚ÇÅ(u·µß‚ÇÇ+tg‚Çò*Œ∂nod[2]-c‚Çõ)-tg‚Çë*Œ∂nod[2]    #Local displacement of node 2

    # interpolation
    Œµ               = ‚àö((u‚Çó‚ÇÇ[1]+L/2)^2+u‚Çó‚ÇÇ[2]^2+u‚Çó‚ÇÇ[3]^2)*2/L - 1.
    gp              = ntuple(ngp) do igp
        y‚Çê,y·µ§,y·µ•,Œ∫‚Çê,Œ∫·µ§,Œ∫·µ• = o.y‚Çê[igp],o.y·µ§[igp],o.y·µ•[igp],o.Œ∫‚Çê[igp],o.Œ∫·µ§[igp],o.Œ∫·µ•[igp]
        Œ∫           = SVector(         Œ∫‚Çê*v‚Çó‚ÇÇ[1], Œ∫·µ§*u‚Çó‚ÇÇ[2]+Œ∫·µ•*v‚Çó‚ÇÇ[3], Œ∫·µ§*u‚Çó‚ÇÇ[3]-Œ∫·µ•*v‚Çó‚ÇÇ[2])
        y           = SVector(y‚Çê*u‚Çó‚ÇÇ[1]         , y·µ§*u‚Çó‚ÇÇ[2]+y·µ•*v‚Çó‚ÇÇ[3], y·µ§*u‚Çó‚ÇÇ[3]-y·µ•*v‚Çó‚ÇÇ[2])
        x           = r‚Çõ‚Çò‚àò‚ÇÅ(tg‚Çë*Œ∂gp[igp]+y)+c‚Çõ+c‚Çò
        (Œ∫=Œ∫,x=x)
    end
    return gp,Œµ,v‚Çõ‚Çò,r‚Çõ‚Çò
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">kinematics (generic function with 1 method)</code></pre><h1 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h1><p>Defining the beam properties and loading. Beam clamped at both ends, subjected to uniform distributed load of intensity q</p><pre><code class="language-julia hljs">L = 10.0;  # Beam length [m]
q = 10.0;  # Uniform lateral load [N/m]
EI = 1e6;  # Bending stiffness [Nm¬≤]
EA = 1e6;  # Axial stiffness [N]
GJ = 1e3;  # Torsional stiffness [Nm¬≤]</code></pre><p>Analytical solutions from <a href="https://mechanics.tamu.edu/wp-content/uploads/2017/03/Appendix-A_Exact-Analytical-Solutions.pdf">here</a> (which contains errors), and checked against <a href="https://faculty.arch.tamu.edu/anichols/Courses/Arch%20331/Spring%20last/Notes/Files/24_NS8-2beamdiagrams_RycFHMO.pdf">this source</a></p><pre><code class="language-julia hljs">x = (0:L/100:L);</code></pre><p>Deflection (the two sources agree)</p><pre><code class="language-julia hljs">w = q*L^2*x.^2 .* (1.0 .-x/L).^2 ./ (24.0*EI);</code></pre><p>Slope (verified by differentiating the above)</p><pre><code class="language-julia hljs">Œ∏ = -q*L^2*x.*(1.0 .- 3.0*x/L + 2.0*x.^2/L^2) / (12.0*EI);</code></pre><p>Curvature (derived)</p><pre><code class="language-julia hljs">Œ∫ = -q*L^2*(1.0 .- 6.0*x/L + 6.0*x.^2/L^2) / (12.0*EI);</code></pre><p>Bending moment (the two sources do not agree)</p><pre><code class="language-julia hljs">M = -q*L^2*(1.0 .- 6.0*x/L + 6.0*x.^2/L^2) / 12.0;</code></pre><p>Shear force (the two sources agree)</p><pre><code class="language-julia hljs">V = q*L*(1.0 .- 2.0*x/L) / 2.0;</code></pre><p>Create the model</p><pre><code class="language-julia hljs">nel         = 20
nnodes        = nel+1
nodeCoord   = hcat((0:L/nel:L),zeros(Float64,nnodes,2))
mat         = BeamCrossSection(EA=EA,EI=EI,GJ=GJ)
model       = Model(:TestModel)
nodid       = addnode!(model,nodeCoord)
mesh        = hcat(nodid[1:nnodes-1],nodid[2:nnodes])
eleid       = addelement!(model,EulerBeam3D,mesh;mat=mat,orient2=SVector(0.,1.,0.))

[addelement!(model,Hold,[nodid[1]]  ;field) for field‚àà[:t1,:t2,:t3,:r1,:r2,:r3]]                                # Clamp end 1
[addelement!(model,Hold,[nodid[end]];field) for field‚àà[:t1,:t2,:t3,:r1,:r2,:r3]]                                # Clamp end 2
[addelement!(model,DofLoad,[nodid[nodeidx]];field=:t2,value=t-&gt;-min(1,t)*q*L/nnodes) for nodeidx=1:nnodes];          # Distributed vertical load q</code></pre><p>Solve the problem</p><pre><code class="language-julia hljs">initialstate    = initialize!(model);</code></pre><p>state           = solve(SweepX{0};initialstate,time=[0.,1.])</p><h1 id="Fetch-and-display-results"><a class="docs-heading-anchor" href="#Fetch-and-display-results">Fetch and display results</a><a id="Fetch-and-display-results-1"></a><a class="docs-heading-anchor-permalink" href="#Fetch-and-display-results" title="Permalink"></a></h1><p>w_ = getdof(state[2];field=:t2,nodID=nodid[1:nnodes]) Œ∏_ = getdof(state[2];field=:r3,nodID=nodid[1:nnodes]) req = @request gp(resultants(m)) out = getresult(state[2],req,eleid) Mgp1_ = [ out[idxEl].gp[1][:resultants][:m][2] for idxEl ‚àà 1:nel] Mgp2_ = [ out[idxEl].gp[2][:resultants][:m][2] for idxEl ‚àà 1:nel] xgp1 = (L/nel)<em>((0.5-1.0/(2</em>sqrt(3))):1:nel) xgp2 = (L/nel)<em>((0.5+1.0/(2</em>sqrt(3))):1:nel) req = @request gp(Œ∫) out = getresult(state[2],req,eleid) Œ∫gp1_ = [ out[idxEl].gp[1].Œ∫[1][2] for idxEl ‚àà 1:nel] Œ∫gp2_ = [ out[idxEl].gp[2].Œ∫[1][2] for idxEl ‚àà 1:nel];</p><p>fig      = Figure(size = (1000,1000)) ax = Axis(fig[1,1], ylabel=&quot;Deflection w [m]&quot;,        yminorgridvisible = true,xminorgridvisible = true,xticks = (0:L/nel:L)) lines!(fig[1,1], x,            -w,                       label=&quot;Analytical solution&quot;) scatter!(fig[1,1],(0:L/nel:L),  w<em>[:],                  label=&quot;Muscade/beam&quot;); axislegend() ax=Axis(fig[2,1], ylabel=&quot;Rotation Œ∏ [deg]&quot;,        yminorgridvisible = true,xminorgridvisible = true,xticks = (0:L/nel:L)) lines!(fig[2,1],x,            Œ∏*180/pi,                 label=&quot;Analytical solution&quot;) scatter!(fig[2,1],(0:L/nel:L),  Œ∏</em>[:]*180/pi,           label=&quot;Muscade/beam&quot;); ax=Axis(fig[3,1], ylabel=&quot;Curvature Œ∫ [m‚Åª¬π]&quot;,       yminorgridvisible = true,xminorgridvisible = true,xticks = (0:L/nel:L)) lines!(fig[3,1],x,            Œ∫,                        label=&quot;Analytical solution&quot;) scatter!(fig[3,1],[xgp1;xgp2],  [Œ∫gp1<em>;Œ∫gp2</em>],          label=&quot;Muscade/beam&quot;); ax=Axis(fig[4,1], ylabel=&quot;Bending moment M [Nm]&quot;,   yminorgridvisible = true,xminorgridvisible = true,xticks = (0:L/nel:L), xlabel=&quot;Position on beam [m]&quot;) lines!(fig[4,1],x,            M,                        label=&quot;Analytical solution&quot;) scatter!(fig[4,1],[xgp1;xgp2],  [Mgp1<em>;Mgp2</em>],          label=&quot;Muscade/beam&quot;);</p><p>currentDir = @<strong>DIR</strong> if occursin(&quot;build&quot;, currentDir)     save(normpath(joinpath(currentDir,&quot;..&quot;,&quot;src&quot;,&quot;assets&quot;,&quot;beam.png&quot;)),fig) elseif occursin(&quot;examples&quot;, currentDir)     save(normpath(joinpath(currentDir,&quot;beam.png&quot;)),fig) end <img src="assets/beam.png" alt="Result"/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Elements.html">¬´ Implementing new elements</a><a class="docs-footer-nextpage" href="DecayAnalysis.html">Estimating model parameters ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Tuesday 6 May 2025 08:48">Tuesday 6 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
