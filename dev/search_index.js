var documenterSearchIndex = {"docs":
[{"location":"TypeStable.html#typestab","page":"Type-stability","title":"Type-stability","text":"","category":"section"},{"location":"TypeStable.html#Introduction","page":"Type-stability","title":"Introduction","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"This text presents type stability, which is one of the important concepts that one needs to understand in order to write high-performance Julia code.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"This text is aimed at Julia users that are familiar with composite types, abstract types, functions, methods and multiple dispatch. At the same time, as little advanced Julia syntax as possible is used, to make the text accessible.","category":"page"},{"location":"TypeStable.html#To-type,-or-not-to-type","page":"Type-stability","title":"To type, or not to type","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The developers of Julia wanted to solve the two-language problem.  They have achieved this and produced a language that \"walks like Python and runs like C\".  Julia \"walks like Python\", because it is not necessary to systematically define the type of every variable that appears in the code.  It \"runs like C\" because it is a compiled language, and produces (or rather, can produce) highly efficient machine code.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Python and MATLAB are examples of interpreted language.  In a pure interpreted language, the type of the variables is computed at run time, at the same time as the value of the variables.  As long as the values of the inputs to the code are known at the top level (in the REPL or the top script), the interpretation infers, step by step the type of the variables, all the way down the call stack. This allows to write functions without specifying types, and this in turn allows to write generic code (for example an iterative solver that works just as well with Float64 and Float32 variables).  The disadvantage is that inferring the type of variables on the fly introduces significant overhead at run time.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"At the other end of the scale C and Fortran are examples of strictly typed compiled languages. Because the source code specifies the type of every variable in the function (both variables in the function interface, and local variables), the compiler can create efficient machine code for each function, just by considering the code of that function alone. The disadvantage is that type declaration takes time to write and clutters the source code, and (unless the language offers \"templates\", as C++ does), it may be necessary to write several methods, identical in all but types of variables, to make an algorithm available to various data types.","category":"page"},{"location":"TypeStable.html#Julia's-approach-to-type-specifications","page":"Type-stability","title":"Julia's approach to type specifications","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Julia takes the sweet spot in between, not requiring to specify the type of each variable, yet producing fast machine code. The trick is as follows: every time a method is called (so, at run time), with a combination of concrete types of arguments that has not yet been encountered for this method, the compiler quicks in.  A \"concrete type\" is the information returned by typeof() when called on a variable.  One example is Float64.  This is as opposed to an abstract type, like Real, which is a set of concrete types, and includes Float64 and Float32. In the rest of this text \"type\" will refer to \"concrete type\".","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The compiler now has the source code of the method, and the types of all the arguments. The compiler will produce a method instance (or instance, for short), which is machine code for this combination. One interesting implication is that writing strictly typed method interfaces in Julia does not provide any improvement of machine code performance: the compiler takes the type of the arguments from the calling context anyway. A strictly typed interface has the disadvantage of offering no flexibility. A method that only accepts a Vector will not accept other vector-like things like a SubArray (an array view), a Adjoint (a transposed array), a SparseMatrix or a StaticArray, even thought the method probably implements an algorithm that would compile perfectly well for all of these.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"However, providing partial specification of the type of the arguments of a method serves important purposes in Julia:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"If a function has several methods, it allows to specify which method should be executed (multiple dispatch). This is where abstract types like Real,  AbstractVector and AbstractVector{<:Real} come into their own.\nIt improves code readability, stating for example \"this method expects some vector of some real numbers - but not a string\".\nIt provides more graceful failures: \"function foo has no method that takes in a string\" is more informative that some esoteric failure down the line when attempting to add two strings.","category":"page"},{"location":"TypeStable.html#What-is-type-stability?","page":"Type-stability","title":"What is type stability?","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"If the source code of the method is well written, the source code and the concrete type of all arguments is enough information for the compiler to infer the concrete type of every variable and expression within the method.  The method is then said to be \"typestable\", and the Julia compiler will produce efficient code.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"If, for a variety of reasons that will be studied in the following, the type of a local variable cannot be inferred from the types of the arguments, the compiler will produce machine code full of \"if\"s, covering all options of what the type of each variable could be. The loss in performance is often significant, easily by a factor of 10.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"If you are yourself able to infer the type of every local variable, and every expression in a method (or script) from the types (not the values) of the arguments or from constants in the code, the function will be typestable.  Actually, as will be seen below, this inference of types is also allowed access to struct declarations, and to the types of the return values of functions called by the function you are studying.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The rest of this text will examine a variety of situations, ranging from obvious to more tricky tricky, in which it is not possible to infer the types of local variables from the types of the arguments, resulting in type instability.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"For this purpose, it will be useful to write down the information available to the compiler.  So for example, if the method","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"function add(a::Number,b::Number)\n    c = a+b\n    return c\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"is called with a of type Float64 and b of type Int32, then we will write the information available to the compiler to create an instance as","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance add(a::Float64,b::Int32)\n    c = a+b\n    return c\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance is not Julia syntax, it is just a notation introduced in this text to describe an instance.  In such instance description, a concrete type must be associated with every argument.","category":"page"},{"location":"TypeStable.html#If,-then","page":"Type-stability","title":"If, then","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Consider the following method instance","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance largest(a::Float64,b::Int64)\n    if a > b\n        c = a\n    else\n        c = b\n    end\n    return c\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The variable c will be set to either a or b. c will take the value and the type of either a or b.  The type of c depends on an operation a > b on the values of a and b: the type of c cannot be inferred from the type of arguments alone, and this code is not typestable.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Several approaches might be relevant to prevent type instability.  The simplest is to code largest so that it only accepts two arguments of the same type.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"function largest(a::R,b::R) where{R<:Real}\n    if a > b\n        c = a\n    else\n        c = b\n    end\n    return c\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The method is general, it can result in the generation of method instances like instance largest(a::Float64,b::Float64), instance largest(a::Int64,b::Int64) and many others. It cannot result in the generation of machine code for instance largest(a::Float64,b::Int64) (because R cannot be both Int64 and Float64). If we need to be able to handle variables of different types, yet want type stability, a solution is to use promotion to ensure that c is always of the same type.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"function largest(a,b)\n    pa,pb = promote(a,b)\n    if a > b\n        c = pa\n    else\n        c = pb\n    end\n    return c\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"promote is defined so that pa and pb have the same type, and this type is inferred from the types of a and b. For example, for a call instance largest(a::Float64,b::Int64), the types of pa, pb and c will be Float64, to which one can convert a Int64 variable without loss of information (well, mostly).","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Do not allow an if-then construct to return a variable which type depends on the branch taken.","category":"page"},{"location":"TypeStable.html#Method-return-value","page":"Type-stability","title":"Method return value","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"A method foo that would call the above first, not typestable, version of the method instance largest would receive as output a variable of a type that is value dependent: foo itself would not be typestable.  The workaround here is to create typestable methods for largest, as suggested above.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"One example is the method Base.findfirst(A), which given a Vector{Boolean} returns the index of the first true element of the vector.  The catch is that if all the vector's elements are false, the method returns nothing. nothing is of type Nothing, while the index is of type Int64.  Using this method will make the calling method not typestable.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Avoid methods that return variables of value-dependant types.","category":"page"},{"location":"TypeStable.html#Array-of-abstract-element-type","page":"Type-stability","title":"Array of abstract element type","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Consider the following code","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"v = [3.,1,\"Hello world!\"]\nfunction showall(v)\n    for e ∈ v\n        @show e\n    end\nend\nshowall(v)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The above call showall(v) generates a method instance","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance showall(v::Array{Any,1})\n    for e ∈ v\n        @show e\n    end\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The concrete type of e cannot be inferred from Array{Any,1}, because Any is not a concrete type. More specifically, the type of e changes from one iteration to the next: the code is not typestable. If v is of type Array{Any,1}, even if V has elements that are all of the same type, this does not help:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"v = Vector{Any}(undef,3)\nv[1] = 3.\nv[2] = 1.\nv[3] = 3.14\nshowall(v)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"e may have the same type at each iteration, but this type still cannot be inferred from the type Array{Any,1} of the argument.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"If we define w = randn(3), w has type Array{Float64,1}.  This is much more informative: every element of w is known to have the same concrete type Float64. Hence the call showall(w) generates a method instance","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance showall(v::Array{Float64,1})\n    for e ∈ v\n        @show e\n    end\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"and the compiler can infer that e is a Float64.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Wherever possible use arrays with a concrete element type.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Sometimes, the use of array with abstract element type is deliberate.  One may really wish to iterate over a heterogeneous collection of elements and apply various methods of the same function to them: we design for dynamic dispatch, and must accept that the process of deciding which method to call takes time.  Two techniques can be used to limit the performance penalty.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The first is the use of a \"function barrier\": The loop over the heterogenous array should contain as little code as possible, ideally only the access to the arrays element, and the call to a method.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"for e ∈ v\n    foo(e)\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"If v contains elements of different type, the loop is not typestable and hence slow. Yet each value of e at each iteration has its unique concrete type, for which an instance of foo will be generated: foo can be made typestable and fast.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The second, a further improvement of the first, is to group elements by concrete type, for example, using a heterogenous arrays of homogeneous arrays.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"vv = [[1.,2.,3.],[1,2]]\nfor v ∈ vv  # outerloop\n    innerloop(v)\nend\nfunction innerloop(v)\n    for e ∈ v\n        foo(e)\n    end\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Here vv is an Array{Any,1}, containing two vectors of different types. vv[1] is a Array{Float64,1} and vv[2] is a Array{Int64,1}. Function innerloop is called twice and two instances are generated","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance innerloop(v::Array{Float64,1})\n    for e ∈ v  # e is Float64\n        foo(e)\n    end\nend\ninstance innerloop(v::Array{Int64,1})\n    for e ∈ v  # e is Int64\n        foo(e)\n    end\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"and in both instances, the type of e is clearly defined: the instances are typestable.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The with this second approach is that the loop for v ∈ vv has few iterations (if the number of types is small compared to the number of elements in each types).","category":"page"},{"location":"TypeStable.html#Structure-of-abstract-field-type","page":"Type-stability","title":"Structure of abstract field type","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"A similar loss of type stability arises when reading data from structures that have a field of abstract type:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"struct SlowType\n    a\nend\nstruct JustAsBad\n    a::Real\nend\nstruct MuchBetter\n    a::Float64\nend\nfunction show_a(s)\n    @show s.a\nend\nshow_a(SlowType(3.))\nshow_a(JustAsBad(3.))\nshow_a(MuchBetter(3.))","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The first call to show_a generates","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance show_a(s::SlowType)\n    @show s.a # The concrete type of field a of type SlowType cannot be\n              # inferred from the definition of SlowType\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The second call to show_a has the same problem.  The third call generates a typestable instance","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance show_a(s::Better)\n    @show s.a # That's a Float64\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"It is often interesting to create structures with fields that can have various types. A classic example is Julia's Complex type, which can have real and imaginary components which are either both Float64, both Float32 or other more exotic choices. This can be done without losing type stability by using parametric types:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"struct FlexibleAndFast{R}\n    a::R\nend\nshow_a(FlexibleAndFast(3.))\nshow_a(FlexibleAndFast(3 ))","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The above calls generate two typestable instances of show_a","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance show_a(s::FlexibleAndFast{Float64})\n    @show s.a # That's a Float64\nend\ninstance show_a(s::FlexibleAndFast{Int64})\n    @show s.a # That's an Int64\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Always use struct with fields of concrete types.  Use parametric structure where necessary.","category":"page"},{"location":"TypeStable.html#A-note-on-constructors-for-parametric-types","page":"Type-stability","title":"A note on constructors for parametric types","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Consider a struct definition without inner constructor:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"struct MyType{A,B}\n    a::A\n    b::B\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Julia will automatically generate a constructor method with signature","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"MyType{A,B}(a::A,b::B)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Julia will also produce another method with signature","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"MyType(a::A,b::B)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"because for MyType, it is possible to infer all type parameters from the types of the inputs to the constructor. Other constructors like","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"MyType{A}(a::A,b::B)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"have to be defined explicitly (how should the compiler decide whether to interpret a single type-parameter input as A or B...).","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Consider another example:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"struct MyType{A,B,C}\n    a::A\n    b::B\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Julia will automatically generate a constructor method with signature","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"MyType{A,B,C}(a::A,b::B)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"but will not generate other methods.  A method like","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"MyType{C}(a::A,b::B)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"would have to be defined explicitly.","category":"page"},{"location":"TypeStable.html#StaticArrays","page":"Type-stability","title":"StaticArrays","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Julia Arrays are an example of parametric type, where the parameters are the type of elements, and the dimension (the number of indices). Importantly, the size of the array is not part of the type, it is a part of the value of the array.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The package StaticArrays.jl provides the type StaticArray, useful for avoiding another performance problem: garbage collection that follows the allocation of Arrays on the heap. This is because StaticArray are allocated on the stack, simplifying runtime memory management.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"using StaticArrays\nSA = SVector{3,Float64}([1.,2.,3.])\nSA = SVector(1.,2.,3.)\nSA = SVector([1.,2.,3.])","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The first call to SVector is typestable: all the information needed to infer the type of SA is provided in curly braces. The second call is typestable too, because the compiler can deduce the same information from the type and number of inputs. The third call is problematic: while the type of the elements of SA can be inferred by the compiler, the length of [1.,2.,3.] is part of this array's value, not type. The type of SA has a parameter that depends on the value (the size) of the argument passed to the constructor.  Not only does this generate an instance of the constructor that is not type stable, but the non-inferable type of SA \"contaminates\" the calling code with type instability.","category":"page"},{"location":"TypeStable.html#Val","page":"Type-stability","title":"Val","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"What if we want to write a function that takes an Vector as an input, processes it (for example just keeps it as it is), and returns a SVector of the same shape. Of course we want this function to be general and not be limited to a given array size and we want this function to be typestable, for good performance.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"First attempt:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"function static(v::Vector)\n    return SVector{length(v),eltype(v)}(v)\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"This function is not typestable. It constructs a variable of type StaticArray{(3,),Float64}, where 3 is obtained as the length of v, and the length is part of the value of an Array.  Value-to-type alarm!","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"One possible solution is to use Val. Let us say that static is called by a function foo within which the length of v can be inferred at compile time.  We could create the following code","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"function static(v,::Val{L}) where{L}\n    return SVector{L,Float64}(v)\nend\nfunction foo()\n    Val3 = Val(3)\n    Val4 = Val(4)\n    @show static([1.,2.,3.]   ,Val3)\n    @show static([1.,2.,3.,4.],Val4)\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The call Val(3) generates a variable, of type Val{3}. Clearly, Val as a function is not typestable, since it creates a variable of a type depending on the value of its argument.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"However, function foo is typestable.  This may come as a surprise, but two things conspire to allow this:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The source code of foo explicitly mentions the constants 3 and 4, and the compiler has access to it.\nThe compiler is greedy - it evaluates at compile time whenever possible.  Hence the call Val(3) is evaluated during compilation, and Val3 is known to the compiler to be a a value-empty variable of type Val{3}.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"In foo, the method static is called twice, leading to the generation of two typestable instances","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance static(v,::Val{3})\n    return SVector{3,Float64}(v)\nend\ninstance static(v,::Val{4})\n    return SVector{4,Float64}(v)\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"What if the length of the vectors is not defined as a constant in foo?  If this length is the result of some computation, the call to Val with not be typestable. If foo is high enough in the call hierarchy, and outside any time-critical loop, this is not an issue: only foo will not be typestable, but functions that it calls can still be typestable (cf. the function barrier pattern).","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Val allows to move type instability up the call hierarchy, or eliminate it altogether.","category":"page"},{"location":"TypeStable.html#Functions","page":"Type-stability","title":"Functions","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The type Function is an abstract datatype, and every function in Julia has its own type.  Here we refer not to the type of the variables returned by the function, but to the function being a variable in itself.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The implication is that if we have a scalar-valued function energy that takes a function signal as an input, and computes the energy of the signal over some interval, then a new instance of energy will be compiled every time it is called with an new argument signal.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"This also has implications on how to store functions in a struct. This is not typestable","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"struct MyType\n    foo::Function\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"but this is","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"struct MyType{Tfoo}\n    foo::Tfoo\nend","category":"page"},{"location":"TypeStable.html#@code_warntype","page":"Type-stability","title":"@code_warntype","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"One important tool to check that an instance is typestable is the macro @code_warntype. For example","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"v = randn(3)\n@code_warntype Val(length(v))\n@code_warntype static(v,Val(length(v)))","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The first invocation of @code_warntype outputs a semi-compiled code, and highlights some of the types in red: the call Val(3) is not typestable. The second invocation of @code_warntype produces an output in which all types are highlighted in blue: the call to static is typestable.  Note that @code_warntype only analyses the compilation of the outermost function static - given the arguments v and Val(length(v)).","category":"page"},{"location":"TypeStable.html#Profile.jl","page":"Type-stability","title":"Profile.jl","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Profile.jl and ProfileView.jl together provide a \"flame graph\", a graphical representation of where processor time goes, in which code that is not typestable is highlighted. Output from the profiler often shows how type instability propagates: a single variable that is not typestable makes \"anything it touches\" type unstable.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Particularly useful, one can click on a function, and then type warntype_last() in the REPL to get to see a @code_warntype output for that function.","category":"page"},{"location":"StaticBeamAnalysis.html#Static-analysis-of-a-beam","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"","category":"section"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"Cantilever bend, with out-of-plane load leading to a three-dimensional response mobilizing axial force, bending moment and torque. Comparison to solutions by Longva (2015) and Crisfield (1990)","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"using Muscade, StaticArrays, GLMakie\nusing Muscade.Toolbox\n\nR = 100.0;  # Radius of the bend [m]\nEI₂ = 833.33e3;  # Bending stiffness [Nm²]\nEI₃ = 833.33e3;  # Bending stiffness [Nm²]\nEA = 1e9;  # Axial stiffness [N]\nGJ = 705e3;  # Torsional stiffness [Nm²]\nnothing #hide","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"Create the model","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"nel         = 8\nnnodes      = nel+1\nnodeCoord   = hcat( 0 .+ R*cos.(3π/2 .+ ((1:nnodes).-1)/(nnodes-1)*π/4),\n                    0 .+ zeros(Float64,nnodes,1),\n                    R .+ R*sin.(3π/2 .+ ((1:nnodes).-1)/(nnodes-1)*π/4))\nmat         = BeamCrossSection(EA=EA,EI₂=EI₂,EI₃=EI₃,GJ=GJ,μ=1.,ι₁=1.)\nmodel       = Model(:TestModel)\nnodid       = addnode!(model,nodeCoord)\nmesh        = hcat(nodid[1:nnodes-1],nodid[2:nnodes])\neleid       = addelement!(model,EulerBeam3D,mesh;mat=mat,orient2=SVector(0.,1.,0.))\n[addelement!(model,Hold,[nodid[1]]  ;field) for field∈[:t1,:t2,:t3,:r1,:r2,:r3]]; # Clamp at one end\nnothing #hide","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"Define the loading procedure. First 300 N then 450  and 600 N","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"@functor with() function load(t)\n    t<=1. ? load=t*300. :\n    t>1. && t<=2. ? load=300. +(t-1)*150. :\n    load=450. +(t-2)*150.\nend\naddelement!(model,DofLoad,[nodid[nnodes]];field=:t2,value=load);                                        # Force along axis2 at other\nnothing #hide","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"Run the static analysis","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"initialstate    = initialize!(model);\nloadSteps = [0.,1.,2.,3.];\nnLoadSteps = length(loadSteps)\nstate           = solve(SweepX{0};initialstate,time=loadSteps,verbose=true,maxΔx=1e-9);\nnothing #hide","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"Fetch and show beam profile for all load cases","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"x_ = [getdof(state[idxLoad];field=:t1,nodID=nodid[1:nnodes]) for idxLoad ∈ 1:nLoadSteps]\ny_ = [getdof(state[idxLoad];field=:t2,nodID=nodid[1:nnodes]) for idxLoad ∈ 1:nLoadSteps]\nz_ = [getdof(state[idxLoad];field=:t3,nodID=nodid[1:nnodes]) for idxLoad ∈ 1:nLoadSteps]\n\nfig     = Figure(size = (1000,1000))\nax      = Axis3(fig[1,1],xlabel=\"x [m]\", ylabel=\"y [m]\", zlabel=\"z [m]\",aspect=:equal)\nclr = [:black,:blue,:green,:red]\nfor idxLoad ∈ 1:nLoadSteps\n    draw!(ax,state[idxLoad];EulerBeam3D=(;nseg=10,line_color=clr[idxLoad]))\nend\nxlims!(ax, 0,70); ylims!(ax, 0,60); zlims!(ax, 0,40);\ncurrentDir = @__DIR__\nif occursin(\"build\", currentDir)\n    save(normpath(joinpath(currentDir,\"..\",\"src\",\"assets\",\"StaticBeamAnalysis1.png\")),fig)\nelseif occursin(\"examples\", currentDir)\n    save(normpath(joinpath(currentDir,\"StaticBeamAnalysis1.png\")),fig)\nend","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"(Image: Result)","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"Fetch and display results at the Gauss points for the last load case","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"idxLoad = 4;\nnothing #hide","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"Location of the 4 Gauss points","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"xgp1 = (1. /nel)*( (0.5-1/2*sqrt(3/7+2/7*sqrt(6/5))) :1:nel)\nxgp2 = (1. /nel)*( (0.5-1/2*sqrt(3/7-2/7*sqrt(6/5))) :1:nel)\nxgp3 = (1. /nel)*( (0.5+1/2*sqrt(3/7-2/7*sqrt(6/5))) :1:nel)\nxgp4 = (1. /nel)*( (0.5+1/2*sqrt(3/7+2/7*sqrt(6/5))) :1:nel)\nxgps = [xgp1;xgp2;xgp3;xgp4];\nnothing #hide","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"Axial force","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"req = @request gp(resultants(fᵢ))\nout = getresult(state[idxLoad],req,eleid)\nFgp1_ = [ out[idxEl].gp[1][:resultants][:fᵢ] for idxEl ∈ 1:nel]\nFgp2_ = [ out[idxEl].gp[2][:resultants][:fᵢ] for idxEl ∈ 1:nel]\nFgp3_ = [ out[idxEl].gp[3][:resultants][:fᵢ] for idxEl ∈ 1:nel]\nFgp4_ = [ out[idxEl].gp[4][:resultants][:fᵢ] for idxEl ∈ 1:nel];\nnothing #hide","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"Bending moments","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"req = @request gp(resultants(mᵢ))\nout = getresult(state[idxLoad],req,eleid)\nMgp1_ = [ out[idxEl].gp[1][:resultants][:mᵢ] for idxEl ∈ 1:nel]\nMgp2_ = [ out[idxEl].gp[2][:resultants][:mᵢ] for idxEl ∈ 1:nel]\nMgp3_ = [ out[idxEl].gp[3][:resultants][:mᵢ] for idxEl ∈ 1:nel]\nMgp4_ = [ out[idxEl].gp[4][:resultants][:mᵢ] for idxEl ∈ 1:nel];\nnothing #hide","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"Strains","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"req = @request ε\nout = getresult(state[idxLoad],req,eleid)\nεgp1_ = [ out[idxEl].ε[1] for idxEl ∈ 1:nel]\nεgp2_ = [ out[idxEl].ε[1] for idxEl ∈ 1:nel];\nεgp3_ = [ out[idxEl].ε[1] for idxEl ∈ 1:nel];\nεgp4_ = [ out[idxEl].ε[1] for idxEl ∈ 1:nel];\nnothing #hide","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"Curvatures","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"req = @request gp(κgp)\nout = getresult(state[idxLoad],req,eleid)\nκgp1_ = [ out[idxEl].gp[1].κgp[1] for idxEl ∈ 1:nel]\nκgp2_ = [ out[idxEl].gp[2].κgp[1] for idxEl ∈ 1:nel]\nκgp3_ = [ out[idxEl].gp[3].κgp[1] for idxEl ∈ 1:nel]\nκgp4_ = [ out[idxEl].gp[4].κgp[1] for idxEl ∈ 1:nel];\nnothing #hide","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"Plot strains, etc. at Gauss points","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"fig      = Figure(size = (1000,1000))\nax=Axis(fig[1,1], ylabel=\"Forces F [N]\",       yminorgridvisible = true,xminorgridvisible = true,xticks = (0:1. /nel:1))\nscatter!(ax,xgps,  [[Fgp1_[iel][1] for iel=1:nel] ; [Fgp2_[iel][1] for iel=1:nel] ; [Fgp3_[iel][1] for iel=1:nel] ; [Fgp4_[iel][1] for iel=1:nel]],          label=\"F₁\");\nax.title = \"Internal loads, elongation and curvature at last load step\"\naxislegend();\nax=Axis(fig[2,1], ylabel=\"Strain [-]\",       yminorgridvisible = true,xminorgridvisible = true,xticks = (0:1. /nel:1))\nscatter!(ax,xgps,  [[εgp1_[iel][1] for iel=1:nel] ; [εgp2_[iel][1] for iel=1:nel] ; [εgp3_[iel][1] for iel=1:nel] ; [εgp4_[iel][1] for iel=1:nel]],          label=\"ε\");\nax=Axis(fig[3,1], ylabel=\"Moments M [Nm]\",       yminorgridvisible = true,xminorgridvisible = true,xticks = (0:1. /nel:1))\nscatter!(ax,xgps,  [[Mgp1_[iel][1] for iel=1:nel] ; [Mgp2_[iel][1] for iel=1:nel] ; [Mgp3_[iel][1] for iel=1:nel] ; [Mgp4_[iel][1] for iel=1:nel]],          label=\"M₁\");\nscatter!(ax,xgps,  [[Mgp1_[iel][2] for iel=1:nel] ; [Mgp2_[iel][2] for iel=1:nel] ; [Mgp3_[iel][2] for iel=1:nel] ; [Mgp4_[iel][2] for iel=1:nel]],          label=\"M₂\");\nscatter!(ax,xgps,  [[Mgp1_[iel][3] for iel=1:nel] ; [Mgp2_[iel][3] for iel=1:nel] ; [Mgp3_[iel][3] for iel=1:nel] ; [Mgp4_[iel][3] for iel=1:nel]],          label=\"M₃\");\naxislegend()\nax=Axis(fig[4,1], ylabel=\"Curvature κ [m⁻¹]\",       yminorgridvisible = true,xminorgridvisible = true,xticks = (0:1. /nel:1),xlabel=\"Position along beam / beam length [-]\")\nscatter!(ax,xgps,  [[κgp1_[iel][1] for iel=1:nel] ; [κgp2_[iel][1] for iel=1:nel] ; [κgp3_[iel][1] for iel=1:nel] ; [κgp4_[iel][1] for iel=1:nel]],          label=\"κ₁\");\nscatter!(ax,xgps,  [[κgp1_[iel][2] for iel=1:nel] ; [κgp2_[iel][2] for iel=1:nel] ; [κgp3_[iel][2] for iel=1:nel] ; [κgp4_[iel][2] for iel=1:nel]],          label=\"κ₂\");\nscatter!(ax,xgps,  [[κgp1_[iel][3] for iel=1:nel] ; [κgp2_[iel][3] for iel=1:nel] ; [κgp3_[iel][3] for iel=1:nel] ; [κgp4_[iel][3] for iel=1:nel]],          label=\"κ₃\");\naxislegend()\nif occursin(\"build\", currentDir)\n    save(normpath(joinpath(currentDir,\"..\",\"src\",\"assets\",\"StaticBeamAnalysis2.png\")),fig)\nelseif occursin(\"examples\", currentDir)\n    save(normpath(joinpath(currentDir,\"StaticBeamAnalysis2.png\")),fig)\nend","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"(Image: Result)","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"Show comparison with solutions by Longva (2015) and Crisfield (1990)","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"# Load                300 N                       450 N                       600 N\n#                     x,y,z                       x,y,z                       x,y,z\n# Disp Longva         58.56, 40.47, 22.18         51.99, 48.72, 18.45         46.91, 53.64, 15.65\n# Disp Crisfield      58.53, 40.53, 22.16         51.93, 48.79, 18.43         46.84, 53.71, 15.61\nheight = [  nodeCoord[end,1]+x_[2][end], 58.56, 58.53, nodeCoord[end,1]+x_[3][end], 51.99, 51.93, nodeCoord[end,1]+x_[4][end], 46.91, 46.84,\n            nodeCoord[end,2]+y_[2][end], 40.47, 40.53, nodeCoord[end,2]+y_[3][end], 48.72, 48.79, nodeCoord[end,2]+y_[4][end], 53.64, 53.71,\n            nodeCoord[end,3]+z_[2][end], 22.18, 22.16, nodeCoord[end,3]+z_[3][end], 18.45, 18.43, nodeCoord[end,3]+z_[4][end], 15.65, 15.61]\ncolors = [:red, :blue, :green]\ntbl = (cat = [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9],height,\n       grp = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3])\nfig = Figure(size = (2000, 400))\nax = Axis(fig[1,1], xticks = (1:9, [\"x @ 300 N\", \"x @ 450 N\", \"x @ 600 N\", \"y @ 300 N\", \"y @ 450 N\", \"y @ 600 N\", \"z @ 300 N\", \"z @ 450 N\", \"z @ 600 N\"]),\n                    ylabel = \"End node coordinate [m]\")\nbarplot!(ax, tbl.cat, tbl.height,\n        dodge = tbl.grp,\n        color = colors[tbl.grp],\n        bar_labels = :y\n        )\nylims!(ax, 0,70);\nlabels = [\"Muscade\", \"Longva (2015)\", \"Crisfield (1990)\"]\nelements = [PolyElement(polycolor = colors[i]) for i in 1:length(labels)]\ntitle = \"Method\"\nLegend(fig[1,2], elements, labels, title)\nif occursin(\"build\", currentDir)\n    save(normpath(joinpath(currentDir,\"..\",\"src\",\"assets\",\"StaticBeamAnalysis3.png\")),fig)\nelseif occursin(\"examples\", currentDir)\n    save(normpath(joinpath(currentDir,\"StaticBeamAnalysis3.png\")),fig)\nend\n#![Result](assets/StaticBeamAnalysis3.png)","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"","category":"page"},{"location":"StaticBeamAnalysis.html","page":"Static analysis of a beam","title":"Static analysis of a beam","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Theory.html#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"Theory.html#Introduction","page":"Theory","title":"Introduction","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"This section presents the theory of how FEM-optimization problems are defined or formulated.  This is of interest both for the user of a Muscade-based application, and for someone implementing new elements to create such an application.","category":"page"},{"location":"Theory.html#Classes-of-degrees-of-freedom","page":"Theory","title":"Classes of degrees of freedom","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Muscade introduces 3 classes of degrees of freedom (dofs). ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"X-dofs are the dofs normaly encountered in normal \"forward\" FEM analysis.  They provide a discrete representation of the response of the system. There is a one-to-one relation (a \"duality\") between the X-dofs and the residuals R, which are the discretized form of the differential equations we seek to solve. In forward FEM, we formulate a discreet problem of the form","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"forall t R(X(t)t)=0","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"U-dofs are additional dofs that can be used to represent additional unknown loads on the system. Like X-dofs, U-dofs are time-dependent. Unlike X-dofs, there is no residual (no new equations) corresponding to them.","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"A-dofs are additional dofs that can be used to represent unknown model parameters. X-dofs are not time-dependent, and there are no residuals corresponing to them.","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"We now formulate the discrete finite element model of the form","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"forall t R(X(t)U(t)At)=0","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"which is ill-posed (unknowns U and A have been added, but without adding any new equation).","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"To simplify the presentations in the following, we drop time t from the notations.  This can be interpreted in two ways:","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"We are solving a problem at a single instant (static). \nWe are solving an evolution problem (dynamic).  X, U and R are now vectors-valued functions of time, and R=0 denotes that the discretied differential equations must be verified at all times. ","category":"page"},{"location":"Theory.html#Target-function","page":"Theory","title":"Target function","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"To make the problem well-posed again, we introduce a target function Q(XUA).  We then seek to make Q stationary (finding a local minimum or maximum), under the constraint R(XUA)=0. Depending on the relevant application, the target function Q can represent different concepts.","category":"page"},{"location":"Theory.html#Target-function-as-financial-value","page":"Theory","title":"Target function as financial value","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In design optimisation, one can associate a monetary value to A (building stronger costs more money), and to X (some system responses, including failure, would cost money). The objective is to find the design with the lowest total cost,- under the constraint that load and response verify equilibrium.","category":"page"},{"location":"Theory.html#Target-function-as-surprisal","page":"Theory","title":"Target function as surprisal","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In a load estimation problem where part of the response is measured, we wish to find the most probable unknown load U (very large loads are not likely) and response (a computed response X that drasticaly disagrees with the actual measurements is not likely) - under the constraint that load and response verify equilibrium.  ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In Muscade, this must be handled by minimizing the surprisal Q = -log(P) instead of maximizing the probability density P. ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Q and P have the same extrema, so finding a minimum of Q does give a maximum of P.  \nThe joint probability density of independant random variables is equal to the product of each variable's probability density. Because log(ab)=log(a)+log(b), the joint surprisal of independant random variables is equal to the sum of each variable's surprisal. In forward finite element analysis, the load vectors and incremental matrices of elements are added into a system vector and system matrix.  Muscade extends this logic: contributions to the Lagrangian from various elements are added together.\nGeneraly speaking, surprisals are numericaly better behaved than probability densities.  ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"To illustrate the last point, consider a multinormal Gaussian probability density distribution and its surprisal:","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"beginaligned\nP(X) = (2pi)^-k2 det(Σ)^-12 exp left(-frac12 left( X-mu right)^T cdot Sigma^-1 cdot left( X-mu right) right) \nQ(X) = -log(P(X)) \n     = k + frac12 left( X-mu right)^T cdot Q_XX cdot left( X-mu right)\nendaligned","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"where k is a constant, whose value does not affect the extremal X, so k will be ignored in contributions to the target function. The constant matrix Q_XX is the inverse of the covariance matrix Sigma. In this example, s is a quadratic function of X: its Hessian is constant and has value Q_XX.  A Newton-Rapshon algorithm solves the minimization of a quadratic function exactly, in one iteration.  Further, a Newton-Raphson algorithm solves the minimization of a quadratic function, constrained by linear constraints, exaclty, in one iteration.  By contrast, a Newton-Raphson algorithm applied to finding the zero of the derivative of a Gaussian distribution, is prone to diverge.","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Hence, the code for an element defining a \"cost\" on a single dof X, measured to a value v(t) with a Gaussian measurement error of standard deviation sigma would implemented the function ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Q(Xt) = frac12 frac1sigma^2 left( X-v(t) right)^2","category":"page"},{"location":"Theory.html#Contributions-to-the-target-function","page":"Theory","title":"Contributions to the target function","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In Muscade, additive contributions to the target function are called \"costs\", although this is admitedly an inadequate name for an additive contribution to a surprisal. The costs are implemented as elements.  ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"One example of built-in element defining a cost is DofCost, an element to add a cost which is a function of the value of a dof. Examples would include:","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"A cost on a U-dof, a surprisal expressing prior knowledge of the magnitude of forces that may be explaining measured response.\nA cost on a X-dof, a financial cost incured if a point in the model has a too high value, causing a failure.","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Another built-in element is ElementCost, an element to add a cost which is a function of an element-result. For example, a bar element can have \"axial strain\" as an internal value, that is, a value it computes that is neither a dof nor a residual. ","category":"page"},{"location":"Theory.html#Constrained-optimization","page":"Theory","title":"Constrained optimization","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Making Q stationary under the equilibrium constraints R(XUA)=0 is equivalent to finding a stationary point (a saddle point) of the Lagrangian L","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"L(LambdaXUA) = Q(XUA) + R(XUA) cdot Lambda","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"where Λ are Lagrange multipliers (also known as adjoint state variables).  ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"There is a one-to-one correspondance between Lagrange multipliers Λdofs and residuals  R, and hence between Λ-dofs and X-dofs.  One result of this correspondance is that when implementing a new element, the method that must be provided doflist does not list the Λ-dofs (this would otherwise just have been a compulsory repetition of the list of X-dofs). ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"For evolution problems (involving a time-dependency), the dot product R(XUA) cdot Lambda includes an integral over time: the Lagrangian is a functional, and the gradients of L are ordinary differential equations in time, found using functional derivatives.  ","category":"page"},{"location":"Theory.html#Elements","page":"Theory","title":"Elements","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In the original finite element analysis, the elements in a model form a partition of a domain over which differential equations are to be solved. We will call these \"physical elements\".  These elements provide additive contributions to the system of equations R(XUA)=0. Further contributions can come from external loads.","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"When doing optimization-FEM in Muscade, the elements provide additive contributions to the Lagrangian scalar L, instead of to the residual vector R. Actually when creating a new element in Muscade to create an application, one can either implement a contribution to R by implementing a method Muscade.residual for the element, or a contribution to L by implementing Muscade.lagrangian.  For performance, whenever possible (for example when implementing a physical element), prefer Muscade.residual. ","category":"page"},{"location":"Theory.html#Physical-and-optimisation-constraints","page":"Theory","title":"Physical and optimisation constraints","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Physical constraints (including contact or Dirichlet/essential boundary conditions) are added to the model by using an element that adds adds a dof of class X to the model.  This new dof X_λ is a Lagrange multiplier for the constraint. If we note R, X and Λ the list of dofs before adding the constraint element and R^*, X^* and Λ^* after, then  ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"L^*(Lambda^*X^*UA) = Q(XUA)  + R^*(X^*UA) cdot Λ^* ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"with","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"beginaligned\nΛ^* = ΛΛ_λ\nX^* = XX_λ\nR^*(X^*UA) = leftR(XUA) - g_x(XUA) cdot X_λ    g_x(XUA)right\nendaligned","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Optimisation constraints allow to define that some situations are impossible, or inacceptable. For example, in a design optimisation analysis, excessive stresses would lead to failure, so would be constrained to remain under a given threshold. In a tracking or optimal control problem, an actuator force may not exceed some limit for the actuator's capacity.","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Optimisation constraints that have to be verified at every step (for example stresses that must remain below a critical level, at any time) require a Lagrange multiplier that changes over time, and that is thus of class U. Optimisation constraints that act only on A-dofs (for example, there is a limit to the strength of steel we can order)  require a Lagrange multiplier of class A.  With optimisation constraints, the Lagrangian is of the form","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"L^*(LambdaXU^*A^*) = Q^*(XU^*A^*)  + R(XUA) cdot Λ ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"with","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"beginaligned\nU^* = UU_λ\nA^* = AA_λ\nQ^*(XU^*A^*) = Q(XUA) +  g_u(XUA) cdot U_lambda + g_a(A) cdot A_λ \nendaligned","category":"page"},{"location":"Theory.html#Literature","page":"Theory","title":"Literature","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"For more details on the theory and examples of applications, see (Mainçon, 2004), (Mainçon, 2004), (Maree and Mainçon, 2004), (Barnardo and Mainçon, 2004), (Hauser et al., 2006), (Wu and Larsen, 2007), (Mainçon et al., 2008), (Hauser et al., 2008), (Wu et al., 2008), (Wu et al., 2009), (Mainçon and Barnardo, 2013). ","category":"page"},{"location":"DynamicBeamAnalysis.html#Modal-analysis-of-a-beam","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"","category":"section"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"Beam simply supported at both ends","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"using Muscade, StaticArrays, GLMakie\nusing Muscade.Toolbox\n\nL = 1;  # Beam length [m]\nq = 0.0;  # Uniform lateral load [N/m]\nEI₂ = 1;  # Bending stiffness [Nm²]\nEI₃ = 1;  # Bending stiffness [Nm²]\nEA = 1e6;  # Axial stiffness [N]\nGJ = 1e6;  # Torsional stiffness [Nm²]\nμ = 1;\nι₁= 1;\nnothing #hide","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"Create model","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"nel         = 50\nNnod        = nel+1\nnodeCoord   = hcat((0:L/nel:L),zeros(Float64,Nnod,2))\nmat         = BeamCrossSection(EA=EA,EI₂=EI₂,EI₃=EI₃,GJ=GJ,μ=μ,ι₁=ι₁)\nmodel       = Model(:TestModel)\nnodid       = addnode!(model,nodeCoord)\nmesh        = hcat(nodid[1:Nnod-1],nodid[2:Nnod])\neleid       = addelement!(model,EulerBeam3D,mesh;mat=mat,orient2=SVector(0.,1.,0.));\nnothing #hide","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"Set boundary conditions and constraints","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"[addelement!(model,Hold,[nodid[1]]  ;field) for field∈[:t1,:t2,:t3,:r1]]                                # Simply supported end 1\n[addelement!(model,Hold,[nodid[end]];field) for field∈[:t1,:t2,:t3,:r1]]                                # Simply supported end 2\n[addelement!(model,Hold,[nodid[nodeidx]];field=:t3) for nodeidx∈2:Nnod-1]                               # Enforce beam motions in one dimension to obtain planar modeshapes\n@functor with(q,L,Nnod) val(t) = sin(t)*q*L/Nnod\n[addelement!(model,DofLoad,[nodid[nodeidx]];field=:t2,value=val) for nodeidx=1:Nnod];    # Distributed vertical load q\nnothing #hide","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"Static analysis","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"initialstate    = initialize!(model);\nstate           = solve(SweepX{0};initialstate,time=[0.]);\nnothing #hide","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"Solve eigenvalue problem","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"nmod            = 15\nres             = solve(EigX{ℝ};state=state[1],nmod);\nnothing #hide","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"Analytical solutions for the natural frequency of a simply supported beam See e.g. https://roymech.org/UsefulTables/Vibrations/NaturalVibrations_derivation.html","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"fₙ(k) = √(EI₂/μ)*(k^2*π)/(2*L^2)\nΦₙ(k,x) = sin.(k*π/L.*x);\nnothing #hide","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"Display solution and comparison against analytical solution","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"fig      = Figure(size = (2000,1000))\naxes = [Axis(fig[idxLine,1], yminorgridvisible = false,xminorgridvisible = false ) for idxLine=1:3]\naxes[1].title = \"Modeshapes of a simply supported beam. Muscade (\" *string(nel)*\" elements): markers. Analytical solution: lines. \"\nfor idxMod=1:nmod\n    eigres  = increment(state[1],res,[idxMod],[1]);\n    t2_eig  = getdof(eigres;field=:t2,nodID=nodid[1:Nnod])\n    δ       = sign(Φₙ(idxMod,0:L/nel:L)'*t2_eig) * maximum(t2_eig)\n    selectAxis = axes[mod(idxMod-1,3)+1]\n    labelStr= \"Mode \"*string(idxMod)*\", Muscade: \"*string(round(res.ω[idxMod]/(2π),digits=3))*\" Hz, Analytical: \" *string(round(fₙ(idxMod),digits=3))* \" Hz\"\n    scatter!(selectAxis,(0:L/nel:L),  t2_eig[:]/δ,          label=labelStr  );\n    lines!(  selectAxis,(0:L/nel:L),  Φₙ(idxMod,0:L/nel:L)                  );\nend\nfor ax∈axes;\n    xlims!(ax,0,1); ylims!(ax, -2,2); axislegend(ax)\nend\n\ncurrentDir = @__DIR__\nif occursin(\"build\", currentDir)\n    save(normpath(joinpath(currentDir,\"..\",\"src\",\"assets\",\"beamModes.png\")),fig)\nelseif occursin(\"examples\", currentDir)\n    save(normpath(joinpath(currentDir,\"beamModes.png\")),fig)\nend","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"(Image: Result)","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"","category":"page"},{"location":"DynamicBeamAnalysis.html","page":"Modal analysis of a beam","title":"Modal analysis of a beam","text":"This page was generated using Literate.jl.","category":"page"},{"location":"litterature.html#Literature","page":"Literature","title":"Literature","text":"","category":"section"},{"location":"litterature.html","page":"Literature","title":"Literature","text":"Barnardo, C. and Mainçon, P. (2004). Inverse finite element methods  – Part IV: Sensitivity to modelling errors. In: Structural Engineering, Mechanics and Computation Conference, edited by Zingoni, A.\n\n\n\nHauser, C.; Maincon, P. and Walz, B. (2006). Ermittlung von Erdruckverteilungen aus Dehnungsmessungen mit der Inversen FE-Methode (iFEM). Bautechnik 83, 597–603.\n\n\n\nHauser, C.; Walz, B.; Mainçon, P. and Barnardo, C. (2008). Application of inverse FEM to earth pressure estimation. Finite elements in analysis and design 4, 705–714.\n\n\n\nMainçon, P. (2004). Inverse finite element methods  – Part II: Dynamic and non-linear problems. In: Structural Engineering, Mechanics and Computation Conference, edited by Zingoni, A.\n\n\n\nMainçon, P. (2004). Inverse finite element methods  – Part I: Estimating loads and structural response from measurements. In: Structural Engineering, Mechanics and Computation Conference, edited by Zingoni, A.\n\n\n\nMainçon, P.; Barnardo, C. and Larsen, C. M. (2008). VIV force estimation using inverse FEM. In: Proceedings of 27th International Conference on Offshore Mechanics and Arctic Engineering, Vol. 83, edited by Zingoni, A.; pp. 597–603.\n\n\n\nMainçon, P. and Barnardo, C. (2013). An inverse finite element method for the analysis of VIV data. Marine Structures 33, 143–159.\n\n\n\nMaree, J. and Mainçon, P. (2004). Inverse finite element methods  – Part III: Sensitivity to measurement set-up. In: Structural Engineering, Mechanics and Computation Conference, edited by Zingoni, A.\n\n\n\nWu, J. and Larsen, C. M. (2007). Hydrodynamic force identification from vortex induced vibration experiment with slender beam. In: OMAE 2007.\n\n\n\nWu, J.; Larsen, C. M. and Kaasen, K. E. (2008). A new approach for identification of forces on slender beams subjected to vortex induced vibrations. In: OMAE 2008.\n\n\n\nWu, J.; Mainçon, P.; Larsen, C. M. and Lie, H. (2009). VIV force identification using classical optimal control algorithm. In: OMAE; p. 79569.\n\n\n\n","category":"page"},{"location":"Memory.html#Memory-management","page":"Memory management","title":"Memory management","text":"","category":"section"},{"location":"Memory.html#Introduction","page":"Memory management","title":"Introduction","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Mutable structs, arguments passes by value to functions, garbage collection, variable names as tags. A variety of concept in Julia become easier to understand by considering how Julia manages memory, and how this affect performance.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"In line with programming languages of the past decades, Julia uses two approaches to store variables, namely the heap, and the stack. Julia's designer made a few important choices on how they use heap and stack, and these strongly shape how we use the language, in particular when writing high-performance code.","category":"page"},{"location":"Memory.html#The-heap","page":"Memory management","title":"The heap","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"The heap is a swath of memory made available to a program.  When a variable is allocated, a preferably contiguous amount of available memory of the right size is found on the heap, and its adress (a pointer) is returned.  Values within that segment of memory can be written to or read, and the variable is deallocated when it is no longer in use.  ","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"This is very flexible, but this flexibilty comes at a cost: To allocate a variable one must find available memory, thus there must be a heap-ledger describing what memory is available. Browsing the heap-ledger takes time.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Early in the execution of a program, the heap is unused, and finding space for new variables is easy.  But as variables are allocated and deallocated in arbitrary order, large contiguous area of free memory become rarer: the heap is fragmented, and there might be a need to swap things around (defragmentation).","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Further, language designers must make a choice.  Option one is to let the programmer explicitely deallocate a variable when it is no longer needed.  Unfortunately, bugs in which a variable is not deallocate easily occur. If this happens in some loop, memory is allocated but not deallocated (a memory leak) and these bugs are nasty to track down.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"The safer option 2, adopted by Julia, is to automaticaly deallocate memory on the heap when nothing anymore points to it.  That implies that there must be a pointer-ledger of all pointers into the heap, an the language must periodicaly go through the pointer-ledger to find orphaned heap-memory, update the heap-ledger, and possibly defragment the heap (move the variables in order to create large contiguous unallocated memory).  This process is called garbage collection.  While invisible to the programmer, the user sees it: it takes time.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"When a profiler reports the number of allocations, it actualy refers to allocation on the heap, not counting variables created on the stack.","category":"page"},{"location":"Memory.html#The-stack","page":"Memory management","title":"The stack","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"The stack is a limited amount of memory managed on a \"last in first out\" basis: as a picture, the stack is vertical and when the stack start empty, the stack pointer points tot he base of the stack. If a new variable needs to be stored, it is added to the top of the stack and the pointer is updated. When the variable no longer needs to be stored, the pointer is just updated back to its previous value (pop the stack).","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"The mechanism for creating or destroying a variable is simple, and thus extremely fast.  The drawback of course is that variables are destroyed in reverse order of their creation, which is not always convenient.  However this works perfectly for: ","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"input arguments to a function, in languages where these are passed by values, and\nlocal variables for the function.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"All these variables are created when entering the function, and destroyed when leaving it.  The (memory) stack thus fills as the code goes deeper into the call stack.  Recursions gone beserk typicaly result in a (memory) stack overflow.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"That, at least, is how things looked like in the late pre-internet age.  Since then, CPUs have been equipped with a nested system of fast access caches. An outer cache, smaller and fast than RAM, a inner cache, yet smaller and faster, and the CPU's registers are, in a sense, the innermost caches.  It makes sense to store the data currently being processed into one of these inner caches.  But this comes at the cost of complexity to the language and compiler designers: moving data to the cache means to free its original location (which is awkward in the context of a stack). Copying data introduces the classic problem of keeping all copies of the data up to date.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Thus the designers of the Julia language made one important choice: once a variable on the stack has been assigned a value, that value can never be changed.  The variable is said to be immutable. This allows Julia copy any part of the stack to the CPU caches to optimize performance, without worrying about out-of-date copies. \"Immutables are easier to reason about\" says the doc: this may not be true when learning Julia, but applies when writing the compiler. ","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Now we see why variable names in Julia are best viualised as tags on a value (you copy the tag if you copy the value, and there can be multiple tags for the same value) as opposed to the parable of a variable as a box in which you can store different value (valid in other languages).","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Julia's designers made another important choice: the size of all variables stored the stack must be known at compile time. This drasticaly simplifies the process of creating or destroying space on the stack when entering a function: just increment or decrement to stack pointer by a value determined for the function (actualy the method instance) at compile time.  Accessing a local variable from inside the function is likewise very fast: add a compile-time constant to the stack pointer, and that's were your data is.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"As we will see, the fact that variables must be ","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Immutable\nOf size known at compile time","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"significantly affects how one programs \"on the stack\" in Julia.","category":"page"},{"location":"Memory.html#An-Array","page":"Memory management","title":"An Array","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"In Julia, an Array{2,Float64} is \"copied\", for example by passing it as an argument to a function. What happens?","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"The array comes in several parts","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Heap-memory enough to store all the values in the array, in column major order. \nA smaller amount of heap-memory containing.  a.  the sizes of the first and second indices of the array.  b.  a pointer to the storage 1. of the values.\nOn the stack, a pointer to 2.\nMachine code that is written under the assumption that this array has two indices, that the size of an array element is 64 bits, that array elements can be copied directly to the CPU register for algebraic operations, etc.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"When the array is passed to a function, only 3., the pointer is actually passed to the function, as a copy placed at the right spot on the stack.  Being on the stack, the pointer is immutable: the function cannot reallocate 2. (as then the pointer to 2. would change value, pointing to a new spot on th heap). But one can change the content of the array, and its sizes (push!). Upon return from the function, the caller still has the pointer to a place on same spot on the heap: any change made by the function to values inside the array is visible by the caller.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"If function overwrites the array as a whole however, the interpretation is different","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"function foo(a)\n    a = [0,0]\nend\nA = [1,2]\nfoo(A)\n@show A\n\n2-element Vector{Int64}:\n 1\n 2","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Here foo was given a pointer to an array. By writing a =, foo discards its knowledge of the pointer, and uses the same tag-name to refer to a new spot of memory on the heap containing a pair of zeros.","category":"page"},{"location":"Memory.html#Strategies-for-performance","page":"Memory management","title":"Strategies for performance","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Allocating and deallocating memory on the heap takes time.  The amount of time for each allocation is tiny, but an ocean is just many drops. The time required is not proportional to the amount of memory allocated, but to the amount of individual allocations made.  So let us consider as an example a function inside of a hot loop, that needs internal memory for its local computations, and to return the results it produces.  For the function to be fast it must not allocate/deallocate memory on the heap. Two different strategies can be used to this effect, which we could call \"procedural\" and \"functional\".","category":"page"},{"location":"Memory.html#Procedural-strategy","page":"Memory management","title":"Procedural strategy","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"In the procedural strategy, memory (say Arrays) is preallocated \"once and for all\" on the heap, and passed to the function: arrays or slices of arrays are passed to the function.  The function uses this as work arrays and/or to return outputs: it is said to work \"in place\".  In that way there is one (or several) allocation[s] before the hot loop, and many calls to the function.  In Julia, the naming convention for functions that thus modify their input arguments is to end the function name with !.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"function double!(a)\n    for i∈eachindex(a)\n        a[i] *= 2\n    end\nend\n\na = randn(10)\nfor i = 1:10   # \"hot\" loop\n    double!(a)\nend","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"This strategy is sometimes difficult to implement:","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"If the function requires some working space, passing arrays to it is a breach of separation of concern (a new algorithm might require less, or more memory).\nThe return type of some functions might be hard to predict: even for type-stable functions, evaluating the types of an algorithm's output given the types of its inputs is sometimes best left to the compiler.\nAlgebraic operations, for example, are built into larger expression. In an implementation of *, to be used in a*b+c, operating in place is not an option (see however syntaxes like d .= a.*b.+c that are operating in place).","category":"page"},{"location":"Memory.html#Functional-strategy","page":"Memory management","title":"Functional strategy","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"In the functional strategy, the function creates new variables, both for intermediate results and for return value[s].  For performance, these variables are created on the stack, and must thus be immutable and of size known at compile time. ","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"function double(a)\n    b = 2 .*a\n    return b\nend\n\nusing StaticArrays\na = SVector{10}(randn() for i=1:10)\nfor i = 1:10   # \"hot\" loop\n    a = double(a)\nend","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Note that double is called with a SVector.  SVectors' size is a parameter to the type, and is thus known at compile time. SVectors' are immutable (a[2] = 0 will throw an error), and thus SVectors live on the stack. If double was called with a Vector (which size is part of the value, and which is mutable), the operation b = 2 .*a would result in an allocation.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"This strategy may also be difficult to implement:","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"If many array sizes may be used (leading to the compilation of many method instances).\nIf array sizes depend on input values, using types in which size is part of the type leads to type-unstable code.\nIf large arrays are used, compile times will become excessively high.","category":"page"},{"location":"Memory.html#Working-with-immutables","page":"Memory management","title":"Working with immutables","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"SArrays, ntuples and NamedTuples are useful immutable datastructures.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"If a for example an SArray can not be modified after it is created, how can we fill it with values?  Julia provides two syntaxs to do this, comprehensions and do-loops.  A comprehension looks like this:","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"using StaticArrays\n\nconst N=3 \nf(i) = i^2\n\na = SVector{N}(f(i) for i=1:N)","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Importantly, N must be a compile-time constant.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"A do-loop allows more complicated operations. We assume that the function material returns a StaticArray σ and a variable χgp of type difficult to predict. The do-loop creates the ntuple accum, which is then unpacked (using comprehensions) to sum the σ values into r and stack the χgp values into χ.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"function residual(x,y)\n    ngp   = 4\n    accum = ntuple(ngp) do igp\n        z = x[igp] + y[igp]\n        σ, χgp = material(z)\n        (σ=σ, χ=χgp) \n    end # do igp\n    r = sum(        accum[igp].σ for igp=1:ngp)\n    χ = NTuple{ngp}(accum[igp].χ for igp=1:ngp)\n    return r,χ\nend ","category":"page"},{"location":"Solvers.html#solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"Solvers.html#EigX:-standard-FEM-modal-analysis-solver","page":"Solvers","title":"EigX: standard FEM modal analysis solver","text":"","category":"section"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"The solver computes the eignmodes and oscillation frequencies of a model.","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"See the reference manual EigX. ","category":"page"},{"location":"Solvers.html#SweepX:-standard-FEM-solver","page":"Solvers","title":"SweepX: standard FEM solver","text":"","category":"section"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"SweepX{O} is a non-linear solver for differential equations of order O in time. This can be used for static and quasi static problems without hysterertic behaviour (plasticity, friction).","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"SweepX{1} is an implicit-Euler solver for differential equations of order 1 in time. This must be used for viscous problems, and for static and quasi static problem with hysteretic behaviour. The reason for this is that Muscade does not allow elements to have element-internal \"state\" variables (plastic strain, shear-free position for dry friction). Hence, where elements implement such physics, this is done by introducing the \"state\" as a degree of freedom of the element, and a corresponding equation.  This equation is the equation of evolution of the \"state\" variable, which involves the first order derivative of the variable in question even in a static problem.","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"SweepX{2} is a Newmark-β solver for differential equations of order 2 in time. A typical application is in structural dynamics. ","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"SweepX solves forward FEM problems (not optimisation-FEM) (see Theory).  However, SweepX can be applied to models that have U- and A-dofs. This is handled as follows: One input to SweepX is a State, which can come from initialize! or from the output of another solver. SweepX will keep the U- and A-dofs to the value in the input State. initialize! sets all dofs to zero, so when SweepX is given a State produced by initialize! the analysis starts with X-dofs equal to zero, and U- and A-dofs are kept zero throughout the analysis. ","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"SweepX handles inequality constraints (for example defined with the built-in DofConstraint element) using a simplified interior point method.","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"See the reference manual SweepX.   ","category":"page"},{"location":"Solvers.html#DirectXUA:-non-linear-inverse-solver","page":"Solvers","title":"DirectXUA: non-linear inverse solver","text":"","category":"section"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"DirectXUA is a solver for non-linear, static (OX=0), first order (OX=1) or dynamic (OX=2), optimisation-FEM problems. The same remarks on \"state\" variables and the choice of OX as for SweepX apply here. ","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"DirectXUA is designed for load and model parameter identification. Given a model with costs (and possibly constraints) on U- and A-dofs, the solver will determine response (X-dofs) and unknown loads for each step (U-dofs). If (IA=1), the algorithm will also estimate model parameters for the whole history (A-dofs).","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"OU specifies the order of the derivatives of U-dofs that appear in the target function.  For example, if OU=0, then costs should only be associated to the value of unknown external loads: the prior information on the unknown load process is that it is a white noise process. OU≥1 allows to provide prior information in the form of colored processes.  ","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"info: Info\nThe solver is \"direct\" in that it solves all the degrees of freedom at all the steps at the same time. This introduces a limitation on the number of degrees of freedom and time steps that can be handled.  Improving performance for large problems is on-going work.","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"info: Info\nCurrently, the solver does not handle inequality constraints.","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"See the reference manual DirectXUA.","category":"page"},{"location":"Solvers.html#FreqXU:-linear-inverse-solver","page":"Solvers","title":"FreqXU: linear inverse solver","text":"","category":"section"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"FreqXU is a solver for linear, static (OX=0), first order (OX=1) or dynamic (OX=2), optimisation-FEM problems. The same remarks on \"state\" variables and the choice of OX as for SweepX apply here. The same remark on the choice of OU as for DirectXUA applies here.","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"\"Linear\" is to be understood as follows: the solver computes the Hessian (second order derivative) of the Lagrangian at a reference time, and assumes that this Hessian does not vary over time.  This allows to use the Fourier transform to transform the set of differential equations into algegraic equations int he frequency domain: the amplitudes of the X- and U-dofs can be solved for each frequency separately, so that the algorithm is linear in the number of steps.","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"The Hessian of the Lagrangian include the tangential matrices of the finite element model.  Where costs are interpreted as suprisals, this amounts to approximating probability distributions by a Gauss distribution.","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"See the reference manual FreqXU.","category":"page"},{"location":"Elements.html#implementelement","page":"Implementing new elements","title":"Implementing new elements","text":"","category":"section"},{"location":"Elements.html#Introduction","page":"Implementing new elements","title":"Introduction","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"In Muscade, the broad view is taken that anything that contributes to the Lagrangian is an element.  This is a broader definition of \"elements\", compared to classical finite element formulations, in which an element is an element of a partition of a domain over which differential equations are to be solved.  This more general definition of \"elements\" includes a variety of types:","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Physical element (or finite element), discretizing differential equations over a part of the domain\nKnown external loads on the boundary (non-essential boundary conditions)\nKnown external loads in the domain\nConstrained dofs (essential boundary conditions)\nHolonomic equality and inequality constraints (contact)\nOptimisation constraints (e.g. stresses shal not exceed some limit at any point within part of the domain)\nResponse measurements (surprisal on X-dofs)\nUnknown external loads (surprisal on U-dofs)\nObserved damage (surprisal on A-dofs)\nCost of unfavorable response (cost on X-dofs)\nCost of actuators (cost on U-dofs)\nCost of building a system (cost on A-dofs)","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Because \"everything\" is an element in Muscade, app developers can express a wide range of ideas through Muscade's element API.","category":"page"},{"location":"Elements.html#No-internal-variables","page":"Implementing new elements","title":"No internal variables","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"In classical finite element formulations, plastic strain is implemented by letting an element have plastic strain and a hardening parameter as an internal variable at each quadrature point of the element.  Internal variables are not degrees of freedom.  Instead, they are a memory of the converged state of the element at the previous load or time step, used to affect the residual computed at the present time step.  Internal variables are also used when modeling friction and damage processes.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Muscade does not allow elements to have internal variables. The reason is that problem involing dofs of class U are not causal: our estimation of the state of a system a step i also depends on on measurements taken at steps j with j>i.  Hence \"sweep\" procedures, that is, procedures that solve a problem one load or time step at a time, are not applicable to such problems.  Solvers must hence solve for all dofs and steps at once.  When using Newton-Raphson iterations to solve problems of this class, internal variables make the Hessian matrix full: the value of a stress at a given stress depends (through the internal variable) on the strain at all preceeding steps. Or more formaly: Internal variables transforms the problem from differential to integral. A full matrix quickly leads to impossibly heavy computations.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"To model phenomena usualy treated using internal variable, it is necessary in Muscade to make the \"internal\" variable into a degree of freedom, and describe the equation of evolution of this degree of freedom. See examples/DecayAnalysis.jl for an example of implementation.  ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"warning: Warning\nBecause the equations of evolution involves first order time derivative, one can not use a static solver in combination with such elements.","category":"page"},{"location":"Elements.html#Sign-convention-in-elements","page":"Implementing new elements","title":"Sign convention in elements","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Starting with matrix methods in structural analysis, the traditional convention is that in an equation of the form","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"K cdot ΔX = R\nX leftarrow X + ΔX","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"K is (typicaly) symmetric positive definite, ΔX are incremental nodal displacements, and R are external loads applied to the structure (a positive load tends to induce a positive displacement).  As a consequence, when an element is implemented within this convention, the element must return its stiffness K and its \"internal reaction forces\" R_i: a bar that is elongated reacts by pulling its ends inwards. The forces are \"el-on-nod\" (element on node).  Muscade uses the same convention for the description of models.  ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"However, the implementation of elements in Muscade uses another convention.  This is because Muscade optimizes a Lagrangian, relative to a set of variables here collectively denoted as Z.  A Newton step for seeking to make L(Z) stationary is naturaly written as","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"G = fracpartial Lpartial Z\nH = fracpartial Gpartial Z\nH cdot ΔZ = G\nZ leftarrow Z - ΔX","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Note the minus sign on the last lign.  As a consequence of this minus sign, in Muscade, an element returns R_e=-R_i, and K is computed (by automatic differentiation, invisible to the element developer) as","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"K = fracpartial R_epartial X","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"This implies that R_e are the \"external forces\": to elongate a bar one must pull its ends outwards. The forces are \"nod-on-el\" (node on element).  This has one implication that may be surprising: an element that for example implements an (external) point load F must return R_e = -F, note the minus sign, so that the user of the element will interpret F as a classic external load.  The same applies to elements that connect unknown external loads U to the equilibrium equations.  Such an element must return R_e = -U.  Further, elements that return a Lagrangian (see below) must return L = Q + Lambda cdot R_e, note the plus sign.","category":"page"},{"location":"Elements.html#API","page":"Implementing new elements","title":"API","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The implementation of a element requires ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"A DataType defining the element. \nA constructor which is called when the user adds an element to the model, and constructs the above struct.\nMuscade.doflist specifies the degrees of freedom (dofs) of the element.\nMuscade.residual (either this of Muscade.lagrangian) takes element dofs as input and returns the element's additive contribution to the residual of a non-linear system of equations,\nMuscade.lagrangian (either this of Muscade.residual) takes element dofs as input and returns the element's additive contribution to a target function,\nMuscade.allocate_drawing, Muscade.update_drawing and Muscade.display_drawing! (optional) to draw all the elements of the same element type.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Each element must implement either Muscade.lagrangian or Muscade.residual, depending on what is more natural: a beam element will implement Muscade.residual (element reaction forces as a function of nodal displacements), while an element representing a strain sensor will implement Muscade.lagrangian (log-of the probability density of the strain, given an uncertain measurement).","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Here is a template of the code that may or must be supplied:","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"struct MyElement <: AbstractElement\n    ...\nend\nMuscade.doflist(     ::Type{MyElement})  = \n        (inod = (...), \n         class= (...), \n         field= (...) )\n\nfunction MyElement(nod::Vector{Node};...) \n    ...\n    return eleobj\nend\nMuscade.no_second_order(::Type{<:MyElement}) = Val(true)\n@espy function Muscade.residual(o::MyElement,   X,U,A,t,SP,dbg) \n    ...\n    return R,noFB  \nend\n@espy function Muscade.lagrangian(o::MyElement,  Λ,X,U,A,t,SP,dbg) \n    ...\n    return L,noFB\nend\nfunction Muscade.allocate_drawing(axis,o::AbstractVector{MyElement};kwargs...) \n    ...\n    return mut,opt\nend\nfunction Muscade.update_drawing(axis,o::AbstractVector{MyElement},mut,opt, Λ,X,U,A,t,SP,dbg) \n    ...\n    return mut\nend\nfunction Muscade.display_drawing!(axis,::Type{MyElement},obs,opt) \n    ...\nend","category":"page"},{"location":"Elements.html#struct","page":"Implementing new elements","title":"DataType","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"For a new element type MyELement, the datatype is defined as","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"struct MyElement <: AbstractElement\n    ...\nend","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"MyElement must be declared a subtype of AbstractElement.","category":"page"},{"location":"Elements.html#constructor","page":"Implementing new elements","title":"Constructor","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The element must provide a constructor of the form","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"function MyElement(nod::Vector{Node};kwargs...)\n    ...\n    return eleobj\nend","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"which will then call the default constructor provided by Julia.  ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"nod can be used to access the coordinates of the nodes directly:","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"x = nod[inod].coord[icoord]","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"where inod is the element-node number and icoord the index into a vector of coordinates. coord is  provided by the user when adding a Node to the Model. Muscade has no opinion about, and provides no check of, the length of coord provided by the user. In this way elements can define what coordinate system (how many coordinates, and their interpretation) is to be used.  Coordinate systems can even differ from one node to the next. See also the helper function coord to get all node coordinates.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"kwargs... is any number of named arguments, typicaly defining the material properties of the element.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The user does not call the above-defined constructor directly.  Instead, an element is added to the model by a call of the form","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"e1 = addelement!(model,MyElement,nodid,kwargs...)","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"See addelement!.","category":"page"},{"location":"Elements.html#Method-for-Muscade.doflist","page":"Implementing new elements","title":"Method for Muscade.doflist","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The element must provide a method of the form","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"function Muscade.doflist(::Type{MyElement})\n    return (inod =(...),\n            class=(...),\n            field=(...))\nend","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The syntax ::Type{MyElement} is because Muscade.doflist will be called by Muscade with a DataType  (the type MyElement), not with an object of type MyELement . The function name must begin with Muscade. to make it possible to overload a function defined in the module Muscade. ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The return value of the function is a NamedTuple with the fields inod, class and field. ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"inod  is a NTuple of Int64: for each dof, its element-node number. \nclass is a NTuple of Symbol: for each dof, its class (must be :X, :U or :A).\nfield is a NTuple of Symbol: for each dof, its field.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Importantly, Muscade.doflist does not mention dofs of class :Λ: if the element implements Muscade.lagrangian, there is automaticaly a one-to-one correspondance between Λ-dofs and X-dofs.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"For example (using Julia's syntax for one-liner functions):","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Muscade.doflist( ::Type{Turbine}) = (inod =(1   ,1   ,2        ,2        ),\n                                     class=(:X  ,:X  ,:A       ,:A       ),\n                                     field=(:tx1,:tx2,:Δseadrag,:Δskydrag))","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"See Muscade.doflist.","category":"page"},{"location":"Elements.html#Muscade.lagrangian-or-Muscade.residual","page":"Implementing new elements","title":"Muscade.lagrangian or Muscade.residual","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"An element must implement at least one of Muscade.lagrangian or Muscade.residual.","category":"page"},{"location":"Elements.html#Method-for-Muscade.lagrangian","page":"Implementing new elements","title":"Method for Muscade.lagrangian","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Elements that implement a contribution to a target function must implement Muscade.lagrangian.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"@espy function Muscade.lagrangian(o::MyElement,Λ,X,U,A,t,SP,dbg) \n    ...\n    return L,noFB\nend","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"See Muscade.lagrangian for the list of arguments and outputs.","category":"page"},{"location":"Elements.html#Method-for-Muscade.residual","page":"Implementing new elements","title":"Method for Muscade.residual","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Elements that implement \"physics\" will typicaly implement Muscade.residual (they could implement the same using lagrangian, but the resulting code would be less performant).","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The interface is mostly the same as for Muscade.lagrangian with the differences that","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Muscade.residual returns a vector R\nthere is no argument Λ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"@espy function Muscade.residual(o::MyElement,X,U,A,t,SP,dbg) \n    ...\n    return R,noFB\nend","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"See Muscade.residual for the list of arguments and outputs.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Some solvers may prefer to evaluate 2nd order derivatives of residual.  However, for elements with anything but a small number of degrees of freedom, this quickly leads to intractably high compilation and/or execution times.  If this is the case, then the element should implement Muscade.no_second_order to limit differentiation to the first order only. ","category":"page"},{"location":"Elements.html#Automatic-differentiation","page":"Implementing new elements","title":"Automatic differentiation","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The gradients and Hessians of R or L do not need to be implemented, because Muscade uses automatic differentiation. Because of this, it is important not to over-specify the inputs.  For example,  implementing a function header with","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"@espy function Muscade.lagrangian(o::MyElement,Λ::Vector{Float64},X,U,A,t,SP,dbg)\n#                                                |___bad_idea___|","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"would cause a MethodError, because Muscade will attempt to call with a SVector instead of Vector, and a special datatype supporting automatic differentiation instead of Float64.","category":"page"},{"location":"Elements.html#espy","page":"Implementing new elements","title":"Extraction of element-results","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The function definitions of Muscade.lagrangian and Muscade.residual must be anotated with the macro call @espy.   Variables within the body of Muscade.lagrangian and Muscade.residual, which the user may want to obtain must be anotated with ☼ (by typing \\sun they pressing TAB) at the place where they are calculated. An example would be ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"    ☼σ = E*ε","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The macro will generate two versions of Muscade.lagrangian and/or Muscade.residual.  One in which the anotations  ☼ are taken away, which is used to solve the numerical problem.  Another with additional input and output variables, and code inserted into the body of the function to extract results wanted by the user.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"See Muscade.@espy for a complete guide on code anotations. ","category":"page"},{"location":"Elements.html#Immutables-and-Gauss-quadrature","page":"Implementing new elements","title":"Immutables and Gauss quadrature","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Muscade.residual and Muscade.lagrangian must be written in a specific style in order maximize performance and to facilitate automatic differentiation. ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"For performance, no allocation on the heap must occur.  This implies in particular that no Arrays, and only  (stack allocated) StaticArrays must be used.  For example. the code a=zeros(n), creates an Array  (allocated on the heap), and should be replaced with a = SVector{N}(0. for i=1:N) where N must be known  at compile time to ensure type stability.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"To facilitate automatic differentiation, no mutation must occur. StaticArrays are anyway not mutable.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"One difficulty arises with Gauss quadrature.  Typical implementations would rely on setting R to zero, then adding the  contributions from quadrature points to R within a for loop over the Gauss points, which is a mutation.   The pseudo code:","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"R .= 0\nfor igp = 1:ngp\n    F  = ...\n    Σ  = ...\n    R += F ∘₁ Σ ∘₁ ∇N * dV\nend","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"shows that R is mutated. For the extraction of results from a loop, the following pattern must be used:","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"@espy function Muscade.residual(x,χ)\n    t = ntuple(ngp) do igp\n        ☼F = ...\n        ☼Σ = ...\n        r  = F ∘₁ Σ ∘₁ ∇N * dV\n        @named(r)\n    end\n    R = sum(   igp->t[igp].r,ngp)\n    return R,...\nend","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"r are the contributions to R at each quadrature point.  The operation t = ntuple ... returns a datastructure t such that  `t[igp].r are the contribution to the residual from the igp-th quadrature point. This is because","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"    t = ntuple(ngp) do igp\n        expr(igp)\n    end    ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"is equivalent to ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"    t = ntuple(expr for igp=1:ngp)","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"which returns","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"    t = (expr(1),expr(2),...,expr(ngp))","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"where the value of expr is that of its last line @named(r,a,b,c) which is a macro provided by Muscade that inserts the code (r=r,a=a,b=b,c=c).","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The code ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"    a = ntuple(igp->t[igp].a,ngp)\n    R = sum(   igp->t[igp].r,ngp)","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"gathers the hypothetic a of all quadrature points into a Tuple and adds together the contributions r into the residual R.  Variables behaving like a might come into play if solver feedback is provided from each Gauss point.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The macro @named is peculiar in that neither Julia nor Muscade defines a macro named.  Instead, it is a syntactic token identified and transformed by @espy.  This has one important implication: if the loop over the Gauss points only accumulates R (or L, in Muscade.lagrangian), it would be tempting to use a simpler pattern:","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"@espy function Muscade.residual(x,χ)\n    R = sum(1:ngp) do igp\n        ☼F = ...\n        ☼Σ = ...\n        F ∘₁ Σ ∘₁ ∇N * dV\n    end\n    return R,...\nend","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"However, result extraction from inside the loop will not work: @espy only supports \"ntuple...do...@named for the purpose.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"See Muscade.residual, Muscade.lagrangian.","category":"page"},{"location":"Elements.html#Performance","page":"Implementing new elements","title":"Performance","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"For a given element formulation, the performance of Muscade.residual and Muscade.lagrangian can vary with a factor up to 100 between a good and a bad implementation.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Type stable code allows the compiler to know the type of every variable in a function given the type of its parameters. Code that is type unstable is significantly slower. See the page on type stability.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Allocation, and the corresponding deallocation of memory on the heap takes time. By contrast, allocation and deallocation on the stack is fast.  In Julia, only immutable variables can be allocated on the stack. See the page on memory management","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Automatic differentiation generaly does not affect how Muscade.residual and Muscade.lagrangian are written.  There are two performance-related exceptions to this:","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"If a complicated sub-function in Muscade.residual and Muscade.lagrangian (typicaly a material model or other closure) operates on an array (for example, the strain) that is smaller than the number of degrees of freedom of the system, computing time can be saved by computing the derivative of the output (in the example, the stress) with respect to the input to the subfunction, and then compose the derivatives.\nIterative precedures are sometimes used within Muscade.residual and Muscade.lagrangian, a typical example being in plastic material formulations.  There is no need to propagate automatic differentiation through all the iterations - doing so with the result of the iteration provides the same result.\nElements with corotated reference system (e.g. beam elements) can use automatic differentiation to transform the residual back to the global reference system.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"See the page on automatic differentiation.","category":"page"},{"location":"Elements.html#Method-for-graphics:-Muscade.allocate_drawing,-Muscade.update_drawing-and-Muscade.display_drawing!","page":"Implementing new elements","title":"Method for graphics: Muscade.allocate_drawing, Muscade.update_drawing and Muscade.display_drawing!","text":"","category":"section"},{"location":"Elements.html#Template","page":"Implementing new elements","title":"Template","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The element can provide methods of the form","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"function Muscade.allocate_drawing(axis,o::AbstractVector{MyElement};kwargs...) \n    ...\n    return mut,opt\nend\nfunction Muscade.update_drawing(axis,o::AbstractVector{MyElement},mut,opt, Λ,X,U,A,t,SP,dbg) \n    ...\n    return mut\nend\nfunction Muscade.display_drawing!(axis,::Type{MyElement},obs,opt) \n    ...\nend","category":"page"},{"location":"Elements.html#Optional","page":"Implementing new elements","title":"Optional","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Methods for all of Muscade.allocate_drawing, Muscade.update_drawing and Muscade.display_drawing! method. Alternatively, they must implement neither of these three methods: in this case, the element will be invisible if the user requests a drawing of the element.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"None of Muscade's built-in elements implements methods for draw: because Muscade has no inherent interpretation of the various X dofs in these generic elements, there is no graphical representation associated to them.  ","category":"page"},{"location":"Elements.html#Graphic-engine","page":"Implementing new elements","title":"Graphic engine","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The element interface with Muscade.allocate_drawing, Muscade.update_drawing and Muscade.display_drawing! is taylored to GLMakie.jl, allowing to create and update graphical representation of the element. Muscade provides draw! to draw (or update a drawing of) the state of a model.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"It should be quite feasible to support the creation of files for, e.g., Paraview, or the use of other graphic engines. Element developers can implement methods of Muscade.allocate_drawing, Muscade.update_drawing and Muscade.display_drawing! for the graphic system of their choice, for example using WriteVTK.jl for Paraview.  It is hoped, but not tested, that draw! will be suitable for WriteVTK.jl without modification.","category":"page"},{"location":"Elements.html#Graphics-performance","page":"Implementing new elements","title":"Graphics performance","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Graphics packages typicaly create graphical objects (points, lines, patches etc.), and the construction of such objects is quite costly.  Muscade.jl limits the number of graphics objects using two techniques: update and vectorisation.","category":"page"},{"location":"Elements.html#Updating","page":"Implementing new elements","title":"Updating","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"GLMakie.jl, and other graphic systems allow to create a collection of graphic objects to represent a \"model\", and then to update the numerical values stored in the object.  For this reason, an element's graphics methods are divided in three phases:","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Muscade.allocate_drawing: The allocation of memory to be passed to the graphical object constructors.\nMuscade.update_drawing: The updating of the above memory with relevant values for a State of the Model.\nMuscade.display_drawing!: The creation of the graphics objects, by passing the above memory.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The initial call to draw! on a Model will call the above three methods in sequence for each element type.  In additional call (typicaly to create new frames of an animation), only the memory update is carried out.  When using GLMakie.jl, Muscade wraps the above memory in an Observable, and this way when the memory is updated, so is the figure. ","category":"page"},{"location":"Elements.html#Vectorization","page":"Implementing new elements","title":"Vectorization","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"The element's method for Muscade.allocate_drawing, Muscade.update_drawing and Muscade.display_drawing! act on all elements of the same type, in one call. This allows to exploit that e.g. in Makie.jl multiple lines can be drawn in one call to lines! by using NaNs to \"lift the pen\".","category":"page"},{"location":"Elements.html#Keyword-arguments","page":"Implementing new elements","title":"Keyword arguments","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"When requesting a drawing of all or part of the model, the user can provide specifications (line thickness, line colors, what quantity to visualise as colored patches and so forth).   The user can for example require","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"draw!(axis,state;linewidth=2)","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"draw! just passes all keyword argument to the Muscade.allocate_drawing methods of all element type. A pattern that application developers are encouraged to consider is:","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"All inputs are optional, all parameters have a default value.\nInstructions adressed to one element type are gathered by element type.  For example ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"draw!(axis,state;BeamElement  = (color=:red,linethickness=3),\n                 OtherElement = (;property=:value          ))","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"default provides support for the above pattern:","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"function Muscade.allocate_drawing(axis,o::AbstractVector{MyElement};kwargs...) \n    # Extract the NamedTuple of arguments adressed to MyElement.  \n    # Default to empty NamedTuple (;).\n    args = default{:MyElement}(kwargs,(;))\n    # Create opt, in which the default color=:blue is superseeded by \n    # input color=:red\n    opt  = default(args,(draw_marking=true,color=:blue,linethickness=2))\n    ...\nend","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Muscade provides facilities to draw only selected element types or selected elements, so the element's Muscade.allocate_drawing method does not need to implement a switch on whether to draw.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"See Muscade/test/SomeElements.jl for simple examples of implementation.  See also toolbox/BeamElement.jl for an advanced example of implementation where there are options to create completely different type of drawing for the same element type.  ","category":"page"},{"location":"Elements.html#Getting-element-results","page":"Implementing new elements","title":"Getting element results","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"In many cases, drawing provides a graphical representation of element-results (see Extracting results).  A pattern is that draw creates a request and calls residual or lagrangian (which ever the element implements), with an additional last input argument req (the request created using @request), and an additional last output argument out (containing the element-results).","category":"page"},{"location":"Elements.html#Help-functions","page":"Implementing new elements","title":"Help functions","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Muscade provides functions and constants to make it easier to comply with the API:","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Element constructors can use function coord to extract the coordinates fron the Vector{Node} they get as first argument.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Muscade.residual and Muscade.lagrangian must use ∂0, ∂1 and ∂2 when extracting the zeroth, first and second time derivatives from arguments X and U. These functions ensures that a SVector of zeros is returned if for example, an element that handles accelerations is called by a static solver.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Constant noFB (which have value nothing) can be used by elements that do not have feedback to the solving procedure.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"For those prefering to think in terms of Cartesian tensor algebra, rather than matrix algebra, operators ⊗, ∘₁ and ∘₂ provide the exterior product, the single dot product and the double dot product respectively.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Elements with a corotated reference system, can make use of toolbox/Rotations.jl that provides functionality to handle rotations in ℝ³.  See toolbox/BeamElement.jl for an example.","category":"page"},{"location":"Elements.html#Automatic-differentiation-within-element-code","page":"Implementing new elements","title":"Automatic differentiation within element code","text":"","category":"section"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Some advanced elements (in particular, elements with co-rotated element systems) can be implemented elegantly by using automatic differentiation within residual or lagrangian.  These are advanced techniques, requiring a good understanding of automatic differentiation.  Example of usage can be found in toolbox/BeamElement.jl.","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"Helper functions motion and motion⁻¹ allow to transform a tuple of SVectors, like the input X given to residual and lagrangian, into a an automatic differentiation structure, so that functions of ∂0(X) only can be differentiated with respect to time. ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"It is sometimes possible to improve performance by identifying a part of residual or lagrangian which takes a single, SVector as an input: A vector shorter than the list of dofs differentiated by the solver allow to accelerate computations, by using fast, or for more adbanced usage, revariate in combination with compose. ","category":"page"},{"location":"Elements.html","page":"Implementing new elements","title":"Implementing new elements","text":"In toolbox/BeamElement.jl, in function kinematics, fast is applied to accelerate a process of differentiation to the 2nd order.  In residual, revariate and compose in order to differentiate kinematics and accelerate computations by exploiting the fact that kinematic is a function of ∂0(X) only.","category":"page"},{"location":"Adiff.html#Automatic-differentiation","page":"Automatic differentiation","title":"Automatic differentiation","text":"","category":"section"},{"location":"Adiff.html#History","page":"Automatic differentiation","title":"History","text":"","category":"section"},{"location":"Adiff.html","page":"Automatic differentiation","title":"Automatic differentiation","text":"Muscade has its own implementation of forward automatic differentiation for historical reasons: Prototypes automatic differentiation of Muscade where developed in parallel with ForwardDiff.jl.  While the inner workings of ForwardDiff.jl and Muscade's version are similar ( with ForwardDiff.jl probably having better performance), the API are quite different.","category":"page"},{"location":"Adiff.html","page":"Automatic differentiation","title":"Automatic differentiation","text":"Muscade evaluates second derivative of the Lagrangian, using nested forward differentiation, which is far from optimal.  An ambition is to make use of reverse differentiation (using Zygote.jl, Enzyme.jl or similar).","category":"page"},{"location":"Adiff.html#Usage","page":"Automatic differentiation","title":"Usage","text":"","category":"section"},{"location":"Adiff.html","page":"Automatic differentiation","title":"Automatic differentiation","text":"Muscades automatic differentiation is used as follows:","category":"page"},{"location":"Adiff.html","page":"Automatic differentiation","title":"Automatic differentiation","text":"using SVector\nx   = SVector(1.,2.,3.)\nN   = length(x)\nx1  = variate{1,N}(x)\ny1  = f(x1)\ny   = value{1}(y1)\nyₓ  = ∂{1,N}(y2)    ","category":"page"},{"location":"Adiff.html","page":"Automatic differentiation","title":"Automatic differentiation","text":"x must be a SVector. In yₓ, the index over x is post-pended to the indices of y.","category":"page"},{"location":"Adiff.html","page":"Automatic differentiation","title":"Automatic differentiation","text":"Where automatic differentiation is nested, the extractions must be carried out in reverse order:","category":"page"},{"location":"Adiff.html","page":"Automatic differentiation","title":"Automatic differentiation","text":"x   = SVector(1.,2.,3.)\nN   = length(x)\nx1  = variate{1,N}(x)\nx2  = variate{2,N}(x1)\ny2  = f(x2)\ny   = value{1}(value{2}(y2))\nyₓ  = ∂{1,N}(value{2}(y2))  \nyₓ  = value{1}(∂{2,N}(y2))\nyₓₓ = ∂{1,N}(∂{2,N}(y2))","category":"page"},{"location":"Adiff.html","page":"Automatic differentiation","title":"Automatic differentiation","text":"The first type parameter given to variate, value and ∂ is the precedence P.  When automatic differentiation is nested, variate must be called with a value of P that is higher than the precedence of an variable that will influence the output. Inside a function, this precedence can vary depending on the type of arguments provided to the function. To this end, the function constants is provided:","category":"page"},{"location":"Adiff.html","page":"Automatic differentiation","title":"Automatic differentiation","text":"using SVector\n...\nN   = length(x)\nP   = constants(x,a,b,c)\nx1  = variate{P,N}(x)\ny1  = f(x1,a,b,c)\ny   = value{P}(y1)\nyₓ  = ∂{P,N}(y2)","category":"page"},{"location":"Adiff.html#Taylor-expansions","page":"Automatic differentiation","title":"Taylor expansions","text":"","category":"section"},{"location":"Adiff.html","page":"Automatic differentiation","title":"Automatic differentiation","text":"One way to accelerate automatic differentiation of complicated functions can be to compose the differentiation of simpler functions, in particular function with smaller inputs.  Use fast for basic applications, and revariate and compose for advanced usage. ","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"using Muscade,StaticArrays","category":"page"},{"location":"DryFriction.html#DryFriction","page":"DryFriction","title":"DryFriction","text":"","category":"section"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"Besides providing a general example of how to implement an element in Muscade, this element illustrates how to implement hysteretic behaviour (here: dry friction, but this would also apply to plasticity) without internal variables, since these make problems with Udofs intractable. This is handled by making what would otherwise have been an internal variable into an additional Xdof.  In this case, the element's second degree of freedom is the friction force.","category":"page"},{"location":"DryFriction.html#Type","page":"DryFriction","title":"Type","text":"","category":"section"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"The struct contains the values provided (indirectly) by the user. Note Fx and Ff which are type parameters: these will be Symbols that represent the field of the Xdof on which to apply the friction, and a Xdof to represent the friction force","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"struct DryFriction{Fx,Ff} <: AbstractElement\n    fric    :: 𝕣\n    x′scale :: 𝕣\n    k⁻¹     :: 𝕣   # ∈ [0,∞[, so k ∈ ]0,∞]\nend","category":"page"},{"location":"DryFriction.html#Constructor","page":"DryFriction","title":"Constructor","text":"","category":"section"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"We provide a constructor, which will be called by AddElement!. The keyword arguments can, or must be given by the user when calling  AddElement!, and are passed on to the constructor. Note that the constructor is type unstable: it gets fields and fieldf as values and uses them as type parameters. This is not deemed to be a problem for the constructor (type instability in residual would be another matter)","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"DryFriction(nod::Vector{Node};fieldx::Symbol,fieldf::Symbol=:f,\n           friction::𝕣,Δx::𝕣=0.,x′scale::𝕣=1.) =\n           DryFriction{fieldx,fieldf}(friction,x′scale,Δx/friction)","category":"page"},{"location":"DryFriction.html#residual","page":"DryFriction","title":"residual","text":"","category":"section"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"The residual function is prepended by @espy to facilitate the extraction of element-results . Variables old and new are prepended by ☼ (\\sun), to tell @espy the values of these variables can be requested using getresult.","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"The full name Muscade.residual must be used, because we are adding a method to a function defined in the module Muscade.","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"@espy function Muscade.residual(o::DryFriction, X,U,A, t,SP,dbg)\n    x,x′,f,f′ = ∂0(X)[1],∂1(X)[1], ∂0(X)[2], ∂1(X)[2]\n    stick = (x′-o.k⁻¹*f′)/o.x′scale\n    slip  = abs(f)/o.fric -1\n    ☼old  = abs(slip)<abs(stick) ? :slip : :stick\n    if        old==:stick && abs(f)>o.fric   ☼new = :slip\n    elseif    old==:slip  && f*x′<0          ☼new = :stick\n    else                                     ☼new = old\n    end\n    return (new==:slip ? SVector(f,slip) : SVector(f,stick)), noFB\nend;\nnothing #hide","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"In the above f (a force) uses the \"nod-on-el\" convention (force exterted by the element's node on the element), so the sign is unusual.","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"If the element was in stick the previous iteration, the variable stick = (x′-o.k⁻¹*f′)/o.x′scale will be very close to zero. Similarly, if the element was in slip the previous iteration, the variable slip  = abs(f)/o.fric -1 will be very close to zero. old is then either :stick or :slip depending on which of the two above is smallest.","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"The if construct can be read as follows:","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"If we were in stick at previous iteration but |f| from previous iteration exceeds o.fric, we slip in this iteration.\nIf we were in slip at previous iteration but force from previous iteration is in the wrong direction, we stick in this iteration.\nOtherwise, no change.","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"The function returns a 2-vector of residuals (corresponding to the two Xdofs).  The first residual f is the friction force applied to the dof fieldx.","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"The second residual corresponds to dof fieldf.  Importantly, this later dof must not be shared with any other element, so the that solver will set the second residual to zero in this iteration: depending on new, this will enforce slip==0 or stick==0. The relevant condition will be enforced exactly (to rounding errors) because both conditions are linear in X.","category":"page"},{"location":"DryFriction.html#doflist","page":"DryFriction","title":"doflist","text":"","category":"section"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"Another function that must be overloaded, in order to tell Muscade what dofs the element provides. Note that this is a function of the element type, not of the element variable: elements of the same concrete type must have the same dofs.","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"Muscade.doflist( ::Type{DryFriction{Fx,Ff}}) where{Fx,Ff} =\n    (inod =(1 ,1 ), class=(:X,:X), field=(Fx,Ff))","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"","category":"page"},{"location":"DryFriction.html","page":"DryFriction","title":"DryFriction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Modelling.html#Creating-a-model","page":"Creating a model","title":"Creating a model","text":"","category":"section"},{"location":"Modelling.html#Script-as-input","page":"Creating a model","title":"Script as input","text":"","category":"section"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Muscade being a framework for the development of optimization-FEM applications, it does not provide the elements needed to treat any specific application. It only provides a limited number of generic modeling capabilities, like fixing degrees of freedom (dofs) to describe boundary conditions, introducing holonomic constraints or costs on either dofs, or element-results (see Built-in elements).","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Hence to create a model, one will typicaly be using both Muscade and another package that provides a Muscade-based application (app).  The app provides specific elements for domains like continuum mechanics, marine structures, hydrogen diffusion etc.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Input to such an app is provided in the form of a Julia script containing instructions (calls to Muscade, using elements provided by the app) to define the model, execute analyses, and extract and process analysis results.  In other words, scripting a series of analyses, or some specific pre or postprocessing is simply done in the same script, and app developpers do not have to write code pertaining to a user interface. That being said, an app could introduce a GUI that would itself do the calls to Muscade.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Here is a simple example of analysis:","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"using Muscade\nusing StaticArrays\n\nmodel           = Model(:TestModel)\nn1              = addnode!(model,[0.]) \nn2              = addnode!(model,[1.])\ne1              = addelement!(model,Hold,[n1];field=:tx1)                       # Hold first node\n@functor with() load(t) = 3t\ne2              = addelement!(model,DofLoad,[n2];field=:tx1,value=load)        # Increase load on second node\n@functor with() res(X,X′,X″,t)  = 12SVector(X[1]-X[2],X[2]-X[1])\ne3              = addelement!(model,QuickFix,[n1,n2];inod=(1,2),field=(:tx1,:tx1),\n                              res=res)  # Linear elastic spring with stiffness 12\ninitialstate    = initialize!(model)\nstate           = solve(SweepX{0};initialstate,time=[0.,1.],verbose=false)      # Solve the problem\ntx1             = getdof(state[2],field=:tx1,nodID=[n2])                        # Extract the displacement of the free node\nreq             = @request F                                                    # Extract internal results from the spring element\neleres          = getresult(state,req,[e2]) \niele,istep      = 1,2\nforce           = eleres[iele,istep].F\n@show tx1\n@show force","category":"page"},{"location":"Modelling.html#Model-definition","page":"Creating a model","title":"Model definition","text":"","category":"section"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"The definition of a model is done in three phases:","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Creating a blank model, with Model.\nAdding nodes and elements, with addnode! and addelement!. One can however add an element to the model after all the nodes of the element have been added to the model.\nInitialising the model with initialize!.  Once this is done, one can no longer add nodes or elements to the model. initialize! hashes some tables and generates an initial \"as meshed\" state of the system. Typicaly (but this depends on the app), all dofs are set to zero. The resulting variable, here called initialstate contains a pointer to the model: passing a state to a solver makes the model available to the solver. ","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"setdof! can be used to set the value of specific dofs for more specific initial conditions.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Muscade does not provide a mesher. There are some general purposes meshers with Julia API, which outputs could be used to generate calls to addnode! and addelement!.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Note that two Functions, load and res are defined in the script, and then passed as argument to element constructors. Elements require that the function has been defined by using the macro @functor.  The first argument is a list of parameters captured by the function. The macro ensures that the values of the parameters are captured. The second argument is the function definition.  The macro prevents the function to be re-parsed if unchanged, which in turn prevents unnecessary recompilations of Muscade when the script is runned multiple times in a session. ","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"The model - either finitialized or under construction, can be examined using describe and getndof.  ","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Optionaly, one can also use setscale! (with the help of Muscade.study_scale) to scale the variables and thus improve the conditioning of the problem. ","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Information on commands provided by Julia and packages (including Muscade) can be obtained from the help mode in the REPL.  Make sure the command is available by using Muscade, then activate the help mode by pressing ?. ","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"help?> Hold\n\n  Hold <: AbstractElement\n\n\n  An element to set a single X-dof to zero.\n\n  Named arguments to the constructor\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\n    •  field::Symbol. The field of the X-dof to constraint.\n\n    •  λfield::Symbol=Symbol(:λ,field). The field of the Lagrange multiplier.  \n(...)","category":"page"},{"location":"Modelling.html#Built-in-elements","page":"Creating a model","title":"Built-in elements","text":"","category":"section"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"With a few exceptions for testing and demonstration, Muscade does not provide physical elements.  However, it provides several general purpose elements  to introduce loads, costs or  constraints.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"DofLoad adds a time-varying load on a single X-dof.  Elements for more general loads, in particular, consistent loads on element boundaries or domain, or follower loads, need to be implemented if required.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"DofCost adds a cost per unit of time, as a function of either X-dofs ,U-dofs (and/or their derivatives), A-dofs and time. Elements for costs on unknown distributed load fields (over boundary or domain) must be provided by apps if required.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"SingleDofCost provides a simplified syntax for costs on a single dof.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Acost adds a once-off cost, as a function of A-dofs. ","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"SingleAcost provides a simplified syntax for A once-off cost on a single A-dof.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"SingleUdof allows to define an unknown external nodal load and apply a cost to it.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"ElementCost adds a cost per unti of time on a combination of one element's dofs and element-results.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"DofConstraint adds a constraint to a combination of values (no time derivatives) of dofs. The constraints can switch over time between equality, inequality and \"off\". Inequality constraints are handled using a modified interior point method.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"ElementConstraint adds a constraint to a function of internal results from one element. The constraints can switch over time between equality, inequality and \"off\". Inequality constraints are handled using a modified interior point method.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Hold provides a simplified syntax to set a single X-dof to zero.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"QuickFix allows to rapidly create a simple element, with limitations in functionality. ","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"When using xxxCost elements to introduce measured time series, consider using DataInterpolations.jl.","category":"page"},{"location":"Modelling.html#Running-the-analysis","page":"Creating a model","title":"Running the analysis","text":"","category":"section"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"solve is then called with the name of the solver to be used (here SweepX{0}), and any named parameters required by the solver. The return value state can have different structures, depending on the solver.  For SweepX{0}, state is a vector (over the time steps) of States.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"describe can also be used to inspect States.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Analyses may fail due to singular matrix.  The source of the singularity can be challenging to diagnose. Muscade.study_singular can help determine the null-space of an incremental matrix, for small problems.","category":"page"},{"location":"Modelling.html#Extracting-results","page":"Creating a model","title":"Extracting results","text":"","category":"section"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"States (returned by initialize! and solve). are variables which contents are private (not part of the API, and subject to change), but can be accessed using getdof and getresult.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"getdof allows to obtain dofs which are directly stored in state, by specifying class, field and node.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"getresult (used in combination with Muscade.@request) allows to obtain \"element-results\".  Element-results are intermediate values that are computed within Muscade.lagrangian or Muscade.residual, but are (generaly) not returned, because the API for these functions does not open for this.  In mechanics,  Muscade.residual would take displacements as inputs (X-dofs) and from them compute the forces that must act on the element to cause these displacements. Element-results woudl then include quantities such as stresses and strains.  To be requestable, a variable must be tagged in Muscade.lagrangian or Muscade.residual, prefixing its name with ☼ (\\sun) at the right hand of an assigment.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"These element-results are not stored in the State, and tagging variables does not result in either increase storage or computing time: getresult will compute requested values on the fly by calling a modified version of Muscade.lagrangian or Muscade.residual generated by @espy.  This also implies that one does not need to decide on what variables to store before an anlysis, a great advantage for heavy analyses.","category":"page"},{"location":"Modelling.html#Units","page":"Creating a model","title":"Units","text":"","category":"section"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Muscade provides functionality to transform quantities to and from basic SI units.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"using Muscade, Printf\nusing Muscade: m, kg, pound, foot\nrho          = 3←(pound/foot^3)                      # convert to SI\nvieuxquintal = 1000*pound                            # define new unit\n@printf(\"Density [pound/foot^3] %f\",rho→pound/foot^3) # convert from SI","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Arrays can be converted in the same way: [200,300,24]←mm.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"A guideline for handling units without problems is:","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Element developers assume inputs with consistent units, and thus never make unit conversions.\nElement developers do not assume that the input are expressed in base SI units, and thus require all necessary dimensional constants (acceleration of gravity, gas constant...) as user input.\nUsers convert all their input values as they define them in the input rho = 3 ← pound/foot^3.\nUsers convert Muscade outputs just before printing them out printf(\"stress [MPa] %f\",stress → MPa).","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Excellent packages exist for the handling of units (Unitful.jl ).  These packages have zero runtime overhead, and allow to verify code for unit consistency (Muscade does not provide this). However, it is arguably not possible to make these packages work with Muscade: In Muscade, 3←(pound/foot^3) is of type Float64.  A comparable operation in Unitful.jl would output a variable with a type containing data about dimensionality. Muscade handles various arrays of quantities with different dimensionality: such a solution would result in arrays of heterogeneous types. Muscade does not allow this, as this would result in catastrophic loss of performance due to type instability.","category":"page"},{"location":"Modelling.html#Drawing","page":"Creating a model","title":"Drawing","text":"","category":"section"},{"location":"Modelling.html#Generating-figures-with-Draw!","page":"Creating a model","title":"Generating figures with Draw!","text":"","category":"section"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"To create a snapshot of a State, either the initialised model, or a step from an analysis, one can use draw!:","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"using GLMakie\nfig     = Figure(size = (500,500))\naxis    = Axis3(fig[1,1])\ndraw!(axis,state;kwargs...)","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"draw! calls methods Muscade.allocate_drawing, Muscade.update_drawing and Muscade.display_drawing! for all (or specific) elements of the model.  ","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Elements that do not implement the above three methods simply have no graphic representation. Muscade's built-in elements, for example, do not implement such methods.  This is for two reasons.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"First, Muscade is not written to serve a specific domain of physics.  How a DofConstraint should be represented would be different in mechanics and chemical species diffusion.  Developers of Muscade-based application can create domain-specific drawing methods for specific elements.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Second, while Muscade is tested with GLMakie.jl, it is intended to support other graphic engines.  For example, fig in the above example could be an opened Paraview file (VTK file), and the drawing methods could be made to write to this file. Muscade itself only passes fig on to the drawing methods, with no form of type checking.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"draw! accepts a list of keywords argument (kwargs...) in the above example, which Muscade just passes on to the drawing methods of all elements. This is intended to provide the user control over what is drawn and how (choose which field to display, line thickness, surface color etc.).","category":"page"},{"location":"Modelling.html#Interactive-exploration-with-GUI","page":"Creating a model","title":"Interactive exploration with GUI","text":"","category":"section"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"The function GUI can be called with a Vector of States.  This allows to explore a sequence of steps interactively, and allows to scale results for visualisation, ","category":"page"},{"location":"reference.html#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference.html#Constants","page":"Reference","title":"Constants","text":"","category":"section"},{"location":"reference.html#Muscade.noFB","page":"Reference","title":"Muscade.noFB","text":"noFB\n\nA constant, used by elements' residual or lagrangian as their 3rd output if they do provide  any feedback to the solver (for example, on the reduction of the barrier parameter in interior point method).\n\nExample: return L,noFB\n\nSee also: noFB\n\n\n\n\n\n","category":"constant"},{"location":"reference.html#Muscade.ϵ","page":"Reference","title":"Muscade.ϵ","text":"ϵ (\\epsilon)\n\nan alias for Base.eps(𝕣). \n\n\n\n\n\n","category":"constant"},{"location":"reference.html#Muscade.∞","page":"Reference","title":"Muscade.∞","text":"∞ (\\infty)\n\nan alias for Base.inf. \n\n\n\n\n\n","category":"constant"},{"location":"reference.html#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"reference.html#Muscade.AbstractElement","page":"Reference","title":"Muscade.AbstractElement","text":"AbstractElement\n\nAn abstract data type.  An element type MyElement must be declared as a subtype of AbstractElement.\n\nMyELementmust provide a constructor with interface\n\n`eleobj = MyElement(nod::Vector{Node}; kwargs...)`\n\nSee also: coord, Node, lagrangian    \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.Acost","page":"Reference","title":"Muscade.Acost","text":"Acost{Na,ainod,afield,Tcost,Tcostargs} <: AbstractElement\n\nAn element to apply a once-off cost on a combination of A-dofs.  For costs per unit of time on A-dofs (not recommended), see DofCost.\n\nNamed arguments to the constructor\n\ninod::NTuple{Na,𝕫}=()       For each A-dof to enter cost, its element-node number.\nfield::NTuple{Na,Symbol}=() For each A-dof to enter cost, its field.\ncost::Functor              cost(A,costargs...)→ℝ\ncostargs::NTuple=() or NamedTuple of additional arguments passed to cost`\n\nRequestable internal variables\n\ncost, the value of the cost.\n\nExample\n\n@functor with() acost(A;A0)=(A[1]-A0)^2\nele1 = addelement!(model,Acost,[nod1],inod=(1,),field=(:EI,),\n       cost=acost,costargs=(;A0=0.27)\n\nSee also:  SingleAcost, DofCost, SingleDofCost, ElementCost, addelement!  \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.DirectXUA","page":"Reference","title":"Muscade.DirectXUA","text":"DirectXUA{OX,OU,IA}\n\nA non-linear direct solver for optimisation FEM.\n\nAn analysis is carried out by a call with the following syntax:\n\ninitialstate    = initialize!(model)\n\nThe solver does not yet support interior point methods. \n\nParameters\n\nOX                0 for static analysis                     1 for first order problems in time (viscosity, friction, measurement of velocity)                     2 for second order problems in time (inertia, measurement of acceleration) \nOU                0 for white noise prior to the unknown load process                     2 otherwise\nIA                0 for XU problems (variables of class A will be unchanged)                     1 for XUA problems                                                  \n\nNamed arguments\n\ndbg=(;)           a named tuple to trace the call tree (for debugging).\nverbose=true      set to false to suppress printed output (for testing).\nsilenterror=false set to true to suppress print out of error (for testing) .\ninitialstate      an AbstractVector of State: one initial state for each experiment\ntime              an AbstractVector (of same length as initialstate) of AbstractRange                      of times at which to compute the steps.  Example: 0:0.1:5.                       \nmaxiter=50        maximum number of Newton-Raphson iterations. \nmaxΔλ=1e-5        convergence criteria: a norm of the scaled Λ increment.\nmaxΔx=1e-5        convergence criteria: a norm of the scaled X increment. \nmaxΔu=1e-5        convergence criteria: a norm of the scaled U increment. \nmaxΔa=1e-5        convergence criteria: a norm of the scaled A increment.\nsaveiter=false    set to true so that the output state contains the states                      at each Newton-Raphson iteration (for debugging                      non-convergence). \n\nSetting the following flags to true will improve the sparsity of the system. But setting a flag to true when the condition isn't met causes the Hessian to be wrong, which is detrimental for convergence.                      \n\nXwhite=false      true if response measurement error is a white noise process.\nXUindep=false     true if response measurement error is independant of U\nUAindep=false     true if U is independant of A\nXAindep=false     true if response measurement error is independant of A\n\nOutput\n\nstate, where state[iexp][itime] contains the state of the optimized model at each of these steps, or if saveiter=true then state[iiter][iexp][itime] is a state.\n\nSee also: solve, initialize!, SweepX, FreqXU\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.DofConstraint","page":"Reference","title":"Muscade.DofConstraint","text":"DofConstraint{λclass,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,\n    afield,λinod,λfield,Tg,Tmode} <: AbstractElement\n\nAn element to apply physical/optimisation equality/inequality constraints on dofs. \n\nThe constraints are holonomic, i.e. they apply to the values, not the time derivatives, of the involved dofs.  This element is very general but not very user-friendly to construct, factory functions are provided for better useability.  The sign convention is that the gap g≥0 and the Lagrange multiplier λ≥0.\n\nThis element can generate three classes of constraints, depending on the input argument λclass.\n\nλclass=:X Physical constraint.  In mechanics, the Lagrange multiplier dof is a   generalized force, dual of the gap. The gap Functor must be of the form gap(x,t,gargs...).\nλclass=:U Time varying optimisation constraint. For example: find A-parameters so that  at all times, the response does not exceed a given criteria. The gap Functor must be of the form     gap(x,u,a,t,gargs...).\nλclass=:A Time invariant optimisation constraint. For example: find A-parameters such that  A[1]+A[2]=gargs.somevalue. The gap Functor must be of the form gap(a,gargs...).\n\nNamed arguments to the constructor\n\nxinod::NTuple{Nx,𝕫}=()       For each X-dof to be constrained, its element-node number.\nxfield::NTuple{Nx,Symbol}=() For each X-dof to be constrained, its field.\nuinod::NTuple{Nu,𝕫}=()       For each U-dof to be constrained, its element-node number.\nufield::NTuple{Nu,Symbol}=() For each U-dof to be constrained, its field.\nainod::NTuple{Na,𝕫}=()       For each A-dof to be constrained, its element-node number.\nafield::NTuple{Na,Symbol}=() For each A-dof to be constrained, its field.\nλinod::𝕫                     The element-node number of the Lagrange multiplier.\nλclass::Symbol               The class (:X,:U or :A) of the Lagrange multiplier.                                 See the explanation above for classes of constraints\nλfield::Symbol               The field of the Lagrange multiplier.\ngap::Functor                 The gap function.\ngargs::NTuple                Additional inputs to the gap function.\nmode::Functor                where mode(t::ℝ) -> Symbol, with value :equal,                                 :positive or :off at any time. An :off constraint                                 will set the Lagrange multiplier to zero.\n\nExample\n\nusing Muscade\nmodel           = Model(:TestModel)\nn1              = addnode!(model,𝕣[0]) \n@functor with() gap(x,t)=x[1]+.1\n@functor with() res(x,u,a,t)=0.4x.+.08+.5x.^2)\ne1              = addelement!(model,DofConstraint,[n1],xinod=(1,),xfield=(:t1,),\n                              λinod=1, λclass=:X, λfield=:λ1,gap=gap,\n                              mode=positive)\ne2              = addelement!(model,QuickFix  ,[n1],inod=(1,),field=(:t1,),\n                              res=res\ninitialstate    = initialize!(model)\nsetdof!(initialstate,1.;field=:λ1)\nstate           = solve(SweepX{0};initialstate,time=[0.],verbose=false) \nX               = state[1].X[1]\n\nSee also: Hold, ElementConstraint, off, equal, positive\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.DofCost","page":"Reference","title":"Muscade.DofCost","text":"DofCost{Class,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,\n    afield,Tcost,Tcostargs} <: AbstractElement\n\nAn element to apply costs on combinations of dofs. The cost is \"per unit of time\". For once-off costs on A-dofs, see Acost.\n\nNamed arguments to the constructor\n\nxinod::NTuple{Nx,𝕫}=()       For each X-dof to enter cost, its element-node number.\nxfield::NTuple{Nx,Symbol}=() For each X-dof to enter cost, its field.\nuinod::NTuple{Nu,𝕫}=()       For each U-dof to enter cost, its element-node number.\nufield::NTuple{Nu,Symbol}=() For each U-dof to enter cost, its field.\nainod::NTuple{Na,𝕫}=()       For each A-dof to enter cost, its element-node number.\nafield::NTuple{Na,Symbol}=() For each A-dof to enter cost, its field.\ncost::Functor               cost(X,U,A,t,costargs...)→ℝ                                X and U are tuples (derivates of dofs...), and ∂0(X),∂1(X),∂2(X)                                 must be used by cost to access the value and derivatives of X (resp. U) \ncostargs::NTuple=() or NamedTuple of additional arguments passed to cost`\n\nRequestable internal variables\n\ncost, the value of the cost.\n\nExample\n\n@functor with() xcost(X,U,A,t;X0) = (X[1]-X0)^2\nele1 = addelement!(model,DofCost,[nod1],xinod=(1,),xfield=(:tx1,),\n       cost=xcost,costargs=(;X0=0.27)\n\nSee also: Acost, SingleDofCost, ElementCost, addelement!  \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.DofLoad","page":"Reference","title":"Muscade.DofLoad","text":"DofLoad{Tvalue,Field} <: AbstractElement\n\nAn element to apply a loading term to a single X-dof.  \n\nNamed arguments to the constructor\n\nfield::Symbol.\nvalue::Functor, where value(t::ℝ) → ℝ.\n\nRequestable internal variables\n\nF, the value of the load.\n\nExamples\n\nusing Muscade\nmodel = Model(:TestModel)\nnode  = addnode!(model,𝕣[0,0])\ne     = addelement!(model,DofLoad,[node];field=:tx,value=t->3t-1)\n\nSee also: Hold, DofCost  \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.EigX","page":"Reference","title":"Muscade.EigX","text":"eiginc = solve(EigX{ℝ};state=initialstate,nmod)\neiginc = solve(EigX{ℂ};state=initialstate,nmod)\n\nGiven an initial (typicaly static) state initialstate, computes the lowest nmod eigenmodes of a system.  EigX{ℝ} computes real eigenmodes not accounting for damping. EigX{ℝ} computes complex eigenmodes accounting for damping. The data structure eiginc can be passed to increment to obtain dynamic states superimposing mode shapes.\n\nInput\n\ninitialstate - a State\nnmod=5 - the number of eigenmodes to identify\ndroptol=1e-9 - in the stiffness and mass matrix, the magnitude of a term relative to the largest term in the matrix       under which the term is set to zero.\nFurther named arguments: see the optional keyword arguments to geneig.         \n\nOutput\n\nan object of type EigXℝincrement or EigXℂincrement, for use with increment to create a snapshot of the oscillating system.\n\nSee also: solve, initialize!, increment, geneig\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.EigXU","page":"Reference","title":"Muscade.EigXU","text":"EigXU{OX,OU}\n\nStudy the combinations of load and response that are least detected by sensor systems.\n\nAn analysis is carried out by a call with the following syntax:\n\ninitialstate    = initialize!(model)\neiginc          = solve(EigXU{OX,OU};Δω, p, nmod,initialstate)\n\nThe solver linearises the problem (computes the Hessian of the Lagrangian) at initialstate and solves  the ΛXU-eigenvalue problem at frequencies ωᵢ = Δω*i with i∈{0,...,2ᵖ-1}.\n\nParameters\n\nOX                0 for static analysis                     1 for first OX problems in time (viscosity, friction, measurement of velocity)                     2 for second OX problems in time (inertia, measurement of acceleration) \nOU                0 for white noise prior to the unknown load process                     2 otherwise\n\nNamed arguments\n\ndbg=(;)           a named tuple to trace the call tree (for debugging).\nverbose=true      set to false to suppress printed output (for testing).\ninitialstate      a State.\nnmod              the number of eigen-modes to identusy\nΔω                frequency step\np                 2^p steps will be analysed.      \ndroptol=1e-10     set to zero terms in the incremental matrices that are smaller than droptol in absolute value.                      \n\nOutput\n\nan object of type EigXUincrement for use with increment to create a snapshot of the oscillating system.\n\nSee also: increment,EigXU, solve, initialize!, study_singular, SweepX, DirectXUA\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.ElementConstraint","page":"Reference","title":"Muscade.ElementConstraint","text":"ElementConstraint{Teleobj,λinod,λfield,Nu,Treq,Tg,Tgargs,Tmode} <: AbstractElement\n\nAn element to apply optimisation equality/inequality constraints on the element-results of  another \"target\" element. The target element must not be added separately to the model.  Instead, the  ElementType, and the named arguments to the target element are provided as input to the  ElementConstraint constructor.\n\nThis element generates a time varying optimisation constraint. For example: find A-parameters so that    at all times, the element-result von-Mises stress does not exceed a given value. \n\nThe Lagrangian multiplier introduced by this optimisation constraint is of class :U.   \n\nNamed arguments to the constructor\n\nλinod::𝕫            The element-node number of the Lagrange multiplier.\nλfield::Symbol      The field of the Lagrange multiplier.\nreq                 A request for element-results to be extracted from the target element, see @request.                       The request is formulated as if adressed directly to the target element.\ngₛ::𝕣=1.             A scale for the gap.\nλₛ::𝕣=1.             A scale for the Lagrange multiplier.\ngap                 A gap function gap(eleres,t,gargs...)→ℝ.                       eleres is the output of the above-mentionned request to the target element. \ngargs::NTuple       Additional inputs to the gap function. \nmode::Functor      where mode(t::ℝ) -> Symbol, with value :equal,                        :positive or :off at any time. An :off constraint                        will set the Lagrange multiplier to zero.\nElementType         The named of the constructor for the relevant element \nelementkwargs       A named tuple containing the named arguments of the ElementType constructor.     \n\nRequestable internal variables\n\nNot to be confused with the req provided as input to addelement! when adding an ElementConstraint, one can, after  the analysis, request results from ElementConstraint \n\nλ                   The constraints Lagrange multiplier\ngap                 The constraints gap Functor\neleres(...)         where ... is the list of requestables wanted from the target element.  The \"prefix\"                         eleres is there to prevent possible confusion with variables requestable from ElementConstraint.                         For example @request gap would extract the value of the ElementConstraint's function gap, while                       @request eleres(gap) refers to the value of a variable called gap in the target element. \n\nExample\n\n@functor with() gap(eleres,t) = eleres.Fh^2\nele1 = addelement!(model,ElementCoonstraint,[nod1];req=@request(Fh),\n                   gap,λinod=1,λfield=:λ,mode=equal, \n                   ElementType=AnchorLine,\n                   elementkwargs=(Δxₘtop=[5.,0,0], xₘbot=[250.,0],L=290., buoyancy=-5e3))\n\nSee also: Hold, DofConstraint, off, equal, positive, @request, @functor\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.ElementCost","page":"Reference","title":"Muscade.ElementCost","text":"ElementCost{Teleobj,Treq,Tcost,Tcostargs} <: AbstractElement\n\nAn element to apply costs on another \"target\" element's dofs and element-results.   The target element must not be added separately to the model.  Instead, the  ElementType, and the named arguments to the target element are provided as input to the ElementCost constructor.\n\nNamed arguments to the constructor\n\nreq                 A request for element-results to be extracted from the target element, see @request.                       The request is formulated as if adressed directly to the target element.\ncost                A cost Functor cost(eleres,t,costargs...)→ℝ.                        eleres is the output of the above-mentionned request to the target element.  \ncostargs::NTuple=() or NamedTuple of additional arguments passed to cost.\nElementType         The named of the constructor for the relevant element.\nelementkwargs       A named tuple containing the named arguments of the ElementType constructor.     \n\nExample\n\n@functor with() cost(eleres,X,U,A,t;Fh0) = (eleres.Fh-Fh0)^2\nele1 = addelement!(model,ElementCost,[nod1];req=@request(Fh),\n                   cost=cost,\n                   costargs = (;Fh0=0.27),\n                   ElementType=AnchorLine,\n                   elementkwargs=(Λₘtop=[5.,0,0], xₘbot=[250.,0], L=290., buoyancy=-5e3))\n\nSee also: SingleDofCost, DofCost, @request, @functor \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.FreqXU","page":"Reference","title":"Muscade.FreqXU","text":"FreqXU{OX,OU}\n\nA linear frequency domain solver for optimisation FEM.\n\nAn analysis is carried out by a call with the following syntax:\n\ninitialstate    = initialize!(model)\nstateXU         = solve(FreqXU{OX,OU};Δt, p, t₀,tᵣ,initialstate)\n\nThe solver linearises the problem (computes the Hessian of the Lagrangian) at initialstate with time tᵣ, and solves it at times t=range(start=t₀,step=Δt,length=2^p). The return\n\nParameters\n\nOX                0 for static analysis                     1 for first order problems in time (viscosity, friction, measurement of velocity)                     2 for second order problems in time (inertia, measurement of acceleration) \nOU                0 for white noise prior to the unknown load process                     2 otherwise\n\nNamed arguments\n\ndbg=(;)           a named tuple to trace the call tree (for debugging).\nverbose=true      set to false to suppress printed output (for testing).\nsilenterror=false set to true to suppress print out of error (for testing) .\ninitialstate      a State.\nt₀=0.             time of first step.                      \nΔt                time step.\np                 2^p steps will be analysed.      \ntᵣ=t₀             reference time for linearisation.\ndroptol=1e-10     set to zero terms in the incremental matrices that are smaller than droptol in absolute value.                      \n\nOutput\n\nA vector of length 2^p containing the state of the model at each of these steps.                       \n\nSee also: solve, initialize!, study_singular, SweepX, DirectXUA\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.FunctionFromVector","page":"Reference","title":"Muscade.FunctionFromVector","text":"f  = FunctionFromVector(xs::AbstractRange,ys::AbstractVector)\ny  = f(x)\n\nLinear interpolation.  Fails if `x` is outside the range `xs`\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.Hold","page":"Reference","title":"Muscade.Hold","text":"Hold <: AbstractElement\n\nAn element to set a single X-dof to zero.  \n\nNamed arguments to the constructor\n\nfield::Symbol. The field of the X-dof to constraint.\nλfield::Symbol=Symbol(:λ,field). The field of the Lagrange multiplier.\n\nExample\n\nusing Muscade\nmodel = Model(:TestModel)\nnode  = addnode!(model,𝕣[0,0])\ne     = addelement!(model,Hold,[node];field=:tx)\n\nSee also: DofConstraint, DofLoad, DofCost \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.IdVec","page":"Reference","title":"Muscade.IdVec","text":"An \"identity vector\"\n\nid = IdVec i  = 9834987 id[i] == i # true for any i\n\nSee also Julia's identity function.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.Model","page":"Reference","title":"Muscade.Model","text":"model = Model([ID=:my_model])\n\nConstruct a blank model, which will be mutated to create a finite element [optimization] problem.\n\nSee also: addnode!, addelement!, describe, solve  \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.Monitor","page":"Reference","title":"Muscade.Monitor","text":"Muscade.Monitor <: AbstractElement\n\nAn element for for monitoring inputs to and outputs from another element, during an analysis.     \n\nInstead of adding the element to be monitored directly into the model, add this element with the element to be monitored as argument.\n\nInputs and outputs are @show'n. \n\nNamed arguments to the constructor\n\nElementType         The the type of element to be monitored-\ntrigger             A function that takes dbg as an input and returns a boolean                        (true) to printout.\nelementkwargs       a NamedTuple containing the named arguments of the ElementType constructor.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.Node","page":"Reference","title":"Muscade.Node","text":"Node\n\nThe eltype of vectors handed by Muscade as first argument to element constructors.\n\nExample: function SingleDofCost(nod::Vector{Node};class::Symbol, ... )\n\nSee also: coord \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.OffsetVector","page":"Reference","title":"Muscade.OffsetVector","text":"A simple offset vector that only implements \"setindex!\" and \"getindex\". Based on Memory, so cannot be extended.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.QuickFix","page":"Reference","title":"Muscade.QuickFix","text":"QuickFix <: AbstractElement\n\nAn element for creating simple elements with \"one line\" of code.   Elements thus created have several limitations:\n\nphysical elements with only X-dofs.\nonly R can be espied.\n\nThe element is intended for testing.  Muscade-based applications should not include this in their API. \n\nNamed arguments to the constructor\n\ninod::NTuple{Nx,𝕫}. The element-node numbers of the X-dofs.\nfield::NTuple{Nx,Symbol}. The fields of the X-dofs.\nres::Functor, where res(X::ℝ1,X′::ℝ1,X″::ℝ1,t::ℝ) → ℝ1, the residual.\n\nExamples\n\nA one-dimensional linear elastic spring with stiffness 2.\n\nusing Muscade\nmodel = Model(:TestModel)\nnode1  = addnode!(model,𝕣[0])\nnode2  = addnode!(model,𝕣[1])\n@functor with() res(x,u,a,t)=0.4x.+.08+.5x.^2) \ne = addelement!(model,QuickFix,[node1,node2];inod=(1,2),field=(:tx1,:tx1),res=res)\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.SingleAcost","page":"Reference","title":"Muscade.SingleAcost","text":"SingleAcost <: AbstractElement\n\nAn element with a single node, for adding a once-off cost to a single A-dof.  \n\nNamed arguments to the constructor\n\nfield::Symbol.\ncost::Functor, where \ncost(a::ℝ,[,costargs...]) → ℝ \ncostargs::NTuple=() or NamedTuple of additional arguments passed to cost\n\nRequestable internal variables\n\ncost, the value of the cost.\n\nExample\n\nusing Muscade\nmodel = Model(:TestModel)\nnode  = addnode!(model,𝕣[0,0])\n@functor with() acost(a,three)=(a/three)^2\ne     = addelement!(model,SingleAcost,[node];field=:EI,\n                    costargs=(3.,),cost=acost)\n\nSee also: DofCost, SingleDofCost,  Acost, ElementCost\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.SingleDofCost","page":"Reference","title":"Muscade.SingleDofCost","text":"SingleDofCost{Derivative,Class,Field,Tcost} <: AbstractElement\n\nAn element with a single node, for adding a cost to a given dof.  \n\nNamed arguments to the constructor\n\nclass::Symbol, either :X or :U.\nfield::Symbol.\ncost::Functor, where \ncost(x::ℝ,t::ℝ[,costargs...]) → ℝ if class is :X or :U, and \ncost(x::ℝ,    [,costargs...]) → ℝ if class is :A.\n[costargs::NTuple=() or NamedTuple] of additional arguments passed tocost``\nderivative::Int=0 0, 1 or 2 - which time derivative of the dof enters the cost. \t    \n\nRequestable internal variables\n\ncost, the value of the cost.\n\nExample\n\nusing Muscade\nmodel = Model(:TestModel)\nnode  = addnode!(model,𝕣[0,0])\n@functor with() xcost(x,t,three)=(x/three)^2\ne     = addelement!(model,SingleDofCost,[node];class=:X,field=:tx,\n                    costargs=(3.,),cost=xcost)\n\nSee also: DofCost, ElementCost\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.SingleUdof","page":"Reference","title":"Muscade.SingleUdof","text":"SingleUdof{XField,Ufield,Tcost} <: AbstractElement\n\nAn element that creates a Udof, and associates a cost to its value. The value of the Udof is applied as a load to a Xdof on the same node.  \n\nNamed arguments to the constructor\n\nXfield::Symbol.\nUfield::Symbol.\ncost::Functor, where cost(u::ℝ,t::ℝ[,costargs...]) → ℝ \n[costargs::NTuple=() or NamedTuple] of additional arguments passed tocost``\n\nRequestable internal variables\n\ncost, the value of the cost.\n\nExample\n\nusing Muscade\nmodel = Model(:TestModel)\nnode  = addnode!(model,𝕣[0,0])\n@functor with() ucost(u,t,three)->(u/three)^2\ne     = addelement!(model,SingleUdof,[node];Xfield=:tx,Ufield=:utx,\n                    costargs=(3.,),cost=ucost)\n\nSee also: DofCost, ElementCost\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.SpyAxis","page":"Reference","title":"Muscade.SpyAxis","text":"axis = Muscade.SpyAxis()\n\nSpoof a GLMakie.jl Axis/Axis3 object so that calls like\n\nlines!(  axis,args...;kwargs...)\n\nresult in args and kwargs being stored in axis, allowing to test functions that generate plots. Results are accessed by for example\n\naxis.call[3].fun        \naxis.call[3].args[2]\n\nTo get the name of the 3rd GLMakie.jl function that was called, and the 2nd input argument of this call.\n\nOnly lines!, scatter! and mesh! logging functions are implemented for now, but more functions can easily be added.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.SweepX","page":"Reference","title":"Muscade.SweepX","text":"SweepX{ORDER}\n\nA non-linear, time domain solver, that solves the problem time-step by time-step. Only the X-dofs of the model are solved for, while U-dofs and A-dofs are unchanged.\n\nSweepX{0} is Newton-Raphson, with feasibility line-search, to handle inequality constraints. \nSweepX{1} is implicit Euler, with feasibility line-search. \nSweepX{2} is Newmark-β, with Newton-Raphson iterations and feasibility line search\n\nIMPORTANT NOTE: Muscade does not allow elements to have state variables, for example, plastic strain, or shear-free position for dry friction.  Where the element implements such physics, this  is implemented by introducing the state as a degree of freedom of the element, and solving for its evolution, even in a quasi-static problem, requires the use of ORDER≥1.\n\nAn analysis is carried out by a call with the following syntax:\n\ninitialstate    = initialize!(model)\nsetdof!(initialstate,1.;class=:U,field=:λcsr)\nstates           = solve(SweepX{2};initialstate=initialstate,time=0:10)\n\nNamed arguments to solve:\n\ndbg=(;)           a named tuple to trace the call tree (for debugging)\nverbose=true      set to false to suppress printed output (for testing)\nsilenterror=false set to true to suppress print out of error (for testing) \ninitialstate      a State, obtain from ìnitialize! or SweepX.\ntime              maximum number of Newton-Raphson iterations \nβ=1/4,γ=1/2     parameters to the Newmark-β algorithm. Dummy if ORDER<2\nmaxiter=50        maximum number of equilibrium iterations at each step.\nmaxΔx=1e-5        convergence criteria: norm of X. \nmaxLλ=∞           convergence criteria: norm of the residual. \nsaveiter=false    set to true so that output states contains the state                     at the iteration of the last step analysed.  Useful to study                     a step that fails to converge. \nmaxLineIter=50    Maximum number of iteration in the feasibility line search.                     set to 0 to skip the line search (not recommended for models                     with inequality constraints).\nsfac=0.5          Parameter in the line search for a feasible point. If a                      tentative result is not feasible, backtrack by a factor sfac.                     If still not feasible, backtrack what is left by a factor sfac,                     and so forth, up to maxLineIter times.\nγfac=0.5          Parameter for feasibility. For an inequality constraint g(X)                     with reaction force λ, require g(X)*λ==γ, and multiply                     γ *= γfac at each iteration.                            \n\nOutput\n\nA vector of length equal to that of the named input argument time containing the states at the time steps.                       \n\nSee also: solve, initialize!, findlastassigned, study_singular, DirectXUA, FreqXU  \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.SweepXA","page":"Reference","title":"Muscade.SweepXA","text":"SweepXA{ORDER}\n\nA non-linear, time domain solver, that solves the problem time-step by time-step. Only the X-dofs of the model are solved for, while U-dofs and A-dofs are unchanged.\n\nSweepXA{0} is Newton-Raphson, with feasibility line-search, to handle inequality constraints. \nSweepXA{1} is implicit Euler, with feasibility line-search. \nSweepXA{2} is Newmark-β, with Newton-Raphson iterations and feasibility line search\n\nIMPORTANT NOTE: Muscade does not allow elements to have state variables, for example, plastic strain, or shear-free position for dry friction.  Where the element implements such physics, this  is implemented by introducing the state as a degree of freedom of the element, and solving for its evolution, even in a quasi-static problem, requires the use of ORDER≥1.\n\nAn analysis is carried out by a call with the following syntax:\n\ninitialstate    = initialize!(model)\nsetdof!(initialstate,1.;class=:U,field=:λcsr)\nstates           = solve(SweepXA{2};initialstate=initialstate,time=0:10)\n\nNamed arguments to solve:\n\ndbg=(;)           a named tuple to trace the call tree (for debugging)\nverbose=true      set to false to suppress printed output (for testing)\nsilenterror=false set to true to suppress print out of error (for testing) \ninitialstate      a State, obtain from ìnitialize! or SweepXA.\ntime              maximum number of Newton-Raphson iterations \nβ=1/4,γ=1/2     parameters to the Newmark-β algorithm. Dummy if ORDER<2\nmaxiter=50        maximum number of equilibrium iterations at each step.\nmaxΔx=1e-5        convergence criteria: norm of X. \nmaxLλ=∞           convergence criteria: norm of the residual. \nsaveiter=false    set to true so that output states contains the state                     at the iteration of the last step analysed.  Useful to study                     a step that fails to converge. \nmaxLineIter=50    Maximum number of iteration in the feasibility line search.                     set to 0 to skip the line search (not recommended for models                     with inequality constraints).\nsfac=0.5          Parameter in the line search for a feasible point. If a                      tentative result is not feasible, backtrack by a factor sfac.                     If still not feasible, backtrack what is left by a factor sfac,                     and so forth, up to maxLineIter times.\nγfac=0.5          Parameter for feasibility. For an inequality constraint g(X)                     with reaction force λ, require g(X)*λ==γ, and multiply                     γ *= γfac at each iteration.                            \n\nOutput\n\nA vector of length equal to that of the named input argument time containing the states at the time steps.                       \n\nSee also: solve, initialize!, findlastassigned, study_singular, DirectXUA, FreqXU  \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.addin!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Vector{Int64}, Int64}, SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC{Tv, Ti}, Int64, Int64}, Tuple{SparseArrays.SparseMatrixCSC{Vector{Int64}, Int64}, SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC{Tv, Ti}, Int64, Int64, Real}} where {Tv, Ti<:Integer}","page":"Reference","title":"Muscade.addin!","text":"addin!(asm,global,block,ibr,ibc,factor=1.)\n\nAdd a sparse block into a large out sparse matrix, at block-row and -column ibr and ibc.      Use prepare to allocate memory for global and build the assembler asm.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.addin!-Union{Tuple{Tv}, Tuple{Vector{Int64}, AbstractVector{Tv}, Vector{Tv}, Int64}, Tuple{Vector{Int64}, AbstractVector{Tv}, Vector{Tv}, Int64, Real}} where Tv","page":"Reference","title":"Muscade.addin!","text":"addin!(asm,outvec,blockvec,ibr)\n\nAdd a full block vector into a large outvec full vector.  at block-row ibr. Use prepare to create asm.\n\nSee also: prepare\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.composeJacobian","page":"Reference","title":"Muscade.composeJacobian","text":"composeJacobian{P}(Ty,X_)\n\nGiven Ty obtained using revariate, and X_, obtained using motion{P}(X) where X is a tuple of SVectors and P=constants(X), compute y, a tuple of length ND of AbstractArrays of same eltype as vectors in X, andy∂X₀, the Jacobian of∂0(y)with respect to∂0(X)`.\n\nSee also revariate, motion, motion⁻¹, composevalue   \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.composevalue","page":"Reference","title":"Muscade.composevalue","text":"composevalue{P,ND}(Ty,X_)\n\nGiven Ty obtained using revariate, and X_, obtained using motion{P}(X) where X is a tuple of length ND and P=constants(X), compute y, a tuple of length ND of AbstractArrays of same eltype as vectors in `X.\n\nSee also revariate, motion, motion⁻¹, composeJacobian  \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.default","page":"Reference","title":"Muscade.default","text":"value      = default{:fieldname}(namedtuple,defaultvalue)\nnamedtuple = default(inputnamedtuple,defaultnamedtuple)\n\nThe first syntax attempts to access field fieldname from namedtuple. If namedtuple does not have  such a field - or is not a NamedTuple, return defaultvalue.\n\nThe second syntax creates namedtuple from inputnamedtuple, supplementing with fields and values from defaultnamedtuple where there is no corresponding field in inputnamedtuple.  This a thin wrapper of Julia's Base.merge. \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.diffed_lagrangian","page":"Reference","title":"Muscade.diffed_lagrangian","text":"Muscade.diffed_lagrangian{P}(eleobj;Λ,X,U,A,t=0.,SP=nothing)\n\nCompute the Lagrangian, its gradients and Hessian, and the memory of an element. For element debugging and testing. \n\nP, the order of differentiation must be 1 or 2.\n\nThe output is a NamedTuple with fields Λ, X, U, A, t, SP echoing the inputs and fields\n\n∇L of format ∇L[iclass][ider]so that for example ∇L[2][3] contains the gradient of the Lagrangian wrt to the acceleration.  iclass is 1,2,3 and 4 for Λ, X, U and A respectively.\nif P==2: HL of format HL[iclass,jclass][ider,jder]so that for example HL[1,2][1,3] contains the mass matrix.\nFB as returned by lagrangian\n\nSee also: diffed_residual, print_element_array\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.geneig","page":"Reference","title":"Muscade.geneig","text":"λ,v,ncv = geneig{ALGO}(A,B,neig=5)\n\nSolves (A-λ*B)*v=0, finding the neig lowest eigenvalues λ (in absolute value) and the corresponding eigenvectors v (a Vector{Vector})\n\nInput\n\nALGO can be\n\n:SDP       if A is symmetric definite positive and B is symmetric.  Will return real λ and v.\n:Hermitian if A is symmetric indefinite and B is symmetric. Will return real λ and v.\n:Complex   otherwise, will return complex λ and v. \n\nOptional keyword arguments:\n\nmaxiter     = 300\nverbosity   = 0 ∈ {0,1,2,3}\nkrylovdim   = 2neig+6\n\nUses KrylovKit.jl. Freely based on VibrationGEPHelpers.jl and input from PetrKryslUCSD and stevengj.   See GIThub-blame for bug-credits.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.increment","page":"Reference","title":"Muscade.increment","text":"state = increment{OX}(initialstate,eiginc,imod,A)\n\nStarting from initalstate for which an EigX analysis has been carried out, and using the output eiginc of that analysis, construct new States representing the instantaneous state of the  vibrating structure\n\nInput\n\nOX the number of time derivatives to be computed.  increment(initialstate,eiginc,imod,A) defaults to OX=2\ninitialstate the same initial State provided to EigX to compute eiginc\neiginc obtained from EigX\nimod, an AbstractVector of integer mode numbers\nA, an AbstractVector of same length as imod, containing real or complex  amplitudes associated to the modes\n\nOutput\n\nstate a snapshot of the vibrating system\n\nSee also: EigX\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.increment-Union{Tuple{OX}, Tuple{Any, Muscade.EigXUincrement, Int64, AbstractVector{Int64}, AbstractVector}} where OX","page":"Reference","title":"Muscade.increment","text":"state = increment{OX}(initialstate,eiginc,iω,imod,A)\n\nStarting from initalstate for which an EigX analysis has been carried out, and using the output eiginc of that analysis, construct new States representing the instantaneous state of the  vibrating structure\n\nInput\n\nOX the number of time derivatives to be computed.  increment(initialstate,eiginc,imod,A) defaults to OX=2\ninitialstate the same initial State provided to EigXU to compute eiginc\neiginc obtained from EigXU\niω, the number of the frequency to consider. ω=iω*Δω where Δω is an input to EigXU. \nimod, an AbstractVector of integer mode numbers\nA, an AbstractVector of same length as imod, containing real or complex  amplitudes associated to the modes\n\nOutput\n\nstate a snapshot of the vibrating system\n\nSee also: EigXU\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.motion-Union{Tuple{NTuple{ND, StaticArraysCore.SVector{N, R}}}, Tuple{R}, Tuple{N}, Tuple{P}, Tuple{ND}} where {ND, P, N, R}","page":"Reference","title":"Muscade.motion","text":"P  = constant(X)\nX_ = motion{P}(X)\n\nTransform a NTuple of SVectors, for example the vector X provided as an input to residual or Lagrangian into a SVector of ∂ℝ.  This can be used by an element to  compute time derivatives, for example Euler, Coriolis and centrifugal accelerations,  or strain rates.\n\nSome principles of safe automatic differentiation must be adhered to:\n\nthe function that uses motion must also 'unpack' : no variable that is touched by  the output of motion must be returned by the function without having been unpacked by motion⁻¹. Touched variables can for example be marked with an underscore.\nThe precendence P must be calculated using constants with all variables that are input to  the function and may be differentiated.\nIf other levels of automatic differentiation are introduced within the function, unpack in reverse order of packing.    \n\nSee motion⁻¹\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.motion⁻¹-Union{Tuple{Real}, Tuple{P}} where P","page":"Reference","title":"Muscade.motion⁻¹","text":"P  = constants(X,U,A,t)\nND = length(X)\nX_  = motion{P,ND}(X)\nY_  = f(Y_)    \nY₀ = motion⁻¹{P,ND,0}(Y_)\nY₁ = motion⁻¹{P,ND,1}(Y_)\nY₂ = motion⁻¹{P,ND,2}(Y_)\nY  = motion⁻¹{P,ND  }(Y)\n\nExtract the value and time derivatives from a variable that is a function of the output of motion. In the above Y is a tuple of length ND.  One can use ∂0,∂1 and ∂2 to unpack Y.    \n\nSee also motion\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.revariate","page":"Reference","title":"Muscade.revariate","text":"TX = revariate{P}(V)\n\nThe variable V is a nested structure NamedTuples, Tuples and SArrays of  Reals (possibly: ∂ℝs).\n\nV is stripped of its partials, an revariated to  order P.\n\nTV = revariate(VX)\n\nrevariates to the order precedence(V).  \n\nrevariate, in conjunction with compose can be used to improve performance when the length of  V is smaller than the length of its partials.\n\nBe extremely careful never to mix any variable that is a function of V with any other variables containing  ∂ℝs but not produced by the same revariate.\n\nA special version of revariate\n\nV = (;X,U,A)\nS = (X=scale.X,U=scale.U,A=scale.A)\nTV = revariate{P}(V,S)\n\nallows to introduce scaling in automatic differentiation.  For this method, S and V have the same structure, with the important exception that Tuples in V must be ntuples (have elements of identical type T), and, to a Tuple in V corresponds  a variable of type T in V. Put simply: the same scale scale.X will be applied to ∂0[X], ∂1[X] and ∂2[X]. \n\nSee also: compose\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.to_order","page":"Reference","title":"Muscade.to_order","text":"to_order{P}(V)\n\nDecrease (lossy) or increase (pad partials with zeros) the order of differentiation of V. V is a nested structure of NamedTuple, Tuple, SArray, and the components of V must be of type ∂ℝ (otherwise, the number of partials would be undefined).\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.value-Union{Tuple{∂ℝ{P, N, R}}, Tuple{R}, Tuple{N}, Tuple{P}} where {P, N, R}","page":"Reference","title":"Muscade.value","text":"y = value{P}(Y)\n\nExtract the value of an automatic differentiation object, or SArray of such objects.    \n\nSee also: constants, variate, δ, ∂, VALUE, value_∂\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.value_∂-Union{Tuple{Any}, Tuple{N}, Tuple{P}} where {P, N}","page":"Reference","title":"Muscade.value_∂","text":"y,yₓ = value_∂{P,N}(Y)\ny,y′ = value_∂{P  }(Y)\n\nGet value and derivative in one operation.    \n\nSee also: constants, variate, δ, value, ∂, VALUE\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.variate-Union{Tuple{StaticArraysCore.SVector{N, R}}, Tuple{R}, Tuple{N}, Tuple{P}} where {P, N, R<:Real}","page":"Reference","title":"Muscade.variate","text":"X = variate{P,N}(x)\n\nwhere typeof(x)<:SVector{N}, create a SVector of automatic differentiation objects of precedence P.    \n\nX = variate{P}(x)\n\nwhere typeof(x)<:Real, create an object of precedence P.    \n\nSee also: constants, δ, value, ∂, VALUE, value_∂\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.δ-Union{Tuple{}, Tuple{R}, Tuple{N}, Tuple{P}} where {P, N, R<:Real}","page":"Reference","title":"Muscade.δ","text":"X = δ{P,N,R}()\n\ncreate a SVector of automatic differentiation objects of precedence P and value zero.    \n\nX = δ{P}()\n\nCreate automatic differentiation object of precedence P and value zero.  \n\nSee also: constants, variate, value, ∂, VALUE, value_∂\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.ℂ","page":"Reference","title":"Muscade.ℂ","text":"ℂ (\\bbC)\n\nan alias for abstract type Complex{<:Real}. For use in dispatching. ℂ1... ℂ4 are AbstractArrays of dimensions 1 to 4. ℂ11 is an AbstractVector of AbstractVector.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.ℕ","page":"Reference","title":"Muscade.ℕ","text":"ℕ (\\bbN)\n\nan alias for UInt64. For use in dispatching. ℕ1... ℕ4 are AbstractArrays of dimensions 1 to 4.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.ℝ","page":"Reference","title":"Muscade.ℝ","text":"ℝ (\\bbR)\n\nan alias for abstract type Real. For use in dispatching. ℝ1... ℝ4 are AbstractArrays of dimensions 1 to 4. ℝ11 is an AbstractVector of AbstractVector.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.ℤ","page":"Reference","title":"Muscade.ℤ","text":"ℤ (\\bbZ)\n\nan alias for abstract type Integer. For use in dispatching. ℤ1... ℤ4 are AbstractArrays of dimensions 1 to 4. ℤ11 is an AbstractVector of AbstractVector.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.∂-Union{Tuple{∂ℝ{P, N, R}}, Tuple{R}, Tuple{N}, Tuple{P}} where {P, N, R}","page":"Reference","title":"Muscade.∂","text":"yₓ = ∂{P,N}(Y)\n\nExtract the gradient of an automatic differentiation object.  If Y is a SArray,  the index of the partial derivative is appended to the indices of Y.   \n\ny′ = ∂{P}(Y)\n\nExtract the derivative of an automatic differentiation object (or SArray of such), where the variation was created by the syntax variate{P}.\n\nSee also: constants, variate, δ, value, VALUE, value_∂\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.𝔹","page":"Reference","title":"Muscade.𝔹","text":"𝔹 (\\bbB)\n\nan alias for Bool. For use in dispatching. 𝔹1... 𝔹4 are AbstractArrays of dimensions 1 to 4.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.𝕓","page":"Reference","title":"Muscade.𝕓","text":"𝕓 (\\bbb)\n\nan alias for Bool. For use in struct definitions. 𝕓1... 𝕓4 are Arrays of dimensions 1 to 4.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.𝕔","page":"Reference","title":"Muscade.𝕔","text":"𝕔 (\\bbc)\n\nan alias for Complex{Float64}. For use in struct definitions. 𝕔1... 𝕔4 are Arrays of dimensions 1 to 4. 𝕔11 is a Vector of Vector.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.𝕟","page":"Reference","title":"Muscade.𝕟","text":"𝕟 (\\bbn)\n\nan alias for UInt64. For use in struct definitions. 𝕟1... 𝕟4 are Arrays of dimensions 1 to 4.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.𝕣","page":"Reference","title":"Muscade.𝕣","text":"𝕣 (\\bbr)\n\nan alias for Float64. For use in struct definitions. 𝕣1... 𝕣4 are Arrays of dimensions 1 to 4. 𝕣11 is a Vector of Vector.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.𝕫","page":"Reference","title":"Muscade.𝕫","text":"𝕫 (\\bbz)\n\nan alias for Int64. For use in struct definitions. 𝕫1... 𝕫4 are Arrays of dimensions 1 to 4. 𝕫11 is a Vector of Vector.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Functions","page":"Reference","title":"Functions","text":"","category":"section"},{"location":"reference.html#Muscade.:∘₁-Tuple{Any, Any}","page":"Reference","title":"Muscade.:∘₁","text":"c = a∘₁b\n\nCompute the single-dot product of two arrays, so that cᵢⱼ=Σₖ aᵢₖ bₖⱼ where i and j can be multiple indices.\n\nSee also: ⊗,∘₂\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.:∘₂-Tuple{Any, Any}","page":"Reference","title":"Muscade.:∘₂","text":"c = a∘₂b\n\nCompute the double-dot product of two arrays, so that cᵢⱼ=Σₖₗ aᵢₖₗ bₖₗⱼ where i and j can be multiple indices.\n\nSee also: ∘₁,⊗\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.:⊗-Tuple{Any, Any}","page":"Reference","title":"Muscade.:⊗","text":"c = a⊗b\n\nCompute the exterior product of two arrays, so that cᵢⱼ=aᵢ bⱼ where i and j can be multiple indices.\n\nSee also: ∘₁,∘₂\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.GUI-Tuple{Any, Muscade.EigXUincrement}","page":"Reference","title":"Muscade.GUI","text":"GUI(eiginc,initialstate;[draw_shadow=true],[shadow=...],[model=...])\n\nTaking the output eiginc obtained from an EigXU, and the state initstate provided to EigXU, provide a GUI to explore the results.\n\nOptional keyword arguements are\n\ndraw_shadow whether to superimpose a drawing of initstate\nshadow a NamedTuple with any arguments to be passed to draw! initstate\nmodel a NamedTuple with any arguments to be passed to draw! the EigXU modes.\n\nSee also EigXU\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.GUI-Union{Tuple{AbstractVector{S}}, Tuple{S}, Tuple{nUder}, Tuple{nXder}, Tuple{nΛder}, Tuple{AbstractVector{S}, Any}} where {nΛder, nXder, nUder, S<:(Muscade.State{nΛder, nXder, nUder})}","page":"Reference","title":"Muscade.GUI","text":"GUI(state,refstate=state[1];dim=3,kwargs...)\n\nTaking state, a Vector of States output by various solvers, provide a GUI to explore the results.\n\nThis assumes that elements' drawing methods are writen for GLMakie.\n\nThe GUI allows to intereactively amplify responses (Λ,X,U and A-dofs) to  make then easier to visualise. For X-dofs, it is the difference from the refstate  (by default: state[1]) that is amplified.\n\nOptional keyword arguements are\n\ndim, 2 or 3 depending on whether elements assume Axis or Axis3 \nkwargs keywords argument, that will be passed to draw!\n\nSee also EigXU\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.McLaurin-Tuple{Tuple, Any}","page":"Reference","title":"Muscade.McLaurin","text":"McLaurin(Ty,x)\n\nTy::∂ℝ has partials to arbitrary order with respect to a variable x. These partials define a McLaurin expansion, which McLaurin evaluates at value x,  as if Ty had been computed at 0.\n\nMcLaurin handles nested structures of Tuples and SVectors of ∂ℝ, applying the expansion to each element.\n\nMcLaurin is a utility function behind compose and Taylor\n\nSee also: compose, Taylor, revariate, fast    \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.Taylor-Tuple{Tuple, Any, Any}","page":"Reference","title":"Muscade.Taylor","text":"Taylor(Ty,x₀,x)\n\nTy::∂ℝ has partials to arbitrary order evaluated at x₀. These partials define a Taylor expansion, which Taylor evaluates at value x\n\nTaylor handles nested structures of Tuples and SVectors of ∂ℝ, applying the expansion to each element.\n\nSee also: compose, McLaurin, revariate, fast    \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.VALUE-Tuple{Nothing}","page":"Reference","title":"Muscade.VALUE","text":"@show VALUE(Y)\n\nCompletely strip Y of partial derivatives.  Use only for debugging purpose.    \n\nSee also: constants, variate, δ, value, ∂, value_∂\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, AbstractMatrix{Muscade.NodID}}} where T<:AbstractElement","page":"Reference","title":"Muscade.addelement!","text":"eleid = addelement!(model,ElType,nodid;kwargs...)\n\nAdd one or several elements to model, connecting them to the nodes specified  by nodid.\n\nIf nodid is an AbstractVector: add a single element to the model. eleid is then a single element identifier.\n\nIf nodid is an AbstractMatrix: add multiple elements to the model. Each  row of nodid identifies the node of a single element. eleid is then  a vector of element identifiers.\n\nFor each element, addelement! will call eleobj = ElType(nodes;kwargs...) where nodes is a vector of nodes of the element.\n\nSee also: addnode!, describe, coord\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t<:Real}","page":"Reference","title":"Muscade.addnode!","text":"nodid = addnode!(model,coord)\n\nIf coord is an AbstractVector of Real: add a single node to the model.   Muscade does not prescribe what coordinate system to use.  Muscade will handle  to each element the coord of the nodes of the element, and the element  constructor must be able to make sense of it. nodid is a node identifier, that is used as input to addelement!.\n\nIf coord is an AbstractMatrix, its rows are treated as vectors of coordinates. nodid is then a vector of node identifiers.\n\nSee also: addelement!, coord , describe \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.allocate_drawing-Union{Tuple{E}, Tuple{Any, AbstractVector{E}}} where E<:AbstractElement","page":"Reference","title":"Muscade.allocate_drawing","text":"mut,opt = Muscade.allocate_drawing(axis,eleobjs;kwargs...)\n\nElements that are to be displayed in graphical output must implement a method for Muscade.allocate_drawing.\n\nThe method is to allocate opt, a NamedTuple of data that will not be mutated from frame to frame, but are usefull in Muscade.update_drawing or Muscade.display_drawing!.\n\nThe method is also to allocate mut, a NamedTuple of data that will be mutated from frame to frame.  When implementing graphics with GLMakie.jl, the fields of mut must be exactly the updatable inputs provided to GLMakie.jl's drawing primitives: in Muscade.display_drawing!\n\nlines!(axis,mut.x,mut.y)\n\nis acceptable, but \n\nlines!(axis,mut.x[:,s],mut.y[:,s])\nlines!(axis,mut.a.x,mut.a.y)\n\nare not.\n\nThe content of Arrays in opt and mut can be undef-ined.\n\nInputs are:\n\naxis the \"canvas\" to draw on, typicaly a GLMakie.jl Axis.\neleobjs an AbstractVector of element objects, of length nel.\nkwargs a NamedTuple containing the keyword arguments provided by the user. See default.\n\nSee also: Muscade.update_drawing, Muscade.display_drawing!\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.colnormalize-Union{Tuple{StaticArraysCore.SMatrix{ndim, nvec, R}}, Tuple{R}, Tuple{nvec}, Tuple{ndim}} where {ndim, nvec, R<:Real}","page":"Reference","title":"Muscade.colnormalize","text":"colnormalize(a)\n\nEuclidian-normalize the columns of an SMatrix\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.columnmatrix-Tuple{Vector}","page":"Reference","title":"Muscade.columnmatrix","text":"columnmatrix(v)\n\nReshape a vector into a matrix of size (length(v),1)    \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.compose-Tuple{Any, Any}","page":"Reference","title":"Muscade.compose","text":"compose(Ty,x)\n\nCompose automatic differentiation.  For example      Tx = revariate(x)     Ty = f(Tx)     y  = compose(Ty,x)     is faster than     y  = f(x) if the length of x is smaller than the length of its partials.\n\nSee also: revariate, fast    \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.constants-Tuple{Tuple}","page":"Reference","title":"Muscade.constants","text":"P = constants(a,b,c)\n\nGenerate a precedence P that is higher than the precedence of the arguments.   \n\nSee also: variate, δ, value, ∂, VALUE, value_∂\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.coord-Tuple{AbstractVector{Node}}","page":"Reference","title":"Muscade.coord","text":"c = coord(node)\n\nUsed by element constructors to obtain the coordinates of a vector of Nodes handed by Muscade to the constructor. c is accessed as \n\nc[inod][icoord]\n\nwhere inod is the element-node number and icoord an index into a vector of coordinates.\n\nNote that c[inod] points at the same memory as nod[inod].coord: do not mutate c[inod]!\n\nSee also: addnode!, addelement!, describe, solve  \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.describe-Tuple{Model, Muscade.EleID}","page":"Reference","title":"Muscade.describe","text":"describe(model,spec)\n\nPrint out information about model. spec can be \n\nan EleID to describe an element,\na DofID to describe a dof.\na NodID to describe a node,\n:doftyp to obtain a list of doftypes, \n:dof to obtain a list of dofs or \n:eletyp for a list of element types.\ndescribe(state,[class=:all])\n\nProvide a description of the dofs stored in state. class can be either :all, :Λ, :ΛX, :X, :U, :A or :scale.\n\nSee also: addelement!, addnode!\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.diffed_residual-Tuple{Eletyp} where Eletyp<:AbstractElement","page":"Reference","title":"Muscade.diffed_residual","text":"Muscade.diffed_residual(eleobj;X,U,A,t=0.,SP=nothing)\n\nCompute the residual, its gradients, and the memory of an element. For element debugging and testing. \n\nThe output is a NamedTuple with fields X, U, A, t, SP echoing the inputs and fields\n\nR containing the residual\n∇R of format ∇R[iclass][ider]so that for example ∇R[2][3] contains the mass matrix.  iclass is 2,3 and 4 for X, U and A respectively.\nFB as returned by residual\n\nSee also: diffed_lagrangian, print_element_array\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.display_drawing!-Union{Tuple{E}, Tuple{Any, Type{E}, Any, Any}} where E<:AbstractElement","page":"Reference","title":"Muscade.display_drawing!","text":"Muscade.display_drawing!(axis,MyElement,mut,opt)\n\nElements that are to be displayed in graphical output must implement a method for Muscade.display_drawing!.\n\nInputs are:\n\naxis the \"canvas\" to draw on, typicaly a GLMakie.jl Axis.\nMyElement used for dispatching to the right method.\nmut is a NamedTuple, as output by Muscade.update_drawing.  More specificaly, if implementing  graphics with GLMakie.jl, mut has been\nopt is as returned by Muscade.allocate_drawing\n\nWhen implementing graphics with GLMakie.jl, the fields of mut must be exactly the updatable inputs provided to GLMakie.jl's drawing primitives: in Muscade.display_drawing!\n\nlines!(axis,mut.x,mut.y)\n\nis acceptable, but \n\nlines!(axis,mut.x[:,s],mut.y[:,s])\n\nis not. The reason is that when doing graphics with GLMakie.jl, Muscade will recursively wrap each field of mut into an Observable before calling the elements' methods display_drawing!.  This allows Muscade to update the graphics  by just calling Muscade.update_drawing for each element.\n\nSee also: Muscade.allocate_drawing, Muscade.update_drawing\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.doflist-Union{Tuple{Type{E}}, Tuple{E}} where E<:AbstractElement","page":"Reference","title":"Muscade.doflist","text":"Muscade.doflist(::Type{E<:AbstractElement})\n\nElements must provide a method for Muscade.doflist.  \n\nThe method must take the element type as only input, and return a NamedTuple with fieldnames inod,class and field.  The tuple-fields are NTuples of the same length.  For example\n\nMuscade.doflist( ::Type{<:Turbine}) = (inod =(1   ,1   ,2        ,2        ),\n                                       class=(:X  ,:X  ,:A       ,:A       ),\n                                       field=(:tx1,:tx2,:Δseadrag,:Δskydrag))\n\nIn Λ, X, U and A handed by Muscade to residual or lagrangian, the dofs in the vectors will follow the order in the doflist. Element developers are free to number their dofs by node, by field, or in any other way.\n\nSee also: Muscade.lagrangian, Muscade.residual, Muscade.no_second_order  \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.draw!-Tuple{Any, Muscade.State, Vector{Muscade.EleID}}","page":"Reference","title":"Muscade.draw!","text":"graphic = draw!(axis   ,state[,els];kwargs...)\n          draw!(graphic,state[,els];kwargs...)\n\nPlot all or part of a Model.\n\nCurrently, only GLMakie.jl is supported and tested, but Muscade is designed to allow application developers to  chose other graphic system, including exporting data to Paraview. GLMakie.jl is thus not a dependency of Muscade, and must be installed and invoked (using) separately to run demos provided with Muscade.\n\nApplication developers can implement methods Muscade.allocate_drawing, Muscade.update_drawing and Muscade.display_drawing! to make their element \"drawable\".\n\naxis a GLMakie.jl Axis, a Muscade.SpyAxis (for automated testing of graphic generation), and in the future           a HDF5/VTK file handle for export of data to Paraview.    state a single State. els specifies which elements to draw and can be either\n\na vector of EleIDs (obtained from addelement!`), all corresponding to the same concrete element type\na concrete element type (see eletyp).\nomitted: all the element of the model are drawn.\n\nkwargs... is any additional key words arguments that will be passed to the draw method of each element,  for example to specify colors, etc.  See the elements' documentation.\n\nWhen a plot of the Model is first generated, axis must be provided, and draw! returns graphic. graphic can then be provided for further calls to draw! to update the graphic.\n\nSee also: getdof, @request, @espy, addelement!, solve\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.eletyp-Tuple{Model}","page":"Reference","title":"Muscade.eletyp","text":"et = eletyp(model)\n\nReturn a vector of the concrete types of elements in the model. \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.equal","page":"Reference","title":"Muscade.equal","text":"equal(t) → :equal\n\nA function which for any value t returns the symbol equal.  Useful for specifying the keyword argument mode=equal in adding an element of type `DofConstraint to a Model.\n\nSee also: DofConstraint, ElementConstraint, off, positive\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Muscade.fast-Tuple{Any, Any}","page":"Reference","title":"Muscade.fast","text":"y,... = fast(f,x)\n\nIn the context of forward automatic differentiation using ∂ℝ, accelerate the evaluation of y,...= f(x) if the length of x is smaller than the length of its partials.\n\nAlso work where x is a nested structure of Tuples and NamedTuples where the leaves are ℝ or SArray{S,R} where {S,R<:ℝ}.    \n\nBe extremely careful with closures, making sure that f does not capture variables of type ∂ℝ.\n\nWrapper function of revariate and McLaurin      \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.findlastassigned-Tuple{Vector}","page":"Reference","title":"Muscade.findlastassigned","text":"ilast = findlastassigned(state)\n\nFind the index ilast of the element before the first non assigment element in a vector state.\n\nIn multistep analyses, solve returns a vector state of length equal to the number of steps requested by the user.  If the analysis is aborted, solve still returns any available results at the begining of state, and the vector state[1:ilast] is fully assigned.\n\nSee also: solve\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.getdof-Tuple{Muscade.State}","page":"Reference","title":"Muscade.getdof","text":"dofres = getdof(state;[class=:X],field=:somefield,nodID=[nodids...],[order=0])\n\nObtain the value of dofs of the same class and field, at various nodes and for various states.\n\nIf state is a vector, the output dofres has size (ndof,nstate). If state is a scalar, the output dofres has size (ndof,).\n\nSee also: getresult, addnode!, solve\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.getndof-Tuple{DataType}","page":"Reference","title":"Muscade.getndof","text":"getndof(model|Element)\ngetndof(model|Element,class)\ngetndof(model|Element,(class1,class2,[,...]))\n\nwhere class can be any of :X, :U, :A: get the number of dofs of each specified dof-classes for the variable model or the type Element.  If no class is specified getndof return the asum of the number of dofs of all classes.\n\nSee also: describe\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.getresult-Union{Tuple{S}, Tuple{Vector{S}, Any, Vector{Muscade.EleID}}} where S<:Muscade.State","page":"Reference","title":"Muscade.getresult","text":"eleres = getresult(state,req,els)\n\nObtain an array of nested NamedTuples and NTuples of element results. req is a request defined using @request. state a vector of States or a single State. els can be either\n\na vector of EleIDs (obtained from addelement!) all corresponding to the same concrete element type\na concrete element type (see eletyp).\n\nIf state is a vector, the output dofres has size (nele,nstate). If state is a scalar, the output dofres has size (nele).\n\nSee also: getdof, @request, @espy, addelement!, solve, eletyp\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.getsomedofs-Union{Tuple{Nder}, Tuple{NTuple{Nder, StaticArraysCore.SVector}, Any}} where Nder","page":"Reference","title":"Muscade.getsomedofs","text":"rotations = getsomedofs(X,[3,6])\n\nUsed by elements' residual or lagrangian to some degrees of freedom, and their time derivatives, from the variables X and U. \n\nSee also: ∂0,∂1,∂2  \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.getδt-Tuple{Any, Any}","page":"Reference","title":"Muscade.getδt","text":"getδt(n,δω) = 2π/(n*δω)\n\n`n` is the length of the time series\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.getδω-Tuple{Any, Any}","page":"Reference","title":"Muscade.getδω","text":"δω=getδω(n,δt) = 2π/(n*δt)\n\n`n` is the length of the time series\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.initialize!-Tuple{Model}","page":"Reference","title":"Muscade.initialize!","text":"initialstate = initialize!(model)\n\nReturn an initial State for the model with all dofs set to zero\n\nModifying a model (invoquing addnode! and addelement! after initialize! will result in an error) \n\nOptional keyword arguments: nΛder=1, nXder=1, nUder=1 to specify the number of \"derivatives\" to store in the State.   note that \"n⋅der==order+1\", that is, for a dynamic problem (with accelerations), nXder=3 so that   order==2.  Setting  n⋅der is only required if setdof! will be used.  A dynamic solver   handles a \"static\" initial state perfectly well. time=-∞ the time associated to the initial state.  Note that for example setting time=0., and then calling a solver with a first time step also at 0. causes an error.  \n\nSee also: setdof!, Model, addnode!, addelement!, solve\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.lagrangian-Tuple{}","page":"Reference","title":"Muscade.lagrangian","text":"@espy function Muscade.lagrangian(eleobj::MyElement,Λ,X,U,A,t,SP,dbg)\n    ...\n    return L,FB\nend\n\nElements must implement a method for Muscade.lagrangian or Muscade.residual.\n\nInputs\n\neleobj an element object\nΛ a SVector{nXdof,R} where{R<:Real}, Lagrange multipliers (aka δX virtual displacements).\nX a NTuple of SVector{nXdof,R} where{R<:Real}, containing the Xdofs and, depending on the solver,  their time derivatives. Use x=∂0(X), v=∂1(X) and a=∂2(X) to safely obtain vectors of zeros  where the solver leaves time derivatives undefined.\nU a NTuple of SVector{nUdof,R} where{R<:Real}, containing the Udofs and, depending on the solver,  their time derivatives. Use u=∂0(U), ̇u=∂1(U) and ̈u=∂2(U) to safely obtain vectors of zeros  where the solver leaves time derivatives undefined.\nA a SVector{nAdof,R} where{R<:Real}.\nt a `Real containing the time.\nSP solver parameters (for example: the barrier parameter γ for  interior point methods).\ndbg a NamedTuple to be used only for debugging purposes.\n\nOutputs\n\nL the lagrangian\nFB feedback from the element to the solver (for example: can γ be  reduced?). Return noFB of the element has no feedback to provide.\n\nSee also: Muscade.residual, Muscade.doflist, @espy, ∂0, ∂1, ∂2, noFB, \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.mergerequest-Tuple{Any}","page":"Reference","title":"Muscade.mergerequest","text":"req = mergerequest(o.req)\n\n\"Outer\" elements like ElementCost and ElementConstraint use requests to apply a cost or a constraint to requestables from another \"target\" element. These outer elements must be coded carefully so that getresult can be used to extracted both requestable internal results from the outer and from the target element.\n\nmergerequest  is used to merge the requests for the request needed to enforce a cost or constraint, and the user's  request for element to be obtained from the analysis.  The call to mergerequest, to be inserted in the code of lagrange  for the outer element will be modified by @espy to something like req = mergerequest(o.req,req), to merge o.req of the outer element to any requests req transmitted by the user to extract results (or by an outer element to the outer element).    \n\nSee the code of ElementCost's constructor and lagrange method for an example.\n\nSee also: ElementCost, @request, getresult\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.mod_onebased-Tuple{Integer, Any}","page":"Reference","title":"Muscade.mod_onebased","text":"mod_onebased(i,n) = mod(i-1,n)+1\n\nFor i::ℤ, returns a value in {1,...n}.  This differs from mod which return a value in [0,n[   \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.muscadeerror-Tuple{NamedTuple, Any}","page":"Reference","title":"Muscade.muscadeerror","text":"muscadeerror([[dbg,]msg])\n\nThrow a MuscadeException, where\n\ndbg is a NamedTuple that contains \"location information\"\n\n(for example: solver, step, iteration, element, quadrature point) that will be displayed with the error message.\n\nmsg is a String describing the problem.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.no_second_order-Tuple{Type{<:AbstractElement}}","page":"Reference","title":"Muscade.no_second_order","text":"no_second_order(::Type{E<:AbstractElement})\n\nElements that define residual are normaly mostly differentiated only to the first order, to avoid excessive compilation and/or execution time. To allow differentiation to the second order (for elements with few dofs), implement a method after the below pattern:   \n\nMuscade.no_second_order(     ::Type{<:MyElementType}) = Val(false)\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.off","page":"Reference","title":"Muscade.off","text":"off(t) → :off\n\nA function which for any value t returns the symbol off.  Useful for specifying the keyword argument mode=off in adding an element of type `DofConstraint to a Model.\n\nSee also: DofConstraint, ElementConstraint, equal, positive\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Muscade.plot_block_matrix_sparsity-Union{Tuple{AbstractArray{SparseArrays.SparseMatrixCSC{Tv, Ti}, 2}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Reference","title":"Muscade.plot_block_matrix_sparsity","text":"Muscade.plot_block_matrix_sparsity(M)\n\nSpecialised tool to visualise the sparsity pattern of a matrix produced by DirectXUA. M is either a Matrix or a SparseMatrixCSC (the block structure), whose entries  are themselve SparseMatrixCSC (the structure of each block).    \n\nOptional inputs:\n\nsize=500        Size in pizel of the figure window.\nmarkersize=3    Size of dots for non-zero elements.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.plot_matrix_sparsity-Tuple{SparseArrays.SparseMatrixCSC}","page":"Reference","title":"Muscade.plot_matrix_sparsity","text":"Muscade.plot_matrix_sparsity(M)\n\nOpens a GLMakie figure and plots the sparsity pattern of M::SparseMatrixCSC.\n\nActual non zero-elements are plotted in green.  Remaining structuraly non-zero elements are plotted in red.\n\nOptional inputs:\n\nsize=500        Size in pizel of the figure window.\ntitle=nothing   Title of the figure window.\nmarkersize=3    Size of dots for non-zero elements.\natol=1e-9        Tolerance for actual non-zero elements.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.positive","page":"Reference","title":"Muscade.positive","text":"positive(t) → :positive\n\nA function which for any value t returns the symbol positive.  Useful for specifying the keyword argument mode=positive in adding an element of type `DofConstraint to a Model.\n\nSee also: DofConstraint, ElementConstraint, off, equal\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Muscade.prepare-Union{Tuple{SparseArrays.SparseMatrixCSC{SparseArrays.SparseMatrixCSC{Tv, Int64}, Int64}}, Tuple{Tv}} where Tv","page":"Reference","title":"Muscade.prepare","text":"bigmat,bigmatasm,bigvecasm,bigvecdis = prepare(pattern)\n\nPrepare for the assembly of sparse blocks into a large sparse matrix.  bigmat is allocated, with the correct sparsity structure, but its nzval undef'ed.     Where some blocks share the same sparsity structure, blocks in pattern can have === elements.\n\npattern is a SparseMatrixCSC{<:SparseMatrixCSC}, where empty blocks are structuraly zero\n\nSee also: addin!\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.print_element_array-Tuple{AbstractElement, Symbol, AbstractVector}","page":"Reference","title":"Muscade.print_element_array","text":"Muscade.print_element_array(eleobj,class,V)\n\nShow a vector (or a matrix) V, the rows of V being described as corresponding to eleobj dof of class class (:X, :U or :A). This can be used to print degrees of freedom, residuals, their derivatives, or gradients and Hessian of the Lagrangian.\n\nSee also: diffed_residual, diffed_lagrangian\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.print_nz-Tuple{Any}","page":"Reference","title":"Muscade.print_nz","text":"print_nz(S::SparseMatrixCSC)\n\nList the structuraly non-zero entries of the sparse matrix.    \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.residual-Tuple{}","page":"Reference","title":"Muscade.residual","text":"@espy function Muscade.residual(eleobj::MyElement,X,U,A,t,SP,dbg)     ...     return R,FB end\n\nElements must implement a method for Muscade.residual or Muscade.lagrangian.\n\nInputs\n\neleobj an element object\nX a NTuple of SVector{nXdof,R} where{R<:Real}, containing the Xdofs and, depending on the solver,  their time derivatives. Use x=∂0(X), v=∂1(X) and a=∂2(X) to safely obtain vectors of zeros  where the solver leaves time derivatives undefined.\nU a NTuple of SVector{nUdof,R} where{R<:Real}, containing the Udofs and, depending on the solver,  their time derivatives. Use u=∂0(U), ̇u=∂1(U) and ̈u=∂2(U) to safely obtain vectors of zeros  where the solver leaves time derivatives undefined.\nA a SVector{nAdof,R} where{R<:Real}.\nt a `Real containing the time.\nSP solver parameters (for example: the barrier parameter γ for  interior point methods).\ndbg a NamedTuple to be used only for debugging purposes.\n\nOutputs\n\nR the residual\nFB feedback from the element to the solver (for example: can γ be  reduced?). Return noFB of the element has no feedback to provide.\n\nSee also: Muscade.lagrangian, Muscade.no_second_order, Muscade.doflist, @espy, ∂0, ∂1, ∂2, noFB\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.rowmatrix-Tuple{Vector}","page":"Reference","title":"Muscade.rowmatrix","text":"rowmatrix(v)\n\nReshape a vector into a matrix of size (1,length(v))    \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.setdof!-Tuple{Muscade.State, Vector{Float64}}","page":"Reference","title":"Muscade.setdof!","text":"state = setdof!(state,value        ;[class=:X],field=:somefield,                  [order=0])\nstate = setdof!(state,value::Vector;[class=:X],field=:somefield,nodID=[nodids...],[order=0])\n\nSet the value of dofs of the same class and field, at various nodes and for various states. There are two methods:\n\nA single value is applied to all relevant nodes in the model\nvalue and nodID are vectors of the same lengths, and each element in value is applied to the corresponding node.\n\nsetdof! is peculiar in that it modifies its input state variable, but must be used as a function. A call like stateout = setdof!(statein,value;class=:X,field=:somefield,order=1) can turn out in two ways: If the state already stores derivatives in X to order 1, then statein is mutated and statein===stateout. Otherwise, statein is unchanged, stateout is a new object, sharing as much memory as possible with statein. To avoid confusion, always use the syntax shown above.\n\nSee also: getresult, addnode!, solve\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.setscale!-Tuple{Model}","page":"Reference","title":"Muscade.setscale!","text":"setscale!(model;scale=nothing,Λscale=nothing)\n\nProvide scale value for each type (class and field) of dof in the model.   This is usued to improve the conditioning of the incremental problems and for convergence criteria. scale is a NamedTuple with fieldnames within  X, U and A.  Each field is itself a NamedTuple with fieldnames being dof fields, and value being the expected order of magnitude.\n\nFor example scale = (X=(tx=10,rx=1),A=(drag=3.)) should be read as: X-dofs of field :tx are expected to be of the order of magnitude of 10m in the solution, :rx to be of the order of 1 radian, and A-dofs of field drag of the order of 3.  All other degrees of freedom are of the order of 1.\n\nDetermining scaling coefficients that improve the condition number of incremental matrices is a hard problem.\n\nΛscale is a scalar. The scale of a Λ-dof will be deemed to be the scale of the  corresponding X-dof, times Λscale.\n\nSee also: addnode!, describe, coord, Muscade.study_scale\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.solve-Tuple{Type{<:Muscade.AbstractSolver}}","page":"Reference","title":"Muscade.solve","text":"solve(Solver;dbg=(;),verbose=true,silenterror=false,kwargs...)\n\nExecute an analysis using solver Solver (e.g. SweepX, DirectXUA...), and  safeguard partial results in the case of error. \n\nNamed arguments\n\ndbg=(;)           a named tuple to trace the call tree (for debugging)\nverbose=true      set to false to suppress printed output (for testing)\nsilenterror=false set to true to suppress print out of error (for testing) \nkwargs...         Further arguments passed on to the method solve provided by the solver\n\nSee also: SweepX, DirectXUA, initialize! \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.sparser!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Function}","page":"Reference","title":"Muscade.sparser!","text":"sparser!(S::SparseMatrixCSC,keep::Function)\n\nEliminate terms that do not satisfy a criteria from the storage of a sparse matrix. S will be mutated, and the size of its internal storage modified. keep is a Function which to an index into S.nzval associate true if storage is to be kept for this term and false otherwise. Alternatively, keep can be a Vector{Bool}\n\nExamples\n\nsparser!([T],S,i->abs(S.nzval[i])>tol)\nsparser!([T],S,keep::Vector{Boolean})\n\nIf T is provided (initialised as T = copy(S)), then result is set in T, S is unchanged, other wise S is mutated in place. The input keep::Vector{Boolean} must be of length nnz(S).\n\nsparser!([S1,S2,...],rtol=1e-9)\n\nOperates in place, reducing the sparses S1, S2 etc... to a common sparsity pattern.    \n\nwarning: Warning\nIn the first example, the keep function accesses S.nzval[i], and the term is then mutated by sparser!.  Any criteria requiring multiple access to nzval must build a Vector before calling sparser!.\n\nwarning: Warning\nNote that assemble! computes the nzval of a sparse, assumning that its sparsity structure colptr and rowval is unchanged since sparse storage was allocated by asmmat in prepare.  In other words, if applying sparser! directly to a sparse returned by assemble!, assemble! can no longer be called for this matrix. \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.study_scale-Tuple{Muscade.State}","page":"Reference","title":"Muscade.study_scale","text":"scale = Muscade.study_scale(state;[SP=nothing],[verbose=false],[dbg=(;)])\n\nReturns a named tuple of named tuples for scaling the model, accessed as     scaled.myclass.myfield, for example scale.X.tx1.\n\ninfo: Info\nThe format of scale is not identical to the input expected by setscale!\n\nIf verbose=true, prints out a report of the analysis underlying the proposed scale.  The proposed scaling depends on the state passed as input - as it is computed for a given incremental matrix.\n\nSee also: setscale!\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.study_singular-Tuple{Muscade.State}","page":"Reference","title":"Muscade.study_singular","text":"matrix = Muscade.study_singular(state;SP,[iclasses=(Λ,:X,:U,:A)],[jclasses=iclasses],[verbose::𝕓=true],[dbg=(;)])\n\nGenerates an incremental matrix for state (no time derivatives) corresponding to the classes required,  and report on the null space of the matrix.\n\nIn teh present implementation, the incremental matrix is converted to full format, limiting the applicability to small models.\n\nThe function returns the incremental matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.toggle-Union{Tuple{Tb}, Tuple{Ta}, Tuple{Bool, Ta, Tb}} where {Ta, Tb}","page":"Reference","title":"Muscade.toggle","text":"toggle(condition,a,b)\n\nTypestable equivalent of condition ? a : b.   Returns a value converted to promote_type(typeof(a),typeof(b))\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.update_drawing-Union{Tuple{E}, Tuple{Any, AbstractVector{E}, Vararg{Any, 9}}} where E<:AbstractElement","page":"Reference","title":"Muscade.update_drawing","text":"mut = Muscade.update_drawing(  axis,::AbstractVector{E},oldmut,opt, Λ,X,U,A,t,SP,dbg)\n\nElements that are to be displayed in graphical output must implement a method for Muscade.allocate_drawing.\n\nFor parametric element types\n\nMuscade.update_drawing(axis,o::AbstractVector{Teleobj}, Λ,X,U,A,t,SP,dbg;kwargs...) \n    where{Teleobj<:MyElement}\n\nFor non-parametric element types, one can simplify the above to:\n\nMuscade.update_drawing(axis,o::AbstractVector{MyElement}, Λ,X,U,A,t,SP,dbg;kwargs...)\n\nInputs are:\n\naxis the \"canvas\" to draw on, typicaly a GLMakie.jl Axis.\neleobjs an AbstractVector of element objects, of length nel.\noldmut the output mut of Muscade.allocate_drawing or of a previous call to Muscade.update_drawing.\nopt the output opt of Muscade.allocate_drawing\nΛ a matrix of size (nXdof,nel)\nX a NTuple (over the derivatives) of matrices of size (nXdof,nel)\nU a NTuple (over the derivatives) of matrices of size (nUdof,nel)\nA a matrix of size (nAdof,nel)\nt time\nSP solver parameters\ndbg debuging information\nkwargs a NamedTuple containing the keyword arguments provided by the user. See default.\n\nSee also: Muscade.allocate_drawing, Muscade.display_drawing!\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.zero!-Tuple{Base.RefValue}","page":"Reference","title":"Muscade.zero!","text":"zero!(a)\n\nSet to zero all elements of an arrays. If a is sparse,  the vector nzval of values is set to zero and the sparsity structure is unchanged.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.∂0-Tuple{Any}","page":"Reference","title":"Muscade.∂0","text":"position = ∂0(X)\n\nUsed by elements' residual or lagrangian to extract the zero-th order time derivative from the variables X and U.\n\nSee also: ∂1,∂2,getsomedofs  \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.∂1-Tuple{Any}","page":"Reference","title":"Muscade.∂1","text":"velocity = ∂1(X)\n\nUsed by elements' residual or lagrangian to extract the first order time derivative from the variables X and U. Where the solver does not provide this derivative (e.g. a static solver), the output is a vector of zeros.\n\nSee also: ∂0,∂2,getsomedofs  \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.∂2-Tuple{Any}","page":"Reference","title":"Muscade.∂2","text":"position = ∂2(X)\n\nUsed by elements' residual or lagrangian to extract the zero-th order time derivative from the variables X and U. Where the solver does not provide this derivative (e.g. a static solver), the output is a vector of zeros.\n\nSee also: ∂0,∂1,getsomedofs  \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.𝔉-Union{Tuple{R}, Tuple{AbstractVector{R}, Real}} where R<:Real","page":"Reference","title":"Muscade.𝔉","text":"X = 𝔉(x,δt)  # typeset with \\mfrakF\\Bbbr\n\nFourrier transform of a real time series x stored at time steps δt and length 2N = 2*2^p into a complex spectre X stored at frequency intervals δω=getδω(2N,δt)=2π/(2N*δt).   The length of the spectre is N: only positive frequencies are stored (the Fourrier  transform of real functions are Hermitian).\n\nThis provides a discretization of the unitary Fourrier transform, \n\nG(ω) = 𝔉(g)(ω) = 1/√(2π) ∫exp(-𝑖ωt) g(t) dt\n\n𝔉 is unitary, in the sense that\n\nsum(abs2.(x))*δt ≈ 2*(sum(abs2.(X)) - abs2.(X[1])/2)*δω\n\n(since the discrete spectre is provided for ω≥0, it contains only half the energy)\n\nArguments\n\nx a vector of real numbers representing a time series.  Its length must be a power of two.\nδt the time step of the time series\n\nExample\n\nX   = 𝔉(x,δt) \nδω  = getδω(length(x),δt)\nx′  = 𝔉⁻¹(X,δω) # ≈ x\n\nSee also: 𝔉⁻¹, getδω, getδt,\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.𝔉⁻¹-Union{Tuple{R}, Tuple{AbstractArray{Complex{R}, 1}, Real}} where R<:Real","page":"Reference","title":"Muscade.𝔉⁻¹","text":"x = 𝔉⁻¹(X,δω)  # typeset with \\mfrakF\\^-\\^1\n\nSee 𝔉    \n\nArguments\n\nX a vector of complex numbers representing one side of a spectra. Its length must be a power of two.\nδω, the angular frequency step of spectra\n\nExample\n\nX   = 𝔉(x,δt) \nδω  = getδω(length(x),δt)\nx′  = 𝔉⁻¹(X,δω) # ≈ x\n\nSee also: 𝔉⁻¹, getδω, getδt,\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.𝕫log2-Tuple{Int64}","page":"Reference","title":"Muscade.𝕫log2","text":"𝕫log2(i::𝕫)\n\nCompute the integer log2 of an integer, fast. Fails if i is not a power of two.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Macros","page":"Reference","title":"Macros","text":"","category":"section"},{"location":"reference.html#Muscade.@espy-Tuple{Any}","page":"Reference","title":"Muscade.@espy","text":"@espy function ... end\n\nFrom an anotated function code, generate     - \"clean\" code, in which the anotations have been deleted, and with        the call syntax argout... = foo(argin...)     - \"espying\" code, with added input and ouput arguments       argout...,res = foo(argin...,req) where req has been       generated using @request and res is a nested structure       of NamedTuples and NTuples containing the requested data.\n\nThe macro is not general: it is designed for residual and lagrangian, which for performance have to be programmed in \"immutable\" style: they must never mutate variables (this implies in particular, no adding into an array in a loop over Gauss points). So @espy only supports the specific programming constructs needed in this style.\n\nThe following is an example of anotated code:\n\n@espy function residual(x::Vector{R},y) where{R<:Real}\n    ngp=2\n    accum = ntuple(ngp) do igp\n        ☼z = x[igp]+y[igp]\n        ☼s,☼t  = ☼material(z)\n        ♢square = s^2\n        @named(s) \n    end\n    r = sum(i->accum[i].s,ngp)\n    return r,nothing,nothing\nend\n\nThe keyword function is preceded by the macro-call @espy.  \nThe name of requestable variables is preceded by ☼ (\\sun).  Such anotation must always appear on the left of an assigment. \nIf the name of a variable is preceded by ♢ (\\diamond), then the variable is evaluated only if requested. Such a notation can only be used if there is only one variable left of the assignement.\nThe name of a function being called must be preceded by ☼ if the definition of the function is itself preceeded by the macro-call @espy.\nfor-loops are not supported. do-loops must be used: to be efficient,  residual and lagrangian must not allocate and thus use immutables.\nThe keyword return must be explicitly used, and if must be followed the a comma separated list of output variables. Syntaxes like return if... are not supported.  \n\nSee also: @request, @espydbg, getresult\n\n\n\n\n\n","category":"macro"},{"location":"reference.html#Muscade.@espydbg-Tuple{Any}","page":"Reference","title":"Muscade.@espydbg","text":"@espydbg function ... end\n\nGenerate the same code as @espy and print it (for debug purposes).\n\nSee also: @espy, @request\n\n\n\n\n\n","category":"macro"},{"location":"reference.html#Muscade.@functor-Tuple{Any, Any}","page":"Reference","title":"Muscade.@functor","text":"a = 3\n@functor with(a,e=2) function f(x::Real)\n    return a*x^e\nend\n\nor\n\na = 3\n@functor with(a,e=2)  f(x::Real)=a*x^e\ne = 1\n@functor with(a,e)    f(x::Real)=a*x^e\n@functor with()       f(x::Real)=x^2\n\nThis is roughly equivalent to a closure defined as\n\nf(x::Real)=a*x^e\n\nFunctors are meant to facilitate the definition of \"functions\" in a Muscade input script,  while avoiding several of the issues associated with defining a function (and in particular a closure) in a script:    \n\nA closure captures a variable \"by reference\", while @functor captures it by value, which might be more intuitive. \nTo ensure type stability, the variables captured by a closure would have to be declared const - forbidding to update  the input value in a script without restarting Julia.\nIf the code of the function is not changed, the function is not parsed and compiled again, accelerating the re-analysis.\n\nIt is not possible to associate multiple methods to a functor.\n\nFunctor is a subtype of the abstract type Function: functions that accept a arg::Function as an  input will accept arg to be a Functor.  Functions that require arg:Functor will not accept a classical Function, thus enforcing capture by value etc.\n\n\n\n\n\n","category":"macro"},{"location":"reference.html#Muscade.@request-Tuple{Any}","page":"Reference","title":"Muscade.@request","text":"req = @request expr\n\nCreate a request of internal results wanted from a function. Considering the function presented as example for @espy, examples of possible syntax include\n\nreq       = @request gp(s,z,material(a,b))\nreq       = @request gp(s)\nreq       = @request gp(material(a))\n\nThe first expression can be read as follows: \"In the function, there is a do loop over variable igp, and within this loop a call to a function material.  Results s and z are wanted from within the loop, and results a and b from within material.\n\nThe corresponding datastructure containing the results for each element is a nesting of NTuples and NamedTuples,  and can be accessed as out.gp[igp].material.a and so forth.        \n\nSee also: @espy, @espydbg\n\n\n\n\n\n","category":"macro"},{"location":"reference.html#Muscade.@typeof-Tuple{Any}","page":"Reference","title":"Muscade.@typeof","text":"inftyp,rettyp = Muscade.@typeof(foo(args...[;kwargs...]))\n\nDetermine the inferred type and the returned type of the output[s] returned by the relevant method-instance of foo.\nUseful to study type-stability in `lagrangian`, `residual` and more.\nThis does not work on all operating systems, and should thus only be used for debugging.  \nIn tests, use `Test.@inferred`.\n\n\n\n\n\n","category":"macro"},{"location":"reference.html#Toolbox","page":"Reference","title":"Toolbox","text":"","category":"section"},{"location":"reference.html#Muscade.Toolbox.EulerBeam3D","page":"Reference","title":"Muscade.Toolbox.EulerBeam3D","text":"EulerBeam3D\n\nAn Euler beam element\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.Toolbox.Position3D-Union{Tuple{Any}, Tuple{Nsensor}} where Nsensor","page":"Reference","title":"Muscade.Toolbox.Position3D","text":"Position3D\n\nAn 3D single-node element, to be connected to a node with both translation and rotation dofs.  The element makes zero contribution to residual or Lagrangian.  It only provides requestables allowing to model accelerometers and optical position measurements. For an inverse analysis, this is done by including the element in  an ElementCost.\n\nKeyword arguments when adding elements:\n\nP SMatrix{3,Nsensor,𝕣}, giving the offset between the nodal position and the point(s)   at which position(s) and/or accelerations will be measured.\nD SMatrix{3,Nsensor,𝕣}, the orientation of an accelerometer. If no accelerometer is    present at a given postion P, use NaNs.  If multiple accelerometers are present   at the same position, one can repeat the columns of P.\n\nRequestables:\n\na a[isensor] is the \nx  x[oder+1][:,isensor] contains the position, velocity and acceleration (oder=0,1,2) of the sensor      which position was described in the isensor-th column of P. \nrᵢ rₑ[oder+1] is a vector containing a zero vector, the intrinsic rotation rate vector and its time derivative (oder=0,1,2), for the element's node.  \nrₑ rₑ[oder+1] is a vector containing the rotation vector, the extrinsic rotation rate vector and its time derivative (oder=0,1,2), for the element's node.  \nR R[oder+1] is a matrix containing the rotation matrix, spin matrix and its time derivative (oder=0,1,2), for the element's node.  \nxₙ x[oder+1] is a vector containing the position, velocity and acceleration (oder=0,1,2) of the element's node.\n\n#Keyword arguments when drawing elements:\n\nWhen calling draw!, instruction to Position3D elements are given as in this example:\n\ndraw!(axis,state>;Position3D=(L= @SVector [0.1,0,0],point_size=10,accelerometer_color=:orange))`\n\nThe opional keword arguments and their default values are    \n\nL                   = 0. (thus if not given, directions of accelerometers are not shown)\npoint_size          = 6\npoint_color         = :black\nstalk_color         = :grey\nstalk_width         = 1\naccelerometer_color = :teal\naccelerometer_width = 2\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.Toolbox.StrainGaugeOnEulerBeam3D","page":"Reference","title":"Muscade.Toolbox.StrainGaugeOnEulerBeam3D","text":"StrainGaugeOnEulerBeam3D\n\nAn element designed to wrap around an EulerBeam3D. The element makes no contribution  to residual or Lagrangian besides the contribution made by the element it wraps. StrainGaugeOnEulerBeam3D provides requestables allowing to model strain gauges. The strain gauges are placed halfway along the EulerBeam3D. In an inverse analysis, the StrainGaugeOnEulerBeam3D is itself wraped by an ElementCost element.\n\nKeyword arguments when adding elements:\n\nP SMatrix{3,Nsensor,𝕣}, giving the offset between the point on the axis of the   element halfway along its length. P[1,:] must be zero.\nD SMatrix{3,Nsensor,𝕣}, the orientation of a strain gauge. If multiple strain gauges   are present at the same position, one can repeat the columns of P.\nElementType=EulerBeam3D the constructor to the wrapped element.  This is typicaly  an EulerBeam3D but could be another element wrapping an EulerBeam3D.\nelementkwargs a NamedTuple with the keyword arguments to the wrapped element.  See EulerBeam3D   \n\nRequestables:\n\nεₐₓ (scalar), the axial strain at the middle of the element\nκ a vector with elements:        κ[1] the torsion at the middle of the element.       κ[2] the component of te curvature in EulerBeam3D's direction 2.       κ[3] the component of te curvature in EulerBeam3D's direction 3.   Although a tri-vector that includes torsion may erroneously suggest    a rotation rate vector, the κ[2:3] points to the inside of the curvature       and the unit is in 1/L (not rad/L) where L is the unit of length of   the model.\nε a vector of length Nsensor containing the strain values defined by P  and D.    \n\n#Keyword arguments when drawing elements:\n\nWhen calling draw!, instruction to StrainGaugeOnEulerBeam3D elements are given as in this example:\n\ndraw!(axis,state>;StrainGaugeOnEulerBeam3D=(L= @SVector [0.1,0,0],point_size=10,accelerometer_color=:orange))`\n\nThe optional keword arguments and their default values are  \n\ngauge_color = :blue\nexpand      = 1.02 a multiplicative factor applied to P in the drawing only (not in strain calculation)  to ensure the gauge is not hidden by a patch-drawing of the beam itself.\nL           = SVector{Nsensor,𝕣}(norm(P)/5 for i=1:Nsensor) the length of the strain gauge in the drawing  TODO\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.Toolbox.Rodrigues-Tuple{StaticArraysCore.SVector{3}}","page":"Reference","title":"Muscade.Toolbox.Rodrigues","text":"Rodrigues(v::SVector{3})\n\nTransform a rotation vector v into the rotation matrix M.\n\nSee also Toolbox.spin, Toolbox.spin⁻¹, Toolbox.Rodrigues⁻¹, Toolbox.adjust.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.Toolbox.Rodrigues⁻¹-Tuple{Any}","page":"Reference","title":"Muscade.Toolbox.Rodrigues⁻¹","text":"Rodrigues⁻¹(v::SVector{3})\n\nTransform a rotation matrix M into the rotation vector v, such that |v| < π. Undefined for rotations of angle π\n\nSee also Toolbox.spin, Toolbox.spin⁻¹, Toolbox.Rodrigues, Toolbox.adjust.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.Toolbox.adjust-Union{Tuple{R}, Tuple{StaticArraysCore.SVector{3, R}, StaticArraysCore.SVector{3, R}}} where R","page":"Reference","title":"Muscade.Toolbox.adjust","text":"adjust(u::SVector{3},v::SVector{3})\n\nCompute the matrix of the rotation with smallest angle that transforms u into a vector colinear with v.   Fails if |u|=0, |v|=0 or if the angle of the rotation is π.\n\nSee also Toolbox.spin, Toolbox.spin⁻¹, Toolbox.Rodrigues, Toolbox.Rodrigues⁻¹.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.Toolbox.intrinsicrotationrates-Union{Tuple{NTuple{ND, StaticArraysCore.SMatrix{3, 3}}}, Tuple{ND}} where ND","page":"Reference","title":"Muscade.Toolbox.intrinsicrotationrates","text":"intrinsicrotationrates(rₑ::NTuple{ND,SMatrix{3,3}}) where{ND}\n\nTransform a NTuple containing a rotation matrix and its extrinsic time derivatives, into a NTuple containing a (zero) rotation vector and its intrinsic time derivatives.\n\nSee also Toolbox.spin, Toolbox.spin⁻¹, Toolbox.Rodrigues, Toolbox.Rodrigues⁻¹.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.Toolbox.scac-Tuple{Any}","page":"Reference","title":"Muscade.Toolbox.scac","text":"scac(x)\n\nscac(x) = sinc1(acos(x)),  The function can be differentiated to the fourth order over ]-1,1] .\n\nSee also Toolbox.sinc1\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.Toolbox.sinc1-Tuple{Any}","page":"Reference","title":"Muscade.Toolbox.sinc1","text":"sinc1(x)\n\nsinc1(x) = sin(x)/x - but  sinc1(0.) = 1..  The function can be differentiated to the fourth order.\n\nThis differs from Julia's sinc(x) = sin(π*x)/(π*x).\n\nSee also Toolbox.scac\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.Toolbox.spin-Tuple{StaticArraysCore.SVector{3}}","page":"Reference","title":"Muscade.Toolbox.spin","text":"spin(v::SVector{3})\n\nTransform a rotation vector v into the cross product matrix M, such that M ∘₁ a = v × a.\n\nSee also Toolbox.spin⁻¹, Toolbox.Rodrigues, Toolbox.Rodrigues⁻¹.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.Toolbox.spin⁻¹-Tuple{StaticArraysCore.SMatrix{3, 3, R, 9} where R}","page":"Reference","title":"Muscade.Toolbox.spin⁻¹","text":"spin⁻¹(M::SMatrix{3,3})\n\nTransform a cross product matrix M into the rotation vector v, such that v × a = M ∘₁ a.\n\nSee also Toolbox.spin, Toolbox.Rodrigues, Toolbox.Rodrigues⁻¹.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.Toolbox.trace-Tuple{StaticArraysCore.SMatrix{3, 3, R, 9} where R}","page":"Reference","title":"Muscade.Toolbox.trace","text":"trace(v::SMatrix{3,3})\n\nComputes the trace of a matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.allocate_drawing-Union{Tuple{Udof}, Tuple{Tmat}, Tuple{Any, AbstractArray{EulerBeam3D{Tmat, Udof}, 1}}} where {Tmat, Udof}","page":"Reference","title":"Muscade.allocate_drawing","text":"Drawing a EulerBeam3D.\n\ndraw!(axis,state)\n\ndraw!(axis,state;EulerBeam3D=(;style=:shape))\n\nα      = 2π*(0:19)/20\ncircle = 0.1*[cos.(α) sin.(α)]'\ndraw!(axis,state;EulerBeam3D=(;style=:solid,section = circle))\n\nstyle=:shape shows the deformed neutral axis of the element. It has optional arguments frame=true  (draws the element's corotated frame of reference) and nseg=10 (number of points to show the deflected shape of each element). \n\nstyle=:solid shows the deformed shape of the element. It requires the input section=... to be given a matrix of size (2,nsec) describing nsec points around the cross section of the element (no need to close  the circumference by repeating the first point at the end).  It has optional arguments nseg=10 as above, marking=true to draw a longitudinal marking and solid_color=:yellow.\n\nOther optional arguments (and their default values) are\n\nUdof (true iff element has Udofs) wether to draw U-forces.\ndraw_frame = false wether to draw the local reference frame of each element\ndraw_marking = true wether to draw \"longitudinal marking\" along the element.  Will only draw if style=:solid.\nnseg = 1 number of segments to display the shape of a deformed element\nsolid_color = :yellow color of the surface if style=:solid\nline_color = :black color of the line if style=:sshape\nUscale = 1. How many meter is a Newton per meter?\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference.html","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"Diagnostic.html#Diagnostic","page":"Diagnostic","title":"Diagnostic","text":"","category":"section"},{"location":"Diagnostic.html","page":"Diagnostic","title":"Diagnostic","text":"The recommended approach is to always do things right the first time.  For those of us that have not yet adopted this wise strategy, Muscade.jl provides an ample supply of tools for diagnostic and testing.","category":"page"},{"location":"Diagnostic.html#Creating-models","page":"Diagnostic","title":"Creating models","text":"","category":"section"},{"location":"Diagnostic.html","page":"Diagnostic","title":"Diagnostic","text":"describe allows to study various aspects of the model being constructed.  It can also be used to display a State (for models of small size).","category":"page"},{"location":"Diagnostic.html","page":"Diagnostic","title":"Diagnostic","text":"Muscade.study_scale looks at the order of magnitudes of the gradient and Jacobian of a model, by doftype. This can help to chose an adequate scaleing.","category":"page"},{"location":"Diagnostic.html","page":"Diagnostic","title":"Diagnostic","text":"Muscade.study_singular looks for vectors than span the nullspace (aka. kernel) of the Hessian of the model.  Inother words, it looks for combinations of dofs which are undefined because there is neither a constraint or a cost associated to it.","category":"page"},{"location":"Diagnostic.html","page":"Diagnostic","title":"Diagnostic","text":"Muscade.Monitor and element that can be \"inserted between another element and the model, to monitor traffic to and from residual or lagrangian.","category":"page"},{"location":"Diagnostic.html#Testing-elements","page":"Diagnostic","title":"Testing elements","text":"","category":"section"},{"location":"Diagnostic.html","page":"Diagnostic","title":"Diagnostic","text":"When developing a new element, it is advisable to test the constructor, and residual or lagrangian in a direct call (outside of any Muscade solver), and examine the returned outputs.","category":"page"},{"location":"Diagnostic.html","page":"Diagnostic","title":"Diagnostic","text":"Muscade.diffed_residual and Muscade.diffed_lagrangian can be used to test the element's automatic differentiation. Generaly, automatic differentiation is unproblematic, but when advanced tools are used (e.g. revariate and compose), then the derivatives should be inspected.  ","category":"page"},{"location":"Diagnostic.html","page":"Diagnostic","title":"Diagnostic","text":"Muscade.@typeof allows to determine the type of the return variable of a function, as inferred by the compiler.  Usefull to study type stability.","category":"page"},{"location":"Diagnostic.html","page":"Diagnostic","title":"Diagnostic","text":"Muscade.print_element_array allows to display vectors of matrices, annotating them with the descriptionsof corresponding dofs.","category":"page"},{"location":"Diagnostic.html","page":"Diagnostic","title":"Diagnostic","text":"Muscade.SpyAxis allows to test calls to graphic generating functions in the element's Muscade.display_drawing! method.","category":"page"},{"location":"Diagnostic.html#Testing-solvers","page":"Diagnostic","title":"Testing solvers","text":"","category":"section"},{"location":"Diagnostic.html","page":"Diagnostic","title":"Diagnostic","text":"When developing a new solver, matrix sparsity structures are of interest.","category":"page"},{"location":"Diagnostic.html","page":"Diagnostic","title":"Diagnostic","text":"Muscade.plot_matrix_sparsity allows to plot the sparsity structure of a SparseMatrixCSC.","category":"page"},{"location":"Diagnostic.html","page":"Diagnostic","title":"Diagnostic","text":"Muscade.plot_block_matrix_sparsity allows to plot the sparsity structure of a \"matrix of matrices\".","category":"page"},{"location":"DecayAnalysis.html#Estimating-model-parameters","page":"Estimating model parameters","title":"Estimating model parameters","text":"","category":"section"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"We estimate the mass and damping matrices of a coupled linear oscillator (floater moving in the surge, sway and yaw) based on a decay tests In the following, we define the necessary element and residual function describing the dynamic behaviour of the floater.","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"using Muscade,StaticArrays,Interpolations,GLMakie\n\nfold(x::SVector{6}) = SMatrix{3,3}( x[1],x[2],x[3],\n                                    x[2],x[4],x[5],\n                                    x[3],x[5],x[6])\n\nconst floatermotion  = (:surge,:sway,:yaw)\nconst idx    = (:11,:12,:16,:22,:26,:66)\n\nstruct FloaterOnCalmWater <: AbstractElement\n    K   :: SMatrix{3,3,𝕣}\n    C   :: SMatrix{3,3,𝕣}\n    M   :: SMatrix{3,3,𝕣}\nend\nFloaterOnCalmWater(nod::Vector{Node};K,C,M  )  = FloaterOnCalmWater(K,C,M)\n\nMuscade.no_second_order(::Type{<:FloaterOnCalmWater}) = Val(true)\n\nMuscade.doflist(::Type{<:FloaterOnCalmWater}) = (inod  = (ntuple(i-> 1,3)...,ntuple(i-> 1,3)...,ntuple(i-> 1,6)...,                  ntuple(i-> 1,6)...           ),\n                                                 class = (ntuple(i->:X,3)...,ntuple(i->:U,3)...,ntuple(i->:A,6)...,                  ntuple(i->:A,6)...          ),\n                                                 field = (floatermotion...  ,floatermotion...  ,ntuple(i->Symbol(:M,idx[i]),6)...,   ntuple(i->Symbol(:C,idx[i]),6)...))\n\n@espy function Muscade.residual(o::FloaterOnCalmWater,   X,U,A,t,SP,dbg)\n    x,x′,x″    = ∂0(X),∂1(X),∂2(X)\n    ☼u         = ∂0(U)\n    a          = exp10.(A)\n    ☼r₂        = (o.M.*fold(a[@SVector [i for i∈1:6 ]]))∘₁x″\n    ☼r₁        = (o.C.*fold(a[@SVector [i for i∈7:12]]))∘₁x′\n    ☼r₀        = o.K∘₁x\n    return r₀+r₁+r₂-u,  noFB\nend","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"This is a tailor-made cost element where the cost is made dependent on the iteration number. In practice, this is used to first solve an XU problem (costs on A are prohibitive) before solving the actual XUA problem.","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"struct SingleDecayAcost{Field,Tcost,Tcostargs} <: AbstractElement\n    cost     :: Tcost\n    costargs :: Tcostargs\n    fac      :: 𝕣1\nend\n\nSingleDecayAcost(nod::Vector{Node};field::Symbol,fac,cost::Functor ,costargs=()) = SingleDecayAcost{field,typeof(cost),typeof(costargs)}(cost,costargs,fac)\nMuscade.doflist(::Type{<:SingleDecayAcost{Field,Tcost,Tcostargs}}) where{Field,Tcost,Tcostargs} = (inod=(1,),class=(:A,),field=(Field,))\n@espy function Muscade.lagrangian(o::SingleDecayAcost,Λ,X,U,A,t,SP,dbg)\n    iter  = min(length(o.fac),default{:iter}(SP,length(o.fac)))\n    ☼cost = o.cost(    A[1]  ,o.costargs...)\n    return cost*o.fac[iter],noFB\nend","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Define stiffness, damping and mass matrix for the true system","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"K         = fold(SVector{6}([1.0,    0.0,     0.0,     1.0,    0.0,     1.0]))\nC         = fold(SVector{6}([0.25,   -0.2,     0.1,     0.15,   -0.15,     0.03]))\nM         = fold(SVector{6}([1.0,    0.1,     0.2,     0.5,     0.1,     0.1]));\nnothing #hide","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Solve direct problem","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"model     = Model(:MooredFloater)\nn1        = addnode!(model,𝕣[0,0,0])\ne1        = addelement!(model,FloaterOnCalmWater,[n1]; K,C,M)\ninitialstate    = initialize!(model;time=0.)\ninitialstate    = setdof!(initialstate,[2.0];   field=:surge,   nodID=[n1], order=0)\ninitialstate    = setdof!(initialstate,[1.0];    field=:sway,    nodID=[n1], order=0)\ninitialstate    = setdof!(initialstate,[-5.0];  field=:yaw,     nodID=[n1], order=0)\nT               = 0.1 *(1:250)\nstate           = solve(SweepX{2};  initialstate,time= T,verbose=false);\nsurge   = [s.X[1][1] for s∈state]\nsway    = [s.X[1][2] for s∈state]\nyaw     = [s.X[1][3] for s∈state];\nnothing #hide","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Create fake measurements","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"surgeMeas = surge   + .05 * randn(length(T))\nswayMeas = sway     + .05 * randn(length(T))\nyawMeas = yaw       + .1 * randn(length(T));\nnothing #hide","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Create intial guesses for M and C","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Cguess         = fold(SVector{6}([0.1,   -0.1,     0.1,     0.1,   -0.1,     0.1]))\nMguess         = fold(SVector{6}([1.0,    1.0,     1.0,     1.0,    1.0,     1.0]));\nnothing #hide","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Create XUA model","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"modelXUA  = Model(:MooredFloater)\nn1        = addnode!(modelXUA,𝕣[0,0,0])\ne1        = addelement!(modelXUA,FloaterOnCalmWater,[n1]; K,C=Cguess,M=Mguess);\nnothing #hide","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Assign costs to unknown forces","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Quu       = @SVector [0.05 ^-2 for i=1:3 ]\n@functor with(Quu) cost1(u,t,i) = 0.5*Quu[i]*u^2\ne2        = [addelement!(modelXUA,SingleDofCost     ,[n1]; class=:U,field=f           ,    cost=cost1,costargs=(i,))  for (i,f)∈enumerate(floatermotion)];\nnothing #hide","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Assign costs to variations of model parameters (wrt guess).","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"fac       = [256,128,64,32,16,8,4,2,1]\nQCaa      = @SVector [.1 ^-2 for i=1:6 ]\n@functor with(QCaa,T) cost2(a,i) = 0.5*QCaa[i]/length(T)*a^2\ne3        = [addelement!(modelXUA,SingleDecayAcost  ,[n1];          field=f,fac,           cost=cost2,costargs=(i,)) for (i,f)∈enumerate((:C11,:C12,:C16,:C22,:C26,:C66))]\nQMaa      = @SVector [.1 ^-2 for i=1:6 ]\n@functor with(QMaa,T) cost3(a,i) = 0.5*QMaa[i]/length(T)*a^2\ne4        = [addelement!(modelXUA,SingleDecayAcost  ,[n1];          field=f,fac,           cost=cost3,costargs=(i,)) for (i,f)∈enumerate((:M11,:M12,:M16,:M22,:M26,:M66))];\nnothing #hide","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Assign costs to measurement errors","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"surgeInt    = linear_interpolation(T, surgeMeas)\nswayInt     = linear_interpolation(T, swayMeas)\nyawInt      = linear_interpolation(T, yawMeas)\n@functor with(surgeInt) devSurge(surge,t)     = 1e-1 ^-2 * (surge-surgeInt(t))^2\n@functor with(swayInt ) devSway(sway,t)       = 1e-1 ^-2 * (sway-swayInt(t))^2\n@functor with(yawInt  ) devYaw(yaw,t)         = 1e-1 ^-2 * (yaw-yawInt(t))^2\ne5             = addelement!(modelXUA,SingleDofCost,[n1];class=:X,field=:surge,    cost=devSurge)\ne6             = addelement!(modelXUA,SingleDofCost,[n1];class=:X,field=:sway,     cost=devSway)\ne7             = addelement!(modelXUA,SingleDofCost,[n1];class=:X,field=:yaw,      cost=devYaw);\n\n\n\n\n\n#Solve inverse problem\ninitialstateXUA    = initialize!(modelXUA;time=0.)\nstateXUA         = solve(DirectXUA{2,0,1};initialstate=[initialstateXUA],time=[T],\n                        maxiter=100,saveiter=true,\n                        maxΔx=1e-5,maxΔλ=Inf,maxΔu=1e-5,maxΔa=1e-5);\nnothing #hide","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Fetch and display estimated model parameters","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"lastIter = findlastassigned(stateXUA); niter = lastIter; iexp=1;\nMest      = Mguess .* fold(exp10.(SVector{6}(stateXUA[niter][iexp][1].A[1:6 ])))\nCest      = Cguess .* fold(exp10.(SVector{6}(stateXUA[niter][iexp][1].A[7:12])));\nnothing #hide","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Fetch response and loads","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"surgeRec    = [s.X[1][1] for s∈stateXUA[niter][iexp]]\nswayRec     = [s.X[1][2] for s∈stateXUA[niter][iexp]]\nyawRec      = [s.X[1][3] for s∈stateXUA[niter][iexp]]\nsurgeExtF   = [s.U[1][1] for s∈stateXUA[niter][iexp]]\nswayExtF    = [s.U[1][2] for s∈stateXUA[niter][iexp]]\nyawExtF     = [s.U[1][3] for s∈stateXUA[niter][iexp]]\nreq = @request r₂,r₁,r₀\nloads = getresult(stateXUA[niter][iexp],req,[e1])\ninertiaLoads = [loads[i][:r₂] for i∈1:length(T)]\ndampingLoads = [loads[i][:r₁] for i∈1:length(T)]\nstiffnessLoads = [loads[i][:r₀] for i∈1:length(T)];\nnothing #hide","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Create a figure with the results","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"fig      = Figure(size = (2000,1000));\nnothing #hide","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Display response","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"ax=Axis(fig[1,1], ylabel=\"Surge\", yminorgridvisible = true,xminorgridvisible = true)\nscatter!(fig[1,1],T,surgeMeas, color=RGBf(.8, .8, .8),        label=L\"\\text{Measurements}\")\nlines!(fig[1,1],T,surge,       color=:black, linestyle=:dash, label=L\"\\text{Exact direct solution } (M,C,K)\")\nlines!(fig[1,1],T,surgeRec,    color=:black,                  label=L\"\\text{Inverse solution } (\\hat{M},\\hat{C},K)\")\nylims!(ax,minimum(surgeMeas),maximum(surgeMeas))\nax.title=\"Displacements [m,deg]\"\naxislegend()\n\nax=Axis(fig[2,1], ylabel=\"Sway\", yminorgridvisible = true,xminorgridvisible = true)\nscatter!(fig[2,1],T,swayMeas,   color=RGBf(.8, .8, .8))\nlines!(fig[2,1],T,sway,         color=:black, linestyle=:dash)\nylims!(ax,-1,2)\nlines!(fig[2,1],T,swayRec,      color=:black)\nylims!(ax,minimum(swayMeas),maximum(swayMeas))\n\nax=Axis(fig[3,1], ylabel=\"Yaw\", yminorgridvisible = true,xminorgridvisible = true,xlabel=\"Time [s]\")\nscatter!(fig[3,1],T,yawMeas,    color=RGBf(.8, .8, .8))\nlines!(fig[3,1],T,yaw,          color=:black, linestyle=:dash)\nlines!(fig[3,1],T,yawRec,       color=:black)\nylims!(ax,minimum(yawMeas),maximum(yawMeas))","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"Display loads","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"ax=Axis(fig[1,2], yminorgridvisible = true,xminorgridvisible = true)\nlines!(fig[1,2],T,-[inertiaLoads[i][1] for i∈1:length(T)],  color=:red,     label=L\"\\text{Inertia } (\\hat{M})\")\nlines!(fig[1,2],T,-[dampingLoads[i][1] for i∈1:length(T)],  color=:blue,    label=L\"\\text{Damping } (\\hat{C})\")\nlines!(fig[1,2],T,-[stiffnessLoads[i][1] for i∈1:length(T)],color=:green,   label=L\"\\text{Stiffness } (K)\")\nlines!(fig[1,2],T,surgeExtF,                                color=:black,   label=L\"\\text{Unknown}\")\nax.title=\"Loads [N, Nm]\"\nylims!(ax,-2,2)\naxislegend()\n\nax=Axis(fig[2,2], yminorgridvisible = true,xminorgridvisible = true)\nlines!(fig[2,2],T,-[inertiaLoads[i][2] for i∈1:length(T)],      color=:red  )\nlines!(fig[2,2],T,-[dampingLoads[i][2] for i∈1:length(T)],      color=:blue )\nlines!(fig[2,2],T,-[stiffnessLoads[i][2] for i∈1:length(T)],    color=:green)\nlines!(fig[2,2],T,swayExtF,                                     color=:black)\nylims!(ax,-2,3)\n\nax=Axis(fig[3,2], yminorgridvisible = true,xminorgridvisible = true,xlabel=\"Time [s]\")\nlines!(fig[3,2],T,-[inertiaLoads[i][3] for i∈1:length(T)],      color=:red  )\nlines!(fig[3,2],T,-[dampingLoads[i][3] for i∈1:length(T)],      color=:blue)\nlines!(fig[3,2],T,-[stiffnessLoads[i][3] for i∈1:length(T)],    color=:green)\nlines!(fig[3,2],T,yawExtF,                                      color=:black)\nylims!(ax,-4,4)\n\nax=Axis(fig[1,3], limits=(nothing,nothing,0,2),\n    xticks = (1:6, [L\"\\hat{M}_{11}/M_{11}\", L\"\\hat{M}_{12}/M_{12}\", L\"\\hat{M}_{16}/M_{16}\",L\"\\hat{C}_{11}/C_{11}\", L\"\\hat{C}_{12}/C_{12}\", L\"\\hat{C}_{16}/C_{16}\"]),\n    yminorgridvisible = true,xminorgridvisible = true)\nbarplot!(ax,[1,2,3,4,5,6], [Mest[1,1]/M[1,1],Mest[1,2]/M[1,2],Mest[1,3]/M[1,3], Cest[1,1]/C[1,1],Cest[1,2]/C[1,2],Cest[1,3]/C[1,3]],\n    bar_labels = :y,color=:white,strokewidth=1,strokecolor=[:red,:red,:red,:blue,:blue,:blue])\nax.title=\"Estimated model parameters compared to exact solution (iteration \" * string(niter) * \"/\" * string(lastIter) * \")\"\n\nax=Axis(fig[2,3], limits=(nothing,nothing,0,2),\n    xticks = (1:6, [L\"\\hat{M}_{21}/M_{21}\", L\"\\hat{M}_{22}/M_{22}\", L\"\\hat{M}_{26}/M_{26}\",L\"\\hat{C}_{21}/C_{21}\", L\"\\hat{C}_{22}/C_{22}\", L\"\\hat{C}_{26}/C_{26}\"]),\n    yminorgridvisible = true,xminorgridvisible = true)\nbarplot!(ax,[1,2,3,4,5,6], [Mest[2,1]/M[2,1],Mest[2,2]/M[2,2],Mest[2,3]/M[2,3], Cest[2,1]/C[2,1],Cest[2,2]/C[2,2],Cest[2,3]/C[2,3]],\n    bar_labels = :y,color=:white,strokewidth=1,strokecolor=[:red,:red,:red,:blue,:blue,:blue])\n\nax=Axis(fig[3,3], limits=(nothing,nothing,0,2),\n    xticks = (1:6, [L\"\\hat{M}_{61}/M_{61}\", L\"\\hat{M}_{62}/M_{62}\", L\"\\hat{M}_{66}/M_{66}\",L\"\\hat{C}_{61}/C_{61}\", L\"\\hat{C}_{62}/C_{62}\", L\"\\hat{C}_{66}/C_{66}\"]),\n    yminorgridvisible = true,xminorgridvisible = true)\nbarplot!(ax,[1,2,3,4,5,6], [Mest[3,1]/M[3,1],Mest[3,2]/M[3,2],Mest[3,3]/M[3,3], Cest[3,1]/C[3,1],Cest[3,2]/C[3,2],Cest[3,3]/C[3,3]],\n    bar_labels = :y,color=:white,strokewidth=1,strokecolor=[:red,:red,:red,:blue,:blue,:blue])\n\ncurrentDir = @__DIR__\nif occursin(\"build\", currentDir)\n    save(normpath(joinpath(currentDir,\"..\",\"src\",\"assets\",\"decay.png\")),fig)\nelseif occursin(\"examples\", currentDir)\n    save(normpath(joinpath(currentDir,\"decay.png\")),fig)\nend","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"(Image: Result)","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"","category":"page"},{"location":"DecayAnalysis.html","page":"Estimating model parameters","title":"Estimating model parameters","text":"This page was generated using Literate.jl.","category":"page"},{"location":"LICENSE.html#MIT-License","page":"MIT License","title":"MIT License","text":"","category":"section"},{"location":"LICENSE.html","page":"MIT License","title":"MIT License","text":"Copyright (c) 2022-2025 SINTEF Ocean","category":"page"},{"location":"LICENSE.html","page":"MIT License","title":"MIT License","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"LICENSE.html","page":"MIT License","title":"MIT License","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"LICENSE.html","page":"MIT License","title":"MIT License","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"index.html#purpose","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html#FEM-optimization-problems","page":"Introduction","title":"FEM-optimization problems","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Muscade.jl is a Julia package for the description and solution of optimization problems constrained by the equilibrium of a finite element (FEM) model.  The mathematical problems solved by Muscade are defined by two components:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"A fairly classical FEM model (the constraints) - but with more degrees of freedom (refered to as \"dofs\" in the following) than usual: In Muscade, dofs are separated into three classes:\nX-dofs are the classical dofs of a finite element model. To each X-dofs corresponds one equilibrium equation of the FEM model (duality). \nU-dofs typicaly represent unknown external loads acting on the system, that vary with time.\nA-dofs typicaly represent unknown model parameters or design parameters that remain constant in time.\nA \"target\" function of the above dofs.  It can represent a cost to be minimized, or a probability to be maximized.  This function is necessary because the FEM model alone has more unknowns that it has equations (a form of ill-posedness).","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Muscade deals with static problems (FEM-equilibrium at a given time, and a target function that depends on the values of the dofs at that time), and dynamic problems (FEM-equilibrium at all time steps, and a target function that depends on the values, of derivatives, of the dofs at all time steps).","category":"page"},{"location":"index.html#Applications","page":"Introduction","title":"Applications","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"FEM-optimization problems include a variety of applications:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Load identification and monitoring: Given incomplete and noisy measurements of the response X of a system, what are the loads U that are most likely to have caused a response close to what has been measured?  The target function describes prior knowledge of the load processes, and the type, value and precision of the measurements. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(Image: iFEMsmall)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Conceptual representation of load identification and response monitoring. U-dof in red X-dof in magenta, measurement data in black and evaluated measurement in green. The figure is not a Muscade analysis output.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Model identification: Adjust the model parameters A of a system (model calibration, damage detection) given measurements on its response X when exposed to at least partly unknown (U) load. As in load identification problems, the target function describes prior knowledge of the load processes, and the measurements.  In addition, it expresses prior knowledge of the state of the structure. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(Image: Decaysmall)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"A small-scale physical model of an anchored vessel is \"kicked\" in an ocean laboratory, and the vessel's oscillations registrered. The graph shows the identification, using Muscade, of the system's non-linear added mass, damping and stiffness for surge (oscillation in forward direction). The actual analysis also captures the interaction with other degrees of freedom (sway and yaw). ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Design optimization: What is the cheapest way to engineer a system whose strength is described by A, that will survive a set of loading conditions?  The target function describes a financial cost.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(Image: SharedAnchor)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Static optimisation of a shared anchor system for a lattice of offshore wind turbines.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Reliability analysis: Finding a design point. What is the most probable combination of external loads U and strength of the structure A that may cause the response X to exceed, in one of many ways, an acceptable limit? Here the target function in the optimization problem describes the probability density (or rather, its logarithm) of unknown loads and strength parameters.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Optimal control: how to steer (U) a system with many dofs (X) to follow a target trajectory? The target function describes the cost of actuation and the cost of deviation from a target behaviour.","category":"page"},{"location":"index.html#Muscade-and-Lagrange-multipliers","page":"Introduction","title":"Muscade and Lagrange multipliers","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"There are two general approaches to constrained optimization problems.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The first is a change of variables to eliminate the constraints.  In FEM-optimization, the FEM model is used to express the response as a function of unknow loads and/or model parameters.  This in turn allows to reexpress the target function in terms of unknow loads and/or model parameters: we now have an unconstrained optimization problem. One advantage of this approach is that it can be implemented using existing FEM software: The FEM software  is evaluated repeatedly by an optimization algorithm (FEM in the loop).  Such an implementation is useful in many applications, but it does not scale well to large numbers of parameters to optimize.  For example, this is not a good solution to identify the load history that must have acted on a dynamic structure to cause the response that has been partialy measured. Further, it is not easily applicable to problems in which the FEM model alone is indetermined because what would otherwise be specified as initial or boundary conditions is to be determined from the measurement data (See the model identification example above, where initial conditions were not provided as input).","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The second approach to constrained optimization is to use Lagrange multipliers (also known in this context as adjoint state variables).  This approach requires dedicated solvers, and dedicated systems for the assembly of gradient vectors and Hessian matrices. Muscade provides such solvers (and more are to be added in the near future).  The \"Lagrange multiplier\"-approach also requires that elements provide partial derivatives and internal results to the solution algorithms, in a way that is not easily achievable within the architecture of existing FEM software. As a consequence, in Muscade, all element types required to model a given physical system need to be reimplemented, which is a serious drawback.  However, thanks to careful design of Muscade, as well as to the capabilities provided by the Julia programming language, implementing elements is significantly easier than it would be within a classical FE software. ","category":"page"},{"location":"index.html#Elements-in-Muscade","page":"Introduction","title":"Elements in Muscade","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Muscade provides an API to create new elements. While Muscade comes with a few elements built-in elements for generic tasks such as applying boundary conditions, the idea is to support users in developing their own element formulations and implementations.   ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Muscade inherently supports the developement of multiphysics model:  Elements can introduce new fields (new types of degrees of freedom: displacement, temperature, chemical species concentration, electric potential...). Elements that model the physics of a problem require the implementation of a function (Muscade.residual) that, given degrees of freedom, returns the element's contribution to the residual of the discretized equations to be solved, representing for example dynamic equilibrium. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Elements are also used to implement constraints, or, for example, measurements: given degrees of freedom, such an element returns the logarithm of the probability of this combination of degrees of freedom, given the measured data (Muscade.lagrangian).  See Implementing new elements for more details.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Muscade makes it easier to develop new element types by applying several techniques:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Automatic differentiation: elements describing a physical phenomena need only return the contribution of the element to the residual of the equations.  Elements describing a contribution to the target function do not need to provide gradient or Hessian. Automatic differentiation allows to efficiently compute the partial derivatives required by the solver without changes tot he element code","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Automatic extraction of element-results: \"Element-results\" are intermediate results evaluated in the process of computing contributions to the residual from degrees of freedom. An example is stresses and strains, in an element that given nodal displacements computes nodal forces. To make an element-result available, the only requirement is to prefix it with a ☼ (special character \\sun) in the code of Muscade.residual or Muscade.lagrangian.  For example: ☼σ = E*ε.  This automatic result extraction also makes it possible to describe measurements taken on element-results (for example a strain).","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Element constructor for modeling: Models in Muscade are created by writing Julia code that among other things, constructs new element instances.  Thanks to this, an element constructor is all that is required of the element programmer to make it available to the user that is modeling a physical system.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"info: Info\nMuscade.jl is under development: Functionality \nSolvers\nTesting \nDocumentation\nPerformanceare all work in progress, and APIs may still evolve.","category":"page"}]
}
