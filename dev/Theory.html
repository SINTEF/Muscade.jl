<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Theory · Muscade.jl</title><meta name="title" content="Theory · Muscade.jl"/><meta property="og:title" content="Theory · Muscade.jl"/><meta property="twitter:title" content="Theory · Muscade.jl"/><meta name="description" content="Documentation for Muscade.jl."/><meta property="og:description" content="Documentation for Muscade.jl."/><meta property="twitter:description" content="Documentation for Muscade.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Muscade.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="Theory.html">Theory</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Classes-of-degrees-of-freedom"><span>Classes of degrees of freedom</span></a></li><li><a class="tocitem" href="#Target-function"><span>Target function</span></a></li><li><a class="tocitem" href="#Constrained-optimization"><span>Constrained optimization</span></a></li><li><a class="tocitem" href="#Elements"><span>Elements</span></a></li><li><a class="tocitem" href="#Physical-and-optimisation-constraints"><span>Physical and optimisation constraints</span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><span class="tocitem">User manual</span><ul><li><a class="tocitem" href="Modelling.html">Creating a model</a></li><li><a class="tocitem" href="Solvers.html">Solvers</a></li><li><a class="tocitem" href="Elements.html">Implementing new elements</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="BeamElement.html">Euler beam element</a></li><li><a class="tocitem" href="StaticBeamAnalysis.html">Static analysis of a beam</a></li><li><a class="tocitem" href="DynamicBeamAnalysis.html">Modal analysis of a beam</a></li><li><a class="tocitem" href="DecayAnalysis.html">Estimating model parameters</a></li><li><a class="tocitem" href="DryFriction.html">DryFriction</a></li></ul></li><li><a class="tocitem" href="reference.html">Reference</a></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="TypeStable.html">Type-stability</a></li><li><a class="tocitem" href="Memory.html">Memory management</a></li><li><a class="tocitem" href="Adiff.html">Automatic differentiation</a></li><li><a class="tocitem" href="litterature.html">Literature</a></li></ul></li><li><a class="tocitem" href="LICENSE.html">MIT License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="Theory.html">Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Theory.html">Theory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SINTEF/Muscade.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SINTEF/Muscade.jl/blob/main/docs/src/Theory.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>This section presents the theory of how FEM-optimization problems are <em>defined</em> or formulated.  This is of interest both for the user of a <code>Muscade</code>-based application, and for someone implementing new elements to create such an application.</p><h2 id="Classes-of-degrees-of-freedom"><a class="docs-heading-anchor" href="#Classes-of-degrees-of-freedom">Classes of degrees of freedom</a><a id="Classes-of-degrees-of-freedom-1"></a><a class="docs-heading-anchor-permalink" href="#Classes-of-degrees-of-freedom" title="Permalink"></a></h2><p><code>Muscade</code> introduces 3 <em>classes</em> of degrees of freedom (dofs). </p><p><strong><span>$X$</span>-dofs</strong> are the dofs normaly encountered in normal &quot;forward&quot; FEM analysis.  They provide a discrete representation of the response of the system. There is a one-to-one relation (a &quot;duality&quot;) between the <span>$X$</span>-dofs and the <em>residuals</em> <span>$R$</span>, which are the discretized form of the differential equations we seek to solve. In forward FEM, we formulate a discreet problem of the form</p><p class="math-container">\[\forall t, R(X(t),t)=0\]</p><p><strong><span>$U$</span>-dofs</strong> are additional dofs that can be used to represent additional <em>unknown</em> loads on the system. Like <span>$X$</span>-dofs, <span>$U$</span>-dofs are time-dependent. Unlike <span>$X$</span>-dofs, there is no residual (no new equations) corresponding to them.</p><p><strong><span>$A$</span>-dofs</strong> are additional dofs that can be used to represent <em>unknown</em> model parameters. <span>$X$</span>-dofs are <em>not</em> time-dependent, and there are no residuals corresponing to them.</p><p>We now formulate the discrete finite element model of the form</p><p class="math-container">\[\forall t, R(X(t),U(t),A,t)=0\]</p><p>which is ill-posed (unknowns <span>$U$</span> and <span>$A$</span> have been added, but without adding any new equation).</p><p>To simplify the presentations in the following, we drop time <span>$t$</span> from the notations.  This can be interpreted in two ways:</p><ol><li>We are solving a problem at a single instant (static). </li><li>We are solving an evolution problem (dynamic).  <span>$X$</span>, <span>$U$</span> and <span>$R$</span> are now vectors-valued functions of time, and <span>$R=0$</span> denotes that the discretied differential equations must be verified at all times. </li></ol><h2 id="Target-function"><a class="docs-heading-anchor" href="#Target-function">Target function</a><a id="Target-function-1"></a><a class="docs-heading-anchor-permalink" href="#Target-function" title="Permalink"></a></h2><p>To make the problem well-posed again, we introduce a target function <span>$Q(X,U,A)$</span>.  We then seek to make <span>$Q$</span> stationary (finding a local minimum or maximum), under the constraint <span>$R(X,U,A)=0$</span>. Depending on the relevant application, the target function <span>$Q$</span> can represent different concepts.</p><h3 id="Target-function-as-financial-value"><a class="docs-heading-anchor" href="#Target-function-as-financial-value">Target function as financial value</a><a id="Target-function-as-financial-value-1"></a><a class="docs-heading-anchor-permalink" href="#Target-function-as-financial-value" title="Permalink"></a></h3><p>In design optimisation, one can associate a monetary value to <span>$A$</span> (building stronger costs more money), and to <span>$X$</span> (some system responses, including failure, would cost money). The objective is to find the design with the lowest total cost,- under the constraint that load and response verify equilibrium.</p><h3 id="Target-function-as-surprisal"><a class="docs-heading-anchor" href="#Target-function-as-surprisal">Target function as surprisal</a><a id="Target-function-as-surprisal-1"></a><a class="docs-heading-anchor-permalink" href="#Target-function-as-surprisal" title="Permalink"></a></h3><p>In a load estimation problem where part of the response is measured, we wish to find the most probable unknown load <span>$U$</span> (very large loads are not likely) and response (a computed response <span>$X$</span> that drasticaly disagrees with the actual measurements is not likely) - under the constraint that load and response verify equilibrium.  </p><p>In Muscade, this <em>must</em> be handled by minimizing the <em>surprisal</em> <span>$Q = -\log(P)$</span> instead of maximizing the probability density <span>$P$</span>. </p><ol><li><span>$Q$</span> and <span>$P$</span> have the same extrema, so finding a minimum of <span>$Q$</span> does give a maximum of <span>$P$</span>.  </li><li>The joint probability density of independant random variables is equal to the <em>product</em> of each variable&#39;s probability density. Because <span>$\log(ab)=\log(a)+\log(b)$</span>, the joint surprisal of independant random variables is equal to the <em>sum</em> of each variable&#39;s surprisal. In forward finite element analysis, the load vectors and incremental matrices of elements are <em>added</em> into a system vector and system matrix.  Muscade extends this logic: contributions to the Lagrangian from various elements are <em>added</em> together.</li><li>Generaly speaking, surprisals are numericaly better behaved than probability densities.  </li></ol><p>To illustrate the last point, consider a multinormal Gaussian probability density distribution and its surprisal:</p><p class="math-container">\[\begin{aligned}
P(X) &amp;= (2\pi)^{-k/2} \det(Σ)^{-1/2} \exp \left(-\frac{1}{2} \left( X-\mu \right)^T \cdot \Sigma^{-1} \cdot \left( X-\mu \right) \right) \\
Q(X) &amp;= -\log(P(X)) \\
     &amp;= k + \frac{1}{2} \left( X-\mu \right)^T \cdot Q_{XX} \cdot \left( X-\mu \right)
\end{aligned}\]</p><p>where <span>$k$</span> is a constant, whose value does not affect the extremal <span>$X$</span>, so <span>$k$</span> will be ignored in contributions to the target function. The constant matrix <span>$Q_{XX}$</span> is the inverse of the covariance matrix <span>$\Sigma$</span>. In this example, <span>$s$</span> is a quadratic function of <span>$X$</span>: its Hessian is constant and has value <span>$Q_{XX}$</span>.  A Newton-Rapshon algorithm solves the minimization of a quadratic function exactly, in one iteration.  Further, a Newton-Raphson algorithm solves the minimization of a quadratic function, constrained by linear constraints, exaclty, in one iteration.  By contrast, a Newton-Raphson algorithm applied to finding the zero of the derivative of a Gaussian distribution, is prone to diverge.</p><p>Hence, the code for an element defining a &quot;cost&quot; on a single dof <span>$X$</span>, measured to a value <span>$v(t)$</span> with a Gaussian measurement error of standard deviation <span>$\sigma$</span> would implemented the function </p><p class="math-container">\[Q(X,t) = \frac{1}{2} \frac{1}{\sigma^2} \left( X-v(t) \right)^2\]</p><h3 id="Contributions-to-the-target-function"><a class="docs-heading-anchor" href="#Contributions-to-the-target-function">Contributions to the target function</a><a id="Contributions-to-the-target-function-1"></a><a class="docs-heading-anchor-permalink" href="#Contributions-to-the-target-function" title="Permalink"></a></h3><p>In Muscade, additive contributions to the target function are called &quot;costs&quot;, although this is admitedly an inadequate name for an additive contribution to a surprisal. The costs are implemented as elements.  </p><p>One example of built-in element defining a cost is <a href="reference.html#Muscade.DofCost"><code>DofCost</code></a>, an element to add a cost which is a function of the value of a dof. Examples would include:</p><ul><li>A cost on a <span>$U$</span>-dof, a surprisal expressing prior knowledge of the magnitude of forces that may be explaining measured response.</li><li>A cost on a <span>$X$</span>-dof, a financial cost incured if a point in the model has a too high value, causing a failure.</li></ul><p>Another built-in element is <a href="reference.html#Muscade.ElementCost"><code>ElementCost</code></a>, an element to add a cost which is a function of an element-result. For example, a bar element can have &quot;axial strain&quot; as an internal value, that is, a value it computes that is neither a dof nor a residual. </p><h2 id="Constrained-optimization"><a class="docs-heading-anchor" href="#Constrained-optimization">Constrained optimization</a><a id="Constrained-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-optimization" title="Permalink"></a></h2><p>Making <span>$Q$</span> stationary under the equilibrium constraints <span>$R(X,U,A)=0$</span> is equivalent to finding a stationary point (a saddle point) of the <em>Lagrangian</em> <span>$L$</span></p><p class="math-container">\[L(\Lambda,X,U,A) = Q(X,U,A) + R(X,U,A) \cdot \Lambda\]</p><p>where <span>$Λ$</span> are <a href="https://en.wikipedia.org/wiki/Lagrange_multiplier">Lagrange multipliers</a> (also known as <em>adjoint state variables</em>).  </p><p>There is a one-to-one correspondance between Lagrange multipliers <span>$Λ$</span>dofs and residuals  <span>$R$</span>, and hence between <span>$Λ$</span>-dofs and <span>$X$</span>-dofs.  One result of this correspondance is that when implementing a new element, the method that must be provided <code>doflist</code> does not list the <span>$Λ$</span>-dofs (this would otherwise just have been a compulsory repetition of the list of <span>$X$</span>-dofs). </p><p>For evolution problems (involving a time-dependency), the dot product <span>$R(X,U,A) \cdot \Lambda$</span> includes an integral over time: the Lagrangian is a <em>functional</em>, and the gradients of <span>$L$</span> are ordinary differential equations in time, found using <a href="https://en.wikipedia.org/wiki/Functional_derivative">functional derivatives</a>.  </p><h2 id="Elements"><a class="docs-heading-anchor" href="#Elements">Elements</a><a id="Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Elements" title="Permalink"></a></h2><p>In the original finite element analysis, the <em>elements</em> in a model form a partition of a domain over which differential equations are to be solved. We will call these &quot;physical elements&quot;.  These elements provide additive contributions to the system of equations <span>$R(X,U,A)=0$</span>. Further contributions can come from external loads.</p><p>When doing optimization-FEM in <code>Muscade</code>, the elements provide additive contributions to the Lagrangian scalar <span>$L$</span>, instead of to the residual vector <span>$R$</span>. Actually when creating a new element in <code>Muscade</code> to create an application, one can either implement a contribution to <span>$R$</span> by implementing a method <code>Muscade.residual</code> for the element, or a contribution to <span>$L$</span> by implementing <code>Muscade.lagrangian</code>.  For performance, whenever possible (for example when implementing a physical element), prefer <code>Muscade.residual</code>. </p><h2 id="Physical-and-optimisation-constraints"><a class="docs-heading-anchor" href="#Physical-and-optimisation-constraints">Physical and optimisation constraints</a><a id="Physical-and-optimisation-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-and-optimisation-constraints" title="Permalink"></a></h2><p><strong>Physical constraints</strong> (including contact or Dirichlet/essential boundary conditions) are added to the model by using an element that adds adds a dof of class <span>$X$</span> to the model.  This new dof <span>$X_λ$</span> is a Lagrange multiplier for the constraint. If we note <span>$R$</span>, <span>$X$</span> and <span>$Λ$</span> the list of dofs before adding the constraint element and <span>$R^*$</span>, <span>$X^*$</span> and <span>$Λ^*$</span> after, then  </p><p class="math-container">\[L^*(\Lambda^*,X^*,U,A) = Q(X,U,A)  + R^*(X^*,U,A) \cdot Λ^* \]</p><p>with</p><p class="math-container">\[\begin{aligned}
Λ^* &amp;= [Λ,Λ_λ]\\
X^* &amp;= [X,X_λ]\\
R^*(X^*,U,A) &amp;= \left[R(X,U,A) - ∇g_x(X,U,A) \cdot X_λ \; , \; g_x(X,U,A)\right]
\end{aligned}\]</p><p><strong>Optimisation constraints</strong> allow to define that some situations are impossible, or inacceptable. For example, in a design optimisation analysis, excessive stresses would lead to failure, so would be constrained to remain under a given threshold. In a tracking or optimal control problem, an actuator force may not exceed some limit for the actuator&#39;s capacity.</p><p>Optimisation constraints that have to be verified at every step (for example stresses that must remain below a critical level, at any time) require a Lagrange multiplier that changes over time, and that is thus of class <span>$U$</span>. Optimisation constraints that act only on <span>$A$</span>-dofs (for example, there is a limit to the strength of steel we can order)  require a Lagrange multiplier of class <span>$A$</span>.  With optimisation constraints, the Lagrangian is of the form</p><p class="math-container">\[L^*(\Lambda,X,U^*,A^*) = Q^*(X,U^*,A^*)  + R(X,U,A) \cdot Λ \]</p><p>with</p><p class="math-container">\[\begin{aligned}
U^* &amp;= [U,U_λ]\\
A^* &amp;= [A,A_λ]\\
Q^*(X,U^*,A^*) &amp;= Q(X,U,A) +  g_u(X,U,A) \cdot U_\lambda + g_a(A) \cdot A_λ \\
\end{aligned}\]</p><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><p>For more details on the theory and examples of applications, see (<a href="litterature.html#maincon04a">Mainçon, 2004</a>), (<a href="litterature.html#maincon04b">Mainçon, 2004</a>), (<a href="litterature.html#maree04">Maree and Mainçon, 2004</a>), (<a href="litterature.html#barnardo04">Barnardo and Mainçon, 2004</a>), (<a href="litterature.html#hauser06">Hauser <em>et al.</em>, 2006</a>), (<a href="litterature.html#wu07">Wu and Larsen, 2007</a>), (<a href="litterature.html#maincon08">Mainçon <em>et al.</em>, 2008</a>), (<a href="litterature.html#hauser08">Hauser <em>et al.</em>, 2008</a>), (<a href="litterature.html#wu08">Wu <em>et al.</em>, 2008</a>), (<a href="litterature.html#wu09">Wu <em>et al.</em>, 2009</a>), (<a href="litterature.html#maincon13">Mainçon and Barnardo, 2013</a>). </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Introduction</a><a class="docs-footer-nextpage" href="Modelling.html">Creating a model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 8 August 2025 08:38">Friday 8 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
