<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Euler beam element ¬∑ Muscade.jl</title><meta name="title" content="Euler beam element ¬∑ Muscade.jl"/><meta property="og:title" content="Euler beam element ¬∑ Muscade.jl"/><meta property="twitter:title" content="Euler beam element ¬∑ Muscade.jl"/><meta name="description" content="Documentation for Muscade.jl."/><meta property="og:description" content="Documentation for Muscade.jl."/><meta property="twitter:description" content="Documentation for Muscade.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Muscade.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="Theory.html">Theory</a></li><li><span class="tocitem">User manual</span><ul><li><a class="tocitem" href="Modelling.html">Creating a model</a></li><li><a class="tocitem" href="Solvers.html">Solvers</a></li><li><a class="tocitem" href="Elements.html">Implementing new elements</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href="BeamElement.html">Euler beam element</a></li><li><a class="tocitem" href="StaticBeamAnalysis.html">Static analysis of a beam</a></li><li><a class="tocitem" href="DynamicBeamAnalysis.html">Modal analysis of a beam</a></li><li><a class="tocitem" href="DecayAnalysis.html">Estimating model parameters</a></li><li><a class="tocitem" href="DryFriction.html">DryFriction</a></li></ul></li><li><a class="tocitem" href="reference.html">Reference</a></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="TypeStable.html">Type-stability</a></li><li><a class="tocitem" href="Memory.html">Memory management</a></li><li><a class="tocitem" href="Adiff.html">Automatic differentiation</a></li><li><a class="tocitem" href="litterature.html">Literature</a></li></ul></li><li><a class="tocitem" href="LICENSE.html">MIT License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="BeamElement.html">Euler beam element</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="BeamElement.html">Euler beam element</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SINTEF/Muscade.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SINTEF/Muscade.jl/blob/main/examples/BeamElement.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><pre><code class="language-julia hljs">include(&quot;Rotations.jl&quot;)</code></pre><h1 id="Euler-beam-element"><a class="docs-heading-anchor" href="#Euler-beam-element">Euler beam element</a><a id="Euler-beam-element-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-beam-element" title="Permalink"></a></h1><pre><code class="language-julia hljs">using StaticArrays, LinearAlgebra, Muscade</code></pre><p>Data structure containing the cross section material properties</p><pre><code class="language-julia hljs">struct BeamCrossSection
    EA  :: ùï£  # axial stiffness
    EI‚ÇÇ :: ùï£ # bending stiffness about second axis
    EI‚ÇÉ :: ùï£ # bending stiffness about third axis
    GJ  :: ùï£ # torsional stiffness (about longitudinal axis)
    Œº   :: ùï£ # mass per unit length
    Œπ‚ÇÅ  :: ùï£ # (mass) moment of inertia for rotation about the element longitudinal axis per unit length
end
BeamCrossSection(;EA=EA,EI‚ÇÇ=EI‚ÇÇ,EI‚ÇÉ=EI‚ÇÉ,GJ=GJ,Œº=Œº,Œπ‚ÇÅ=Œπ‚ÇÅ) = BeamCrossSection(EA,EI‚ÇÇ,EI‚ÇÉ,GJ,Œº,Œπ‚ÇÅ);</code></pre><p>Resultant function that computes the internal loads from the strains and curvatures, and external loads on the element.</p><pre><code class="language-julia hljs">@espy function resultants(o::BeamCrossSection,Œµ,Œ∫,x·µß,r‚Çõ‚Çò,v·µ¢)
    r‚ÇÄ  = ‚àÇ0(r‚Çõ‚Çò)  # orientation of the element&#39;s local refsys
    v·µ¢‚ÇÅ = ‚àÇ1(v·µ¢)  # intrinsic rotation rate         of the element&#39;s local refsys
    v·µ¢‚ÇÇ = ‚àÇ2(v·µ¢)  # intrinsic rotation acceleration of the element&#39;s local refsys
    x·µß‚ÇÄ,x·µß‚ÇÅ,x·µß‚ÇÇ = ‚àÇ0(x·µß),‚àÇ1(x·µß),‚àÇ2(x·µß)
    x‚Çó‚ÇÅ          = x·µß‚ÇÅ ‚àò‚ÇÅ r‚ÇÄ
    x‚Çó‚ÇÇ          = x·µß‚ÇÇ ‚àò‚ÇÅ r‚ÇÄ
    # Compute drag force (example) and added-mass force (example)
    # fa = œÅ * Ca .* x‚Çó‚ÇÇ
    # fd = .5 * œÅ * A .* Cd .* x‚Çó‚ÇÅ #.* abs.(x‚Çó‚ÇÅ)
    # Compute translational inertia force
    fi = o.Œº * x·µß‚ÇÇ
    ‚òºf‚Çë = fi # external forces at Gauss point.
    # Compute roll inertia moment
    m‚ÇÅ‚Çó = o.Œπ‚ÇÅ*v·µ¢‚ÇÇ[1] #local
    m·µß = ‚àÇ0(r‚Çõ‚Çò)[:,1] * m‚ÇÅ‚Çó #global
    ‚òºm‚Çë = m·µß  # external couples at Gauss point.
    # Compute internal loads
    ‚òºf·µ¢ = o.EA*‚àÇ0(Œµ)
    # WARNING: curvatures are defined as rate of rotation along the element, not second derivatives of deflection.
    # Hence Œ∫[3]&gt;0 implies +2 direction is inside curve,
    #       Œ∫[2]&gt;0 implies -3 direction is inside curve.
    ‚òºm·µ¢  = SVector(o.GJ*‚àÇ0(Œ∫)[1],o.EI‚ÇÉ*‚àÇ0(Œ∫)[2],o.EI‚ÇÇ*‚àÇ0(Œ∫)[3])
    return f·µ¢,m·µ¢,f‚Çë,m‚Çë
end;

# Static Euler beam element, with two nodes, two Gauss points and 12 degrees of freedom.
const ngp        = 4
const ndim       = 3
const nXdof      = 12
const nUdof      = 3
const nXnod      = 2;</code></pre><p>Shape functions for a beam element with support Œ∂‚àà[-1/2,1/2]. Though the shape function matrices are sparse, do not &quot;unroll&quot; them.  That would be applyer but considerably clutter the code</p><pre><code class="language-julia hljs">y‚Çê(Œ∂) =            2Œ∂       # differential axial displacement or roll field
y·µ§(Œ∂) =  -4Œ∂^3    +3Œ∂       # deflection due to differential nodal transverse translation
y·µ•(Œ∂) =        Œ∂^2   - 1/4  # deflection due to differenttial rotation (bending, not torsion)
Œ∫‚Çê(Œ∂) =                2    # torsion  . Œ∫‚Çê = y‚Çê‚Ä≤ . Divide by L .
Œ∫·µ§(Œ∂) =  -24Œ∂               # curvature. Œ∫·µ§ = y·µ§‚Ä≤‚Ä≤. Divide by L¬≤.
Œ∫·µ•(Œ∂) =                2;   # curvature. Œ∫·µ• = y·µ•‚Ä≤‚Ä≤. Divide by L .</code></pre><p>Data structure describing an EulerBeam3D element as meshed</p><pre><code class="language-julia hljs">struct EulerBeam3D{Mat,Uforce} &lt;: AbstractElement
    c‚Çò       :: SVector{3,ùï£}     # Position of the middle of the element, as meshed
    r‚Çò       :: Mat33{ùï£}         # Orientation of the element, as meshed, represented by a rotation matrix (from global to local)
    Œ∂gp      :: SVector{ngp,ùï£}   # Location of the Gauss points for the normalized element with length 1
    Œ∂nod     :: SVector{nXnod,ùï£} # Location of the nodes for the normalized element with length 1
    tg‚Çò      :: SVector{ndim,ùï£}  # Vector connecting the nodes of the element in the global coordinate system
    tg‚Çë      :: SVector{ndim,ùï£}  # Vector connecting the nodes of the element in the local coordinate system
    y‚Çê       :: SVector{ngp,ùï£}   # Value at gp of shape function for differential axial displacement or roll field
    y·µ§       :: SVector{ngp,ùï£}   # Value at gp of shape function for deflection due to differential nodal transverse translation
    y·µ•       :: SVector{ngp,ùï£}   # Value at gp of shape function for deflection due to differenttial rotation (bending, not torsion)
    Œ∫‚Çê       :: SVector{ngp,ùï£}   # Value at gp of shape function for torsion  . Œ∫‚Çê = y‚Çê‚Ä≤ . Divided by L .
    Œ∫·µ§       :: SVector{ngp,ùï£}   # Value at gp of shape function for curvature. Œ∫·µ§ = y·µ§‚Ä≤‚Ä≤. Divided by L¬≤.
    Œ∫·µ•       :: SVector{ngp,ùï£}   # Value at gp of shape function for curvature. Œ∫·µ• = y·µ•‚Ä≤‚Ä≤. Divided by L .
    L        :: ùï£                # as meshed length of the element
    dL       :: SVector{ngp,ùï£}   # length associated to each Gauss point
    mat      :: Mat              # used to store material properties (BeamCrossSection, for example)
end;</code></pre><p>For performance, <code>residual</code> will only accept differentiation to first order</p><pre><code class="language-julia hljs">Muscade.nosecondorder(::Type{&lt;:EulerBeam3D}) = Val(true)</code></pre><p>Define nodes, classes, and field names of dofs</p><pre><code class="language-julia hljs">Muscade.doflist(     ::Type{EulerBeam3D{Mat,false}}) where{Mat} =
        (inod = (1,1,1,1,1,1, 2,2,2,2,2,2),
         #class= ntuple(i-&gt;:X,nXdof), # not typestable
         class= (:X,:X,:X,:X,:X,:X,:X,:X,:X,:X,:X,:X),
         field= (:t1,:t2,:t3,:r1,:r2,:r3, :t1,:t2,:t3,:r1,:r2,:r3) )
Muscade.doflist(     ::Type{EulerBeam3D{Mat,true}}) where{Mat} =
        (inod = (1,1,1,1,1,1, 2,2,2,2,2,2, 3,3,3),
         #class= (ntuple(i-&gt;:X,nXdof)...,ntuple(i-&gt;:U,nUdof)...),  # not typestable
         class= (:X,:X,:X,:X,:X,:X,:X,:X,:X,:X,:X,:X,:U,:U,:U),
         field= (:t1,:t2,:t3,:r1,:r2,:r3, :t1,:t2,:t3,:r1,:r2,:r3,  :t1,:t2,:t3) )</code></pre><p>ElementType for the EulerBeam3D element. Arguments: node list, material, and direction of the first bending axis in the global coordinate system.</p><pre><code class="language-julia hljs">EulerBeam3D(nod;kwargs...) = EulerBeam3D{false}(nod;kwargs...) # by default, EulerBeam3D does not have Udof.
function EulerBeam3D{Udof}(nod::Vector{Node};mat,orient2::SVector{ndim,ùï£}=SVector(0.,1.,0.)) where {Udof}
    c       = coord(nod)
    # Position of the middle of the element in the global coordinate system (as-meshed)
    c‚Çò      = SVector{ndim}((c[1]+c[2])/2)
    # Length and tangential vector to the element in the global coordinate system
    tg‚Çò     = SVector{ndim}( c[2]-c[1]   )
    L       = norm(tg‚Çò)
    t       = tg‚Çò/L
    # Create t, n, b which are the longitudinal and two transverse unit vectors to the element (as-meshed).
    # NB: orient2, provided by the user, will define the first bending axis.
    orient2/= norm(orient2)
    n       = orient2 - t*dot(orient2,t)
    nn      = norm(n)
    nn&gt;1e-3 || muscadeerror(&quot;Provide a &#39;orient&#39; input that is not nearly parallel to the element&quot;)
    n      /= nn
    b       = cross(t,n)
    r‚Çò      = SMatrix{ndim,ndim}(t...,n...,b...)
    # Tangential vector and node coordinates in the local coordinate system
    tg‚Çë     = SVector{ndim}(L,0,0)
    # Weight associated to each Gauss point
    dL    = SVector{ngp}(L/2*(18-sqrt(30))/36,L/2*(18+sqrt(30))/36  ,L/2*(18+sqrt(30))/36,L/2*(18-sqrt(30))/36  )
    # Location Œ∂gp of the Gauss points for a unit-length beam element, with nodes at Œ∂nod=¬±1/2.
    Œ∂gp     = SVector{ngp  }(-1/2*sqrt(3/7+2/7*sqrt(6/5)),-1/2*sqrt(3/7-2/7*sqrt(6/5)), +1/2*sqrt(3/7-2/7*sqrt(6/5)),+1/2*sqrt(3/7+2/7*sqrt(6/5)))
    Œ∂nod    = SVector{nXnod}(-1/2  ,1/2  )
    shapes  = (y‚Çê.(Œ∂gp), y·µ§.(Œ∂gp), y·µ•.(Œ∂gp)*L, Œ∫‚Çê.(Œ∂gp)/L, Œ∫·µ§.(Œ∂gp)/L^2, Œ∫·µ•.(Œ∂gp)/L)
    return EulerBeam3D{typeof(mat),Udof}(c‚Çò,r‚Çò,Œ∂gp,Œ∂nod,tg‚Çò,tg‚Çë,shapes...,L,dL,mat)
end;</code></pre><p>Define now the residual function for the EulerBeam3D element.</p><pre><code class="language-julia hljs">@espy function Muscade.residual(o::EulerBeam3D{Mat,Udof},   X,U,A,t,SP,dbg) where{Mat,Udof}
    P,ND                = constants(X),length(X)
    # Compute all quantities at Gauss point, their time derivatives, including intrinsic roll rate and acceleration
    gp_,Œµ_,v‚Çõ‚Çò_,r‚Çõ‚Çò_,v‚Çó‚ÇÇ_,_,_ = kinematics{:direct}(o,motion{P}(X))
    gpval,‚òºŒµ,‚òºr‚Çõ‚Çò        = motion‚Åª¬π{P,ND}(gp_,Œµ_,r‚Çõ‚Çò_)
    v·µ¢                  = intrinsicrotationrates(r‚Çõ‚Çò)
    # compute all Jacobians of the above quantities with respect to X‚ÇÄ
    X‚ÇÄ                  = ‚àÇ0(X) # returns concrete type
    TX‚ÇÄ                 = revariate{1}(X‚ÇÄ)  # returns ::Any
    Tgp,TŒµ,Tv‚Çõ‚Çò,_,_,_,_  = kinematics{:compose}(o,TX‚ÇÄ) # the crux
    gp‚àÇX‚ÇÄ,Œµ‚àÇX‚ÇÄ,v‚Çõ‚Çò‚àÇX‚ÇÄ    = composeJacobian{P}((Tgp,TŒµ,Tv‚Çõ‚Çò),X‚ÇÄ)
    # Quadrature loop: compute resultants
    gp                  = ntuple(ngp) do igp
        ‚òºx,‚òºŒ∫gp         = gpval[igp].x, gpval[igp].Œ∫
        x‚àÇX‚ÇÄ,Œ∫‚àÇX‚ÇÄ       = gp‚àÇX‚ÇÄ[igp].x, gp‚àÇX‚ÇÄ[igp].Œ∫
        f·µ¢,m·µ¢,f‚Çë,m‚Çë     = ‚òºresultants(o.mat,Œµ,Œ∫gp,x,r‚Çõ‚Çò,v·µ¢)          # call the &quot;resultant&quot; function to compute loads (local coordinates) from strains/curvatures/etc. using material properties. Note that output is dual of input.
        f‚Çë              = Udof ? f‚Çë-‚àÇ0(U) : f‚Çë                    # U is per unit length
        R_              = (f·µ¢ ‚àò‚ÇÄ Œµ‚àÇX‚ÇÄ + m·µ¢ ‚àò‚ÇÅ Œ∫‚àÇX‚ÇÄ + f‚Çë ‚àò‚ÇÅ x‚àÇX‚ÇÄ + m‚Çë ‚àò‚ÇÅ v‚Çõ‚Çò‚àÇX‚ÇÄ) * o.dL[igp]     # Contribution to the local nodal load of this Gauss point  [nXdof] = scalar*[nXdof] + [ndim]‚ãÖ[ndim,nXdof] + [ndim]‚ãÖ[ndim,nXdof]
        @named(R_)
    end
    R                   = sum(gp·µ¢.R_ for gp·µ¢‚ààgp)
    ‚ô¢Œ∫                  = motion‚Åª¬π{P,ND}(SVector(v‚Çó‚ÇÇ_[1],v‚Çó‚ÇÇ_[3],-v‚Çó‚ÇÇ_[2])).*(2/o.L)
    return R,noFB
end;

struct kinematics{Mode} end
function kinematics{Mode}(o::EulerBeam3D,X‚ÇÄ)  where{Mode}
    c‚Çò,r‚Çò,tg‚Çò,tg‚Çë,Œ∂nod,Œ∂gp,L  = o.c‚Çò,o.r‚Çò,o.tg‚Çò,o.tg‚Çë,o.Œ∂nod,o.Œ∂gp,o.L   # As-meshed element coordinates and describing tangential vector
    v‚Çõ‚Çò,r‚Çõ‚Çò,u‚Çó‚ÇÇ,v‚Çó‚ÇÇ,c‚Çõ‚Çò  = corotated{Mode}(o,X‚ÇÄ)
    Œµ                = ‚àö((u‚Çó‚ÇÇ[1]+L/2)^2+u‚Çó‚ÇÇ[2]^2+u‚Çó‚ÇÇ[3]^2)*2/L - 1.
    gp               = ntuple(ngp) do igp  # gp[igp].Œ∫, gp[igp].x
        y‚Çê,y·µ§,y·µ•,Œ∫‚Çê,Œ∫·µ§,Œ∫·µ• = o.y‚Çê[igp],o.y·µ§[igp],o.y·µ•[igp],o.Œ∫‚Çê[igp],o.Œ∫·µ§[igp],o.Œ∫·µ•[igp]
        Œ∫            = SVector(         Œ∫‚Çê*v‚Çó‚ÇÇ[1], Œ∫·µ§*u‚Çó‚ÇÇ[2]+Œ∫·µ•*v‚Çó‚ÇÇ[3], Œ∫·µ§*u‚Çó‚ÇÇ[3]-Œ∫·µ•*v‚Çó‚ÇÇ[2])
        y            = SVector(y‚Çê*u‚Çó‚ÇÇ[1]         , y·µ§*u‚Çó‚ÇÇ[2]+y·µ•*v‚Çó‚ÇÇ[3], y·µ§*u‚Çó‚ÇÇ[3]-y·µ•*v‚Çó‚ÇÇ[2])
        x            = r‚Çõ‚Çò‚àò‚ÇÅ(tg‚Çë*Œ∂gp[igp]+y)+c‚Çõ‚Çò
        (Œ∫=Œ∫,x=x)
    end
    return gp,Œµ,v‚Çõ‚Çò,r‚Çõ‚Çò,v‚Çó‚ÇÇ,u‚Çó‚ÇÇ,c‚Çõ‚Çò
end

vec3(v,ind) = SVector{3}(v[i] for i‚ààind);
struct corotated{Mode} end
function corotated{Mode}(o::EulerBeam3D,X‚ÇÄ)  where{Mode}
    c‚Çò,r‚Çò,tg‚Çò,tg‚Çë,Œ∂nod,Œ∂gp,L  = o.c‚Çò,o.r‚Çò,o.tg‚Çò,o.tg‚Çë,o.Œ∂nod,o.Œ∂gp,o.L   # As-meshed element coordinates and describing tangential vector
    u·µß‚ÇÅ,u·µß‚ÇÇ,v·µß                = vec3(X‚ÇÄ,1:3), vec3(X‚ÇÄ,7:9), SVector(X‚ÇÄ[4],X‚ÇÄ[5],X‚ÇÄ[6],X‚ÇÄ[10],X‚ÇÄ[11],X‚ÇÄ[12])
    Œîv·µß,r‚Çõ‚Çò,v‚Çõ‚Çò                = apply{Mode}(v·µß) do v
        v·µß‚ÇÅ,v·µß‚ÇÇ               = vec3(v,1:3), vec3(v,4:6)
        r‚Çõ‚ÇÅ                   = apply{Mode}(Rodrigues,v·µß‚ÇÅ)
        r‚Çõ‚ÇÇ                   = apply{Mode}(Rodrigues,v·µß‚ÇÇ)
        Œîv·µß_                 = 0.5*Rodrigues‚Åª¬π(r‚Çõ‚ÇÇ ‚àò‚ÇÅ r‚Çõ‚ÇÅ&#39;)
        r‚Çõ‚Çò_                  = apply{Mode}(Rodrigues,Œîv·µß_) ‚àò‚ÇÅ r‚Çõ‚ÇÅ ‚àò‚ÇÅ o.r‚Çò
        v‚Çõ‚Çò_                  = Rodrigues‚Åª¬π(r‚Çõ‚Çò_)
        return Œîv·µß_,r‚Çõ‚Çò_,v‚Çõ‚Çò_
    end
    c‚Çõ                        = 0.5*(u·µß‚ÇÅ+u·µß‚ÇÇ)
    u‚Çó‚ÇÇ                       = r‚Çõ‚Çò&#39; ‚àò‚ÇÅ (u·µß‚ÇÇ+tg‚Çò*Œ∂nod[2]-c‚Çõ)-tg‚Çë*Œ∂nod[2]    #Local displacement of node 2
    v‚Çó‚ÇÇ                       = r‚Çõ‚Çò&#39; ‚àò‚ÇÅ Œîv·µß
    return v‚Çõ‚Çò,r‚Çõ‚Çò,u‚Çó‚ÇÇ,v‚Çó‚ÇÇ,c‚Çõ+c‚Çò
end;</code></pre><p>The following functions explain how the beam element should be drawn</p><pre><code class="language-julia hljs">using GLMakie

function Muscade.allocate_drawing(axis,o::AbstractVector{EulerBeam3D{Tmat,Udof}};kwargs...) where{Tmat,Udof}
    args                 = default{:EulerBeam3D     }(kwargs,(;)     )
    section              = default{:section         }(args,zeros(2,0))
    nsec                 = size(section,2)
    opt = (default(args,(style=:shape,draw_frame=false,draw_marking=true,nseg=1,
                  solid_color=:yellow,line_color=:black,Uscale=1.,Udof=Udof))...,
            nel          = length(o)                                  ,
            nsec         = nsec                                       ,
            section      = section                                    ,
            markrad      = nsec==0 ? 0. : 1.01*maximum(section[1,:])
        )
    opt.style==:solid &amp;&amp; nsec&lt;2 &amp;&amp; muscadeerror(&quot;An section description must be provided for &#39;solid&#39; plot&quot;)
    nel_shape         = opt.style==:shape ? opt.nel   : 0
    nel_shape_frame   = opt.draw_frame    ? nel_shape : 0
    nel_solid         = opt.style==:solid ? opt.nel   : 0
    nel_solid_marking = opt.draw_marking  ? nel_solid : 0
    nel_udof          = opt.Udof          ? opt.nel   : 0

    mut=(
            node         = ùï£2(undef,3,3*opt.nel)                        ,
            shape_x      = ùï£2(undef,3,(opt.nseg+2)*nel_shape)           ,
            shape_frame  = ùï£2(undef,3,3*3*nel_shape_frame)              , # idim, point-point-lift, ivec, iel
            solid_vertex = ùï£2(undef,3,opt.nsec*(opt.nseg+1)*nel_solid)  ,
            solid_face   = ùï´2(undef,2*opt.nsec* opt.nseg   *nel_solid,3),
            solid_mark   = ùï£2(undef,3,(opt.nseg+2)*nel_solid_marking)   ,
            ucrest       = ùï£2(undef,3,5*nel_udof)                       , # idim, 6point-lift,iel
        )
    return mut,opt
end

function Muscade.update_drawing(axis,o::AbstractVector{EulerBeam3D{Tmat,Udof}},oldmut,opt, Œõ,X,U,A,t,SP,dbg) where{Tmat,Udof}
    mut               = oldmut
    X‚ÇÄ                = ‚àÇ0(X)
    U‚ÇÄ                = ‚àÇ0(U)
    it1,ir1,it2,ir2   = SVector{3}(1:3),SVector{3}(4:6),SVector{3}(7:9),SVector{3}(10:12)
    nsec              = size(opt.section,2)
    node = reshape(mut.node,(3,3,opt.nel))
    for (iel,o·µ¢) = enumerate(o)
        node[:,1,iel] = o·µ¢.c‚Çò - o·µ¢.tg‚Çò/2 + X‚ÇÄ[it1,iel]
        node[:,2,iel] = o·µ¢.c‚Çò + o·µ¢.tg‚Çò/2 + X‚ÇÄ[it2,iel]
        node[:,3,iel].= NaN
    end

    if opt.style==:shape
        Œ∂ = range(-1/2,1/2,opt.nseg+1)
        if opt.draw_frame shape_frame  = reshape(mut.shape_frame ,(3,3,3       ,opt.nel)) end
        if opt.Udof       ucrest       = reshape(mut.ucrest,      (3,5         ,opt.nel)) end
        shape_x                        = reshape(mut.shape_x     ,(3,opt.nseg+2,opt.nel))
        for (iel,o·µ¢) = enumerate(o)
            c‚Çò,r‚Çò,tg‚Çò,tg‚Çë,Œ∂nod,Œ∂gp,L  = o·µ¢.c‚Çò,o·µ¢.r‚Çò,o·µ¢.tg‚Çò,o·µ¢.tg‚Çë,o·µ¢.Œ∂nod,o·µ¢.Œ∂gp,o·µ¢.L
            X‚ÇÄ‚Çë = view(X‚ÇÄ,:,iel)
            v‚Çõ‚Çò,r‚Çõ‚Çò,u‚Çó‚ÇÇ,v‚Çó‚ÇÇ,c‚Çõ‚Çò = corotated{:direct}(o·µ¢,X‚ÇÄ‚Çë)
            if opt.draw_frame
                for ivec = 1:3
                    shape_frame[:,1,ivec,iel] = c‚Çõ‚Çò
                    shape_frame[:,2,ivec,iel] = c‚Çõ‚Çò + o·µ¢.L/3*r‚Çõ‚Çò[:,ivec]
                    shape_frame[:,3,ivec,iel].= NaN
                end
            end
            if opt.Udof
                ucrest[:,1,iel] = node[:,1,iel]
                ucrest[:,2,iel] = node[:,1,iel] + r‚Çõ‚Çò ‚àò‚ÇÅ view(U‚ÇÄ,:,iel) * opt.Uscale
                ucrest[:,3,iel] = node[:,2,iel] + r‚Çõ‚Çò ‚àò‚ÇÅ view(U‚ÇÄ,:,iel) * opt.Uscale
                ucrest[:,4,iel] = node[:,2,iel]
                ucrest[:,5,iel].= NaN
            end
            for (i,Œ∂·µ¢) ‚àà enumerate(Œ∂)
                y          = SVector(y‚Çê(Œ∂·µ¢)*u‚Çó‚ÇÇ[1] , y·µ§(Œ∂·µ¢)*u‚Çó‚ÇÇ[2]+L*y·µ•(Œ∂·µ¢)*v‚Çó‚ÇÇ[3], y·µ§(Œ∂·µ¢)*u‚Çó‚ÇÇ[3]-L*y·µ•(Œ∂·µ¢)*v‚Çó‚ÇÇ[2])
                shape_x[:,i         ,iel] = r‚Çõ‚Çò‚àò‚ÇÅ(tg‚Çë*Œ∂·µ¢+y)+c‚Çõ‚Çò
                shape_x[:,opt.nseg+2,iel].= NaN
            end
        end
    elseif opt.style==:solid
        Œ∂ = range(-1/2,1/2,opt.nseg+1)
        idx(iel,iseg,isec) = mod_onebased(isec,opt.nsec)+opt.nsec*(iseg-1+(opt.nseg+1)*(iel-1)) # 1st index into rvertex
        if opt.Udof         ucrest         = reshape(mut.ucrest       ,(3,5          ,opt.nel)) end
        if opt.draw_marking solid_mark     = reshape(mut.solid_mark  ,(3,opt.nseg+2 ,opt.nel)) end
        solid_face                         = reshape(mut.solid_face  ,(2,opt.nsec, opt.nseg   ,opt.nel,3))
        solid_vertex                       = reshape(mut.solid_vertex,(3,opt.nsec, opt.nseg+1 ,opt.nel))
        for (iel,o·µ¢) = enumerate(o)
            c‚Çò,r‚Çò,tg‚Çò,tg‚Çë,Œ∂nod,Œ∂gp,L  = o·µ¢.c‚Çò,o·µ¢.r‚Çò,o·µ¢.tg‚Çò,o·µ¢.tg‚Çë,o·µ¢.Œ∂nod,o·µ¢.Œ∂gp,o·µ¢.L
            X‚ÇÄ‚Çë = view(X‚ÇÄ,:,iel)
            v‚Çõ‚Çò,r‚Çõ‚Çò,u‚Çó‚ÇÇ,v‚Çó‚ÇÇ,c‚Çõ‚Çò = corotated{:direct}(o·µ¢,X‚ÇÄ‚Çë)
            v·µß‚ÇÅ,v·µß‚ÇÇ          = vec3(X‚ÇÄ‚Çë,4:6), vec3(X‚ÇÄ‚Çë,10:12)
            r‚Çõ‚ÇÅ              = Rodrigues(v·µß‚ÇÅ)
            r‚Çõ‚ÇÇ              = Rodrigues(v·µß‚ÇÇ)
            if opt.Udof
                ucrest[:,1,iel] = node[:,1,iel]
                ucrest[:,2,iel] = node[:,1,iel] + r‚Çõ‚Çò ‚àò‚ÇÅ view(U‚ÇÄ,:,iel) * opt.Uscale
                ucrest[:,3,iel] = node[:,2,iel] + r‚Çõ‚Çò ‚àò‚ÇÅ view(U‚ÇÄ,:,iel) * opt.Uscale
                ucrest[:,4,iel] = node[:,2,iel]
                ucrest[:,5,iel].= NaN
            end
            Œîv = Rodrigues‚Åª¬π(r‚Çõ‚ÇÇ ‚àò‚ÇÅ r‚Çõ‚ÇÅ&#39;)/opt.nseg
            for (iseg,Œ∂·µ¢) ‚àà enumerate(Œ∂) # actualy iterating over nseg+1 segment boundaries
                y  = SVector(y‚Çê(Œ∂·µ¢)*u‚Çó‚ÇÇ[1] , y·µ§(Œ∂·µ¢)*u‚Çó‚ÇÇ[2]+L*y·µ•(Œ∂·µ¢)*v‚Çó‚ÇÇ[3], y·µ§(Œ∂·µ¢)*u‚Çó‚ÇÇ[3]-L*y·µ•(Œ∂·µ¢)*v‚Çó‚ÇÇ[2])  # interpolate
                xn = r‚Çõ‚Çò‚àò‚ÇÅ(tg‚Çë*Œ∂·µ¢+y)+c‚Çõ‚Çò # point on neutral axis
                r  = Rodrigues((iseg-1)*Œîv) ‚àò‚ÇÅ r‚Çõ‚ÇÅ ‚àò‚ÇÅ r‚Çò
                if opt.draw_marking
                    solid_mark[:,    iseg  ,iel] = xn .+ r[:,2]*opt.markrad
                    solid_mark[:,opt.nseg+2,iel].= NaN
                end
                for isec = 1:opt.nsec
                    solid_vertex[:,isec,iseg,iel] = xn .+ r[:,2]*opt.section[1,isec] + r[:,3]*opt.section[2,isec]
                    if iseg‚â§opt.nseg
                        i1,i2,i3,i4 = idx(iel,iseg,isec),idx(iel,iseg  ,isec+1),idx(iel,iseg+1,isec  ),idx(iel,iseg+1,isec+1)
                        solid_face[1,isec,iseg,iel,:] = SVector(i1,i2,i4)
                        solid_face[2,isec,iseg,iel,:] = SVector(i1,i4,i3)
                    end
                end
            end
        end
    end
    return mut
end

function Muscade.display_drawing!(axis,::Type{EulerBeam3D{Tmat,Udof}},obs,opt) where{Tmat,Udof}
    scatter!(                                          axis, obs.node                         ,color = opt.line_color , marker=:circle,markersize=3)
    opt.style==:shape  &amp;&amp;                     lines!(  axis, obs.shape_x                      ,color = opt.line_color ,linewidth=.5                )
    opt.style==:shape  &amp;&amp; opt.draw_frame   &amp;&amp; lines!(  axis, obs.shape_frame                  ,color = :grey          ,linewidth=.5                )
    opt.style==:solid  &amp;&amp;                     mesh!(   axis, obs.solid_vertex, obs.solid_face ,color = opt.solid_color                             )
    opt.style==:solid  &amp;&amp; opt.draw_marking &amp;&amp; lines!(  axis, obs.solid_mark                   ,color = opt.line_color                              )
    opt.Udof           &amp;&amp;                     lines!(  axis, obs.ucrest                       ,color = :red           ,linewidth=.5                )
end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Elements.html">¬´ Implementing new elements</a><a class="docs-footer-nextpage" href="StaticBeamAnalysis.html">Static analysis of a beam ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 8 August 2025 08:38">Friday 8 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
