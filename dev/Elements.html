<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementing new elements · Muscade.jl</title><meta name="title" content="Implementing new elements · Muscade.jl"/><meta property="og:title" content="Implementing new elements · Muscade.jl"/><meta property="twitter:title" content="Implementing new elements · Muscade.jl"/><meta name="description" content="Documentation for Muscade.jl."/><meta property="og:description" content="Documentation for Muscade.jl."/><meta property="twitter:description" content="Documentation for Muscade.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Muscade.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="Theory.html">Theory</a></li><li><span class="tocitem">User manual</span><ul><li><a class="tocitem" href="Modelling.html">Creating a model</a></li><li><a class="tocitem" href="Solvers.html">Solvers</a></li><li class="is-active"><a class="tocitem" href="Elements.html">Implementing new elements</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#No-internal-variables"><span>No internal variables</span></a></li><li><a class="tocitem" href="#Sign-convention-in-elements"><span>Sign convention in elements</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li><li><a class="tocitem" href="#struct"><span>DataType</span></a></li><li><a class="tocitem" href="#constructor"><span>Constructor</span></a></li><li><a class="tocitem" href="#Method-for-Muscade.doflist"><span>Method for <code>Muscade.doflist</code></span></a></li><li><a class="tocitem" href="#Muscade.lagrangian-or-Muscade.residual"><span><code>Muscade.lagrangian</code> or <code>Muscade.residual</code></span></a></li><li><a class="tocitem" href="#Method-for-Muscade.draw"><span>Method for <code>Muscade.draw</code></span></a></li><li><a class="tocitem" href="#Help-functions"><span>Help functions</span></a></li><li><a class="tocitem" href="#Automatic-differentiation-within-element-code"><span>Automatic differentiation within element code</span></a></li><li><a class="tocitem" href="#Testing-elements"><span>Testing elements</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="StaticBeamAnalysis.html">Static analysis of a beam</a></li><li><a class="tocitem" href="DecayAnalysis.html">Estimating model parameters</a></li><li><a class="tocitem" href="DryFriction.html">DryFriction</a></li></ul></li><li><a class="tocitem" href="reference.html">Reference</a></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="TypeStable.html">Type-stability</a></li><li><a class="tocitem" href="Memory.html">Memory management</a></li><li><a class="tocitem" href="Adiff.html">Automatic differentiation</a></li><li><a class="tocitem" href="litterature.html">Literature</a></li></ul></li><li><a class="tocitem" href="LICENSE.html">MIT License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User manual</a></li><li class="is-active"><a href="Elements.html">Implementing new elements</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Elements.html">Implementing new elements</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SINTEF/Muscade.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SINTEF/Muscade.jl/blob/main/docs/src/Elements.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="implementelement"><a class="docs-heading-anchor" href="#implementelement">Implementing new elements</a><a id="implementelement-1"></a><a class="docs-heading-anchor-permalink" href="#implementelement" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>In <code>Muscade</code>, the broad view is taken that anything that contributes to the Lagrangian is an element.  This is a broader definition of &quot;elements&quot;, compared to classical <em>finite element</em> formulations, in which an element is an element of a partition of a domain over which differential equations are to be solved.  This more general definition of &quot;elements&quot; includes a variety of types:</p><ul><li>Physical element (or finite element), discretizing differential equations over a part of the domain</li><li>Known external loads on the boundary (non-essential boundary conditions)</li><li>Known external loads in the domain</li><li>Constrained dofs (essential boundary conditions)</li><li>Holonomic equality and inequality constraints (contact)</li><li>Optimisation constraints (e.g. stresses shal not exceed some limit at any point within part of the domain)</li><li>Response measurements (surprisal on <span>$X$</span>-dofs)</li><li>Unknown external loads (surprisal on <span>$U$</span>-dofs)</li><li>Observed damage (surprisal on <span>$A$</span>-dofs)</li><li>Cost of unfavorable response (cost on <span>$X$</span>-dofs)</li><li>Cost of actuators (cost on <span>$U$</span>-dofs)</li><li>Cost of building a system (cost on <span>$A$</span>-dofs)</li></ul><p>Because &quot;everything&quot; is an element in <code>Muscade</code>, app developers can express a wide range of ideas through <code>Muscade</code>&#39;s element API.</p><h2 id="No-internal-variables"><a class="docs-heading-anchor" href="#No-internal-variables">No internal variables</a><a id="No-internal-variables-1"></a><a class="docs-heading-anchor-permalink" href="#No-internal-variables" title="Permalink"></a></h2><p>In classical finite element formulations, plastic strain is implemented by letting an element have plastic strain and a hardening parameter as an <em>internal variable</em> at each quadrature point of the element.  Internal variables are not degrees of freedom.  Instead, they are a memory of the converged state of the element at the previous load or time step, used to affect the residual computed at the present time step.  Internal variables are also used when modeling friction and damage processes.</p><p><code>Muscade</code> does not allow elements to have internal variables. The reason is that problem involing dofs of class <code>U</code> are not causal: our estimation of the state of a system a step <code>i</code> also depends on on measurements taken at steps <code>j</code> with <code>j&gt;i</code>.  Hence &quot;sweep&quot; procedures, that is, procedures that solve a problem one load or time step at a time, are not applicable to such problems.  Solvers must hence solve for all dofs and steps at once.  When using Newton-Raphson iterations to solve problems of this class, internal variables make the Hessian matrix full: the value of a stress at a given stress depends (through the internal variable) on the strain at all preceeding steps. Or more formaly: Internal variables transforms the problem from <em>differential</em> to <em>integral</em>. A full matrix quickly leads to impossibly heavy computations.</p><p>To model phenomena usualy treated using internal variable, it is necessary in <code>Muscade</code> to make the &quot;internal&quot; variable into a degree of freedom, and describe the equation of evolution of this degree of freedom. See <a href="DecayAnalysis.html"><code>examples/DecayAnalysis.jl</code></a> for an example of implementation.  </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Because the equations of evolution involves first order time derivative, one can not use a static solver in combination with such elements.</p></div></div><h2 id="Sign-convention-in-elements"><a class="docs-heading-anchor" href="#Sign-convention-in-elements">Sign convention in elements</a><a id="Sign-convention-in-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Sign-convention-in-elements" title="Permalink"></a></h2><p>Starting with matrix methods in structural analysis, the traditional convention is that in an equation of the form</p><p class="math-container">\[K \cdot ΔX = R\\
X \leftarrow X + ΔX\]</p><p><span>$K$</span> is (typicaly) symmetric positive definite, <span>$ΔX$</span> are incremental nodal displacements, and <span>$R$</span> are <em>external</em> loads applied to the structure (a positive load tends to induce a positive displacement).  As a consequence, when an element is implemented within this convention, the element must return its stiffness <span>$K$</span> and its &quot;internal reaction forces&quot; <span>$R_i$</span>: a bar that is elongated reacts by pulling its ends inwards. The forces are &quot;el-on-nod&quot; (element on node).  <code>Muscade</code> uses the same convention for the <em>description of models</em>.  </p><p>However, the <em>implementation of elements</em> in <code>Muscade</code> uses another convention.  This is because <code>Muscade</code> optimizes a Lagrangian, relative to a set of variables here collectively denoted as <span>$Z$</span>.  A Newton step for seeking to make <span>$L(Z)$</span> stationary is naturaly written as</p><p class="math-container">\[G = \frac{\partial L}{\partial Z}\\
H = \frac{\partial G}{\partial Z}\\
H \cdot ΔZ = G\\
Z \leftarrow Z - ΔX\]</p><p>Note the minus sign on the last lign.  As a consequence of this minus sign, in <code>Muscade</code>, an element returns <span>$R_e=-R_i$</span>, and <span>$K$</span> is computed (by automatic differentiation, invisible to the element developer) as</p><p class="math-container">\[K = \frac{\partial R_e}{\partial X}\]</p><p>This implies that <span>$R_e$</span> are the &quot;external forces&quot;: to elongate a bar one must pull its ends outwards. The forces are &quot;nod-on-el&quot; (node on element).  This has one implication that may be surprising: an element that for example implements an (external) point load <span>$F$</span> must return <span>$R_e = -F$</span>, note the minus sign, so that the user of the element will interpret <span>$F$</span> as a classic external load.  The same applies to elements that connect unknown external loads <span>$U$</span> to the equilibrium equations.  Such an element must return <span>$R_e = -U$</span>.  Further, elements that return a Lagrangian (see below) must return <span>$L = Q + \Lambda \cdot R_e$</span>, note the plus sign.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><p>The implementation of a element requires </p><ul><li>A <strong><a href="Elements.html#struct"><code>DataType</code></a></strong> defining the element. </li><li>A <strong><a href="Elements.html#constructor">constructor</a></strong> which is called when the user adds an element to the model, and constructs the above <code>struct</code>.</li><li><strong><a href="reference.html#Muscade.doflist-Union{Tuple{Type{E}}, Tuple{E}} where E&lt;:AbstractElement"><code>Muscade.doflist</code></a></strong> specifies the degrees of freedom (dofs) of the element.</li><li><strong><a href="reference.html#Muscade.residual-Tuple{}"><code>Muscade.residual</code></a></strong> (either this of <a href="reference.html#Muscade.lagrangian-Tuple{}"><code>Muscade.lagrangian</code></a>) takes element dofs as input and returns the element&#39;s additive contribution to the residual of a non-linear system of equations,</li><li><strong><a href="reference.html#Muscade.lagrangian-Tuple{}"><code>Muscade.lagrangian</code></a></strong> (either this of <a href="reference.html#Muscade.residual-Tuple{}"><code>Muscade.residual</code></a>) takes element dofs as input and returns the element&#39;s additive contribution to a target function,</li><li><strong><a href="reference.html#Muscade.draw-Tuple{Any, AbstractElement, Vararg{Any}}"><code>Muscade.draw</code></a></strong> (optional) which draws all the elements of the same element type.</li></ul><p>Each element must implement <em>either</em> <a href="reference.html#Muscade.lagrangian-Tuple{}"><code>Muscade.lagrangian</code></a> <em>or</em> <a href="reference.html#Muscade.residual-Tuple{}"><code>Muscade.residual</code></a>, depending on what is more natural: a beam element will implement <a href="reference.html#Muscade.residual-Tuple{}"><code>Muscade.residual</code></a> (element reaction forces as a function of nodal displacements), while an element representing a strain sensor will implement <a href="reference.html#Muscade.lagrangian-Tuple{}"><code>Muscade.lagrangian</code></a> (log-of the probability density of the strain, given an uncertain measurement).</p><h2 id="struct"><a class="docs-heading-anchor" href="#struct">DataType</a><a id="struct-1"></a><a class="docs-heading-anchor-permalink" href="#struct" title="Permalink"></a></h2><p>For a new element type <code>MyELement</code>, the datatype is defined as</p><pre><code class="language-julia hljs">struct MyElement &lt;: AbstractElement
    ...
end</code></pre><p><code>MyElement</code> <em>must</em> be declared a subtype of <a href="reference.html#Muscade.AbstractElement"><code>AbstractElement</code></a>.</p><h2 id="constructor"><a class="docs-heading-anchor" href="#constructor">Constructor</a><a id="constructor-1"></a><a class="docs-heading-anchor-permalink" href="#constructor" title="Permalink"></a></h2><p>The element must provide a constructor of the form</p><pre><code class="language-julia hljs">function MyElement(nod::Vector{Node};kwargs...)
    ...
    return eleobj
end</code></pre><p>which will then call the default constructor provided by Julia.  </p><p><code>nod</code> can be used to access the coordinates of the nodes directly:</p><pre><code class="language-julia hljs">x = nod[inod].coord[icoord]</code></pre><p>where <code>inod</code> is the element-node number and <code>icoord</code> the index into a vector of coordinates. <code>coord</code> is  provided by the user when adding a <code>Node</code> to the <code>Model</code>. <code>Muscade</code> has no opinion about, and provides no check of, the length of <code>coord</code> provided by the user. In this way elements can define what coordinate system (how many coordinates, and their interpretation) is to be used.  Coordinate systems can even differ from one node to the next. See also the helper function <a href="reference.html#Muscade.coord-Tuple{AbstractVector{Node}}"><code>coord</code></a> to get all node coordinates.</p><p><code>kwargs...</code> is any number of named arguments, typicaly defining the material properties of the element.</p><p>The user does not call the above-defined constructor directly.  Instead, an element is added to the model by a call of the form</p><pre><code class="language-julia hljs">e1 = addelement!(model,MyElement,nodid,kwargs...)</code></pre><p>See <a href="reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, AbstractMatrix{Muscade.NodID}}} where T&lt;:AbstractElement"><code>addelement!</code></a>.</p><h2 id="Method-for-Muscade.doflist"><a class="docs-heading-anchor" href="#Method-for-Muscade.doflist">Method for <code>Muscade.doflist</code></a><a id="Method-for-Muscade.doflist-1"></a><a class="docs-heading-anchor-permalink" href="#Method-for-Muscade.doflist" title="Permalink"></a></h2><p>The element must provide a method of the form</p><pre><code class="language-julia hljs">function Muscade.doflist(::Type{MyElement})
    return (inod =(...),
            class=(...),
            field=(...))
end</code></pre><p>The syntax <code>::Type{MyElement}</code> is because <code>Muscade.doflist</code> will be called by <code>Muscade</code> with <em>a <code>DataType</code></em>  (the type <code>MyElement</code>), not with an object <em>of type</em> <code>MyELement</code> . The function name must begin with <code>Muscade.</code> to make it possible to overload a function defined in the module <code>Muscade</code>. </p><p>The return value of the function is a <code>NamedTuple</code> with the fields <code>inod</code>, <code>class</code> and <code>field</code>. </p><ul><li><code>inod</code>  is a <code>NTuple</code> of <code>Int64</code>: for each dof, its element-node number. </li><li><code>class</code> is a <code>NTuple</code> of <code>Symbol</code>: for each dof, its class (must be <code>:X</code>, <code>:U</code> or <code>:A</code>).</li><li><code>field</code> is a <code>NTuple</code> of <code>Symbol</code>: for each dof, its field.</li></ul><p>Importantly, <code>Muscade.doflist</code> does not mention dofs of class <code>:Λ</code>: if the element implements <code>Muscade.lagrangian</code>, there is automaticaly a one-to-one correspondance between <span>$Λ$</span>-dofs and <span>$X$</span>-dofs.</p><p>For example (using Julia&#39;s syntax for one-liner functions):</p><pre><code class="language-julia hljs">Muscade.doflist( ::Type{Turbine}) = (inod =(1   ,1   ,2        ,2        ),
                                     class=(:X  ,:X  ,:A       ,:A       ),
                                     field=(:tx1,:tx2,:Δseadrag,:Δskydrag))</code></pre><p>See <a href="reference.html#Muscade.doflist-Union{Tuple{Type{E}}, Tuple{E}} where E&lt;:AbstractElement"><code>Muscade.doflist</code></a>.</p><h2 id="Muscade.lagrangian-or-Muscade.residual"><a class="docs-heading-anchor" href="#Muscade.lagrangian-or-Muscade.residual"><code>Muscade.lagrangian</code> or <code>Muscade.residual</code></a><a id="Muscade.lagrangian-or-Muscade.residual-1"></a><a class="docs-heading-anchor-permalink" href="#Muscade.lagrangian-or-Muscade.residual" title="Permalink"></a></h2><p>An element must implement at least one of <code>Muscade.lagrangian</code> or <code>Muscade.residual</code>.</p><h3 id="Method-for-Muscade.lagrangian"><a class="docs-heading-anchor" href="#Method-for-Muscade.lagrangian">Method for <code>Muscade.lagrangian</code></a><a id="Method-for-Muscade.lagrangian-1"></a><a class="docs-heading-anchor-permalink" href="#Method-for-Muscade.lagrangian" title="Permalink"></a></h3><p>Elements that implement a contribution to a target function must implement <code>Muscade.lagrangian</code>.</p><pre><code class="language-julia hljs">@espy function Muscade.lagrangian(o::MyElement,Λ,X,U,A,t,SP,dbg) 
    ...
    return L,noFB
end</code></pre><p>See <a href="reference.html#Muscade.lagrangian-Tuple{}"><code>Muscade.lagrangian</code></a> for the list of arguments and outputs.</p><h3 id="Method-for-Muscade.residual"><a class="docs-heading-anchor" href="#Method-for-Muscade.residual">Method for <code>Muscade.residual</code></a><a id="Method-for-Muscade.residual-1"></a><a class="docs-heading-anchor-permalink" href="#Method-for-Muscade.residual" title="Permalink"></a></h3><p>Elements that implement &quot;physics&quot; will typicaly implement <code>Muscade.residual</code> (they could implement the same using <code>lagrangian</code>, but the resulting code would be less performant).</p><p>The interface is mostly the same as for <code>Muscade.lagrangian</code> with the differences that</p><ul><li><code>Muscade.residual</code> returns a vector <code>R</code></li><li>there is no argument <code>Λ</code></li></ul><pre><code class="language-julia hljs">@espy function Muscade.residual(o::MyElement,X,U,A,t,SP,dbg) 
    ...
    return R,noFB
end</code></pre><p>See <a href="reference.html#Muscade.residual-Tuple{}"><code>Muscade.residual</code></a> for the list of arguments and outputs.</p><h3 id="Automatic-differentiation"><a class="docs-heading-anchor" href="#Automatic-differentiation">Automatic differentiation</a><a id="Automatic-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-differentiation" title="Permalink"></a></h3><p>The gradients and Hessians of <code>R</code> or <code>L</code> do not need to be implemented, because <code>Muscade</code> uses <a href="Adiff.html">automatic differentiation</a>. Because of this, it is important not to over-specify the inputs.  For example,  implementing a function header with</p><pre><code class="language-julia hljs">@espy function Muscade.lagrangian(o::MyElement,Λ::Vector{Float64},X,U,A,t,SP,dbg)
#                                                |___bad_idea___|</code></pre><p>would cause a <code>MethodError</code>, because <code>Muscade</code> will attempt to call with a <code>SVector</code> instead of <code>Vector</code>, and a special datatype supporting automatic differentiation instead of <code>Float64</code>.</p><h3 id="espy"><a class="docs-heading-anchor" href="#espy">Extraction of element-results</a><a id="espy-1"></a><a class="docs-heading-anchor-permalink" href="#espy" title="Permalink"></a></h3><p>The function definitions of <code>Muscade.lagrangian</code> and <code>Muscade.residual</code> must be anotated with the macro call <code>@espy</code>.   Variables within the body of <code>Muscade.lagrangian</code> and <code>Muscade.residual</code>, which the user may want to obtain must be anotated with <code>☼</code> (by typing <code>\sun</code> they pressing <code>TAB</code>) at the place where they are calculated. An example would be </p><pre><code class="language-julia hljs">    ☼σ = E*ε</code></pre><p>The macro will generate two versions of <code>Muscade.lagrangian</code> and/or <code>Muscade.residual</code>.  One in which the anotations  <code>☼</code> are taken away, which is used to solve the numerical problem.  Another with additional input and output variables, and code inserted into the body of the function to extract results wanted by the user.</p><p>See <a href="reference.html#Muscade.@espy-Tuple{Any}"><code>Muscade.@espy</code></a> for a complete guide on code anotations. </p><h3 id="Immutables-and-Gauss-quadrature"><a class="docs-heading-anchor" href="#Immutables-and-Gauss-quadrature">Immutables and Gauss quadrature</a><a id="Immutables-and-Gauss-quadrature-1"></a><a class="docs-heading-anchor-permalink" href="#Immutables-and-Gauss-quadrature" title="Permalink"></a></h3><p><code>Muscade.residual</code> and <code>Muscade.lagrangian</code> must be written in a specific style in order maximize performance and to facilitate automatic differentiation. </p><p>For performance, no allocation on the heap must occur.  This implies in particular that no <code>Array</code>s, and only  (stack allocated) <code>StaticArray</code>s must be used.  For example. the code <code>a=zeros(n)</code>, creates an <code>Array</code>  (allocated on the heap), and should be replaced with <code>a = SVector{N}(0. for i=1:N)</code> where <code>N</code> must be known  at compile time to ensure type stability.</p><p>To facilitate automatic differentiation, no mutation must occur. <code>StaticArray</code>s are anyway not mutable.</p><p>One difficulty arises with Gauss quadrature.  Typical implementations would rely on setting <code>R</code> to zero, then adding the  contributions from quadrature points to <code>R</code> within a <code>for</code> loop over the Gauss points, which is a mutation.   The pseudo code:</p><pre><code class="language-julia hljs">R .= 0
for igp = 1:ngp
    F  = ...
    Σ  = ...
    R += F ∘₁ Σ ∘₁ ∇N * dV
end</code></pre><p>shows that <code>R</code> is mutated. For the extraction of results from a loop, the following pattern <strong>must</strong> be used:</p><pre><code class="language-julia hljs">@espy function Muscade.residual(x,χ)
    t = ntuple(ngp) do igp
        ☼F = ...
        ☼Σ = ...
        r  = F ∘₁ Σ ∘₁ ∇N * dV
        @named(r)
    end
    R = sum(   igp-&gt;t[igp].r,ngp)
    return R,...
end</code></pre><p><code>r</code> are the contributions to <code>R</code> at each quadrature point.  The operation <code>t = ntuple ...</code> returns a datastructure <code>t</code> such that  `<code>t[igp].r</code> are the contribution to the residual from the <code>igp</code>-th quadrature point. This is because</p><pre><code class="language-julia hljs">    t = ntuple(ngp) do igp
        expr(igp)
    end    </code></pre><p>is equivalent to </p><pre><code class="language-julia hljs">    t = ntuple(expr for igp=1:ngp)</code></pre><p>which returns</p><pre><code class="language-julia hljs">    t = (expr(1),expr(2),...,expr(ngp))</code></pre><p>where the value of <code>expr</code> is that of its last line <code>@named(r,a,b,c)</code> which is a macro provided by <code>Muscade</code> that inserts the code <code>(r=r,a=a,b=b,c=c)</code>.</p><p>The code </p><pre><code class="language-julia hljs">    a = ntuple(igp-&gt;t[igp].a,ngp)
    R = sum(   igp-&gt;t[igp].r,ngp)</code></pre><p>gathers the hypothetic <code>a</code> of all quadrature points into a <code>Tuple</code> and adds together the contributions <code>r</code> into the residual <code>R</code>.  Variables behaving like <code>a</code> <em>might</em> come into play if solver feedback is provided from each Gauss point.</p><p>The macro <code>@named</code> is peculiar in that neither Julia nor <code>Muscade</code> defines a <code>macro named</code>.  Instead, it is a syntactic token identified and transformed by <code>@espy</code>.  This has one important implication: if the loop over the Gauss points only accumulates <code>R</code> (or <code>L</code>, in <code>Muscade.lagrangian</code>), it would be tempting to use a simpler pattern:</p><pre><code class="language-julia hljs">@espy function Muscade.residual(x,χ)
    R = sum(1:ngp) do igp
        ☼F = ...
        ☼Σ = ...
        F ∘₁ Σ ∘₁ ∇N * dV
    end
    return R,...
end</code></pre><p>However, result extraction from inside the loop will not work: <code>@espy</code> only supports &quot;<code>ntuple...do...@named</code> for the purpose.</p><p>See <a href="reference.html#Muscade.residual-Tuple{}"><code>Muscade.residual</code></a>, <a href="reference.html#Muscade.lagrangian-Tuple{}"><code>Muscade.lagrangian</code></a>.</p><h3 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h3><p>For a given element formulation, the performance of <code>Muscade.residual</code> and <code>Muscade.lagrangian</code> can vary with a factor up to 100 between a good and a bad implementation.</p><p><strong>Type stable code</strong> allows the compiler to know the type of every variable in a function given the type of its parameters. Code that is type unstable is significantly slower. See the page on <a href="TypeStable.html">type stability</a>.</p><p><strong>Allocation</strong>, and the corresponding deallocation of memory <em>on the heap</em> takes time. By contrast, allocation and deallocation <em>on the stack</em> is fast.  In Julia, only immutable variables can be allocated on the stack. See the page on <a href="Memory.html">memory management</a></p><p><strong>Automatic differentiation</strong> generaly does not affect how <code>Muscade.residual</code> and <code>Muscade.lagrangian</code> are written.  There are two performance-related exceptions to this:</p><ol><li>If a complicated sub-function in <code>Muscade.residual</code> and <code>Muscade.lagrangian</code> (typicaly a material model or other closure) operates on an array (for example, the strain) that is smaller than the number of degrees of freedom of the system, computing time can be saved by computing the derivative of the output (in the example, the stress) with respect to the input to the subfunction, and then compose the derivatives.</li><li>Iterative precedures are sometimes used within <code>Muscade.residual</code> and <code>Muscade.lagrangian</code>, a typical example being in plastic material formulations.  There is no need to propagate automatic differentiation through all the iterations - doing so with the result of the iteration provides the same result.</li><li>Elements with corotated reference system (e.g. <a href="StaticBeamAnalysis.html">beam elements</a>) can use automatic differentiation to transform the residual back to the global reference system.</li></ol><p>See the page on <a href="Adiff.html">automatic differentiation</a>.</p><h2 id="Method-for-Muscade.draw"><a class="docs-heading-anchor" href="#Method-for-Muscade.draw">Method for <code>Muscade.draw</code></a><a id="Method-for-Muscade.draw-1"></a><a class="docs-heading-anchor-permalink" href="#Method-for-Muscade.draw" title="Permalink"></a></h2><h3 id="Vectorization"><a class="docs-heading-anchor" href="#Vectorization">Vectorization</a><a id="Vectorization-1"></a><a class="docs-heading-anchor-permalink" href="#Vectorization" title="Permalink"></a></h3><p>Elements <em>can</em> implement a <a href="reference.html#Muscade.draw-Tuple{Any, AbstractElement, Vararg{Any}}"><code>Muscade.draw</code></a> method. If no method is implemented, the element will be invisible if the user requests a drawing of the element.</p><p>None of <code>Muscade</code> built-in elements implement methods for <code>draw</code>: because <code>Muscade</code> has no inherent interpretation of the various <code>X</code> dofs, there is no graphical representation associated to them.  On the other hand, it might make sense for an app developer (giving an interpretation to various dofs) to create such methods.</p><p>Because <code>Muscade</code> provides no implementation of <code>draw</code> (with the exception of some demo elements), <code>Muscade</code> does not prescribe the use of any specific graphic package.  See <a href="https://docs.makie.org/"><code>Makie.jl</code></a> and <a href="https://juliavtk.github.io/WriteVTK.jl/stable/"><code>WriteVTK.jl</code></a> for candidates.</p><p>While the API may remind that of <a href="reference.html#Muscade.lagrangian-Tuple{}"><code>Muscade.lagrangian</code></a>, there is one significant difference:  because it is more efficient to create few graphical object (in <code>Makie</code>: few calls to <code>lines!</code>, <code>scatter!</code>) etc., the element&#39;s method for <code>draw</code> will be called once to draw several elements of the same type. In <code>Makie</code> multiple lines can be drawn in one call to <code>lines!</code> by using <code>NaN</code>s to &quot;lift the pen&quot;.</p><h3 id="Keyword-arguments"><a class="docs-heading-anchor" href="#Keyword-arguments">Keyword arguments</a><a id="Keyword-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-arguments" title="Permalink"></a></h3><p>When requesting a drawing of all or part of the model, the user can provide specifications (line thickness, line colors, what quantity to visualise as colored patches and so forth).   The user can for example require</p><pre><code class="language-julia hljs">draw(model;linewidth=2)</code></pre><p>The element&#39;s <code>draw</code> method <em>must</em> accept an arbitrary list of keyword arguments.  Keywords arguments not used by the method are automaticaly ignored.  In order not to fail if a <em>used</em> keyword argument is not provided by the user, the following syntax can be used in the element&#39;s <code>draw</code> method.   </p><pre><code class="language-julia hljs">function Muscade.draw(...)
    ...
    linewith = default{:linewidth}(kwargs,2.)
    ...
end</code></pre><p>which can be read: if <code>kwargs.linewidth</code> exists, the set <code>linewidth</code> to its value, otherwise, set it to <code>2.</code>.</p><p>The user has facilities to draw only selected element types or selected elements, so the element&#39;s <code>draw</code> method does not need to implement a switch on <em>whether</em> to draw.</p><p>See <a href="StaticBeamAnalysis.html"><code>examples/BeamElements.jl</code></a> for an example of implementation.</p><h3 id="Getting-element-results"><a class="docs-heading-anchor" href="#Getting-element-results">Getting element results</a><a id="Getting-element-results-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-element-results" title="Permalink"></a></h3><p>In many cases, drawing provides a graphical representation of element-results (see <a href="Modelling.html#Extracting-results">Extracting results</a>).  A pattern is that <code>draw</code> creates a request and calls <code>residual</code> or <code>lagrangian</code> (which ever the element implements), with an additional last input argument <code>req</code> (the request created using <a href="reference.html#Muscade.@request-Tuple{Any}"><code>@request</code></a>), and an additional last output argument <code>out</code> (containing the element-results).</p><h2 id="Help-functions"><a class="docs-heading-anchor" href="#Help-functions">Help functions</a><a id="Help-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Help-functions" title="Permalink"></a></h2><p><code>Muscade</code> provides functions and constants to make it easier to comply with the API:</p><p>Element constructors can use function <a href="reference.html#Muscade.coord-Tuple{AbstractVector{Node}}"><code>coord</code></a> to extract the coordinates fron the <code>Vector{Node}</code> they get as first argument.</p><p><code>Muscade.residual</code> and <code>Muscade.lagrangian</code> <strong>must</strong> use <a href="reference.html#Muscade.∂0-Tuple{Any}"><code>∂0</code></a>, <a href="reference.html#Muscade.∂1-Tuple{Any}"><code>∂1</code></a> and <a href="reference.html#Muscade.∂2-Tuple{Any}"><code>∂2</code></a> when extracting the zeroth, first and second time derivatives from arguments <code>X</code> and <code>U</code>. These functions ensures that a <code>SVector</code> of zeros is returned if for example, an element that handles accelerations is called by a static solver.</p><p>Constant <a href="reference.html#Muscade.noFB"><code>noFB</code></a> (which have value <code>nothing</code>) can be used by elements that do not have feedback to the solving procedure.</p><p>For those prefering to think in terms of Cartesian tensor algebra, rather than matrix algebra, operators <a href="reference.html#Muscade.:⊗-Tuple{Any, Any}"><code>⊗</code></a>, <a href="reference.html#Muscade.:∘₁-Tuple{Any, Any}"><code>∘₁</code></a> and <a href="reference.html#Muscade.:∘₂-Tuple{Any, Any}"><code>∘₂</code></a> provide the exterior product, the single dot product and the double dot product respectively.</p><p>Elements with a corotated reference system, can make use of <a href="StaticBeamAnalysis.html"><code>examples/Rotations.jl</code></a> that provides functionality to handle rotations in ℝ³.  See <a href="StaticBeamAnalysis.html"><code>examples/BeamElements.jl</code></a> for an example.</p><h2 id="Automatic-differentiation-within-element-code"><a class="docs-heading-anchor" href="#Automatic-differentiation-within-element-code">Automatic differentiation within element code</a><a id="Automatic-differentiation-within-element-code-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-differentiation-within-element-code" title="Permalink"></a></h2><p>Some advanced elements (in particular, elements with co-rotated element systems) can be implemented elegantly by using automatic differentiation within <code>residual</code> or <code>lagrangian</code>.  These are advanced techniques, requiring a good understanding of <a href="Adiff.html"><code>automatic differentiation</code></a>.  Example of usage can be found in <a href="StaticBeamAnalysis.html"><code>examples/BeamElements.jl</code></a>.</p><p>Helper functions <a href="reference.html#Muscade.motion-Union{Tuple{Tuple{Vararg{StaticArraysCore.SVector{N, R}, ND}}}, Tuple{R}, Tuple{N}, Tuple{P}, Tuple{ND}} where {ND, P, N, R}"><code>motion</code></a> and <a href="reference.html#Muscade.motion⁻¹-Union{Tuple{Real}, Tuple{P}} where P"><code>motion⁻¹</code></a> allow to transform a <code>tuple</code> of <code>SVectors</code>, like the input <code>X</code> given to <code>residual</code> and <code>lagrangian</code>, into a an automatic differentiation structure, so that functions of <code>∂0(X)</code> only can be differentiated with respect to time. </p><p>It is sometimes possible to improve performance by identifying a part of <code>residual</code> or <code>lagrangian</code> which takes a single, <code>SVector</code> as an input: A vector shorter than the list of dofs differentiated by the solver allow to accelerate computations, by using <a href="reference.html#Muscade.fast-Tuple{Any, Any}"><code>fast</code></a>, or for more adbanced usage, <a href="reference.html#Muscade.revariate-Union{Tuple{StaticArraysCore.SVector{N, R}}, Tuple{R}, Tuple{N}, Tuple{O}} where {O, N, R}"><code>revariate</code></a> in combination with <a href="reference.html#Muscade.compose-Tuple{Tuple, Any}"><code>compose</code></a>. </p><p>In <a href="StaticBeamAnalysis.html"><code>examples/BeamElements.jl</code></a>, in function <code>kinematics</code>, <a href="reference.html#Muscade.fast-Tuple{Any, Any}"><code>fast</code></a> is applied to accelerate a process of differentiation to the 2nd order.  In <code>residual</code>, <a href="reference.html#Muscade.revariate-Union{Tuple{StaticArraysCore.SVector{N, R}}, Tuple{R}, Tuple{N}, Tuple{O}} where {O, N, R}"><code>revariate</code></a> and <a href="reference.html#Muscade.compose-Tuple{Tuple, Any}"><code>compose</code></a>, as well as the convenience function <a href="reference.html#Muscade.composewithJacobian"><code>composewithJacobian</code></a> is applied, in order to differentiate <code>kinematics</code> and accelerate computations by exploiting the fact that <code>kinematic</code> is a function of <code>∂0(X)</code> only.</p><h2 id="Testing-elements"><a class="docs-heading-anchor" href="#Testing-elements">Testing elements</a><a id="Testing-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-elements" title="Permalink"></a></h2><p>When developing a new element, it is advisable to test the constructor, and <code>residual</code> or <code>lagrangian</code> in a direct call (outside of any Muscade solver), and examine the returned outputs.</p><p>Generaly, automatic differentiation is unproblematic, but when advanced tools are used (e.g. <a href="reference.html#Muscade.revariate-Union{Tuple{StaticArraysCore.SVector{N, R}}, Tuple{R}, Tuple{N}, Tuple{O}} where {O, N, R}"><code>revariate</code></a> and <a href="reference.html#Muscade.compose-Tuple{Tuple, Any}"><code>compose</code></a>), then the derivatives should be inspected.  See <a href="reference.html#Muscade.diffed_residual-Tuple{eletyp} where eletyp&lt;:AbstractElement"><code>diffed_residual</code></a> and <a href="reference.html#Muscade.diffed_lagrangian-Tuple{eletyp} where eletyp&lt;:AbstractElement"><code>diffed_lagrangian</code></a> to compute the derivatives of <code>R</code> and <code>L</code> returned by <code>residual</code> and <code>lagrangian</code> respectively. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Solvers.html">« Solvers</a><a class="docs-footer-nextpage" href="StaticBeamAnalysis.html">Static analysis of a beam »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Monday 5 May 2025 04:44">Monday 5 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
