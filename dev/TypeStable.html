<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Type-stability · Muscade.jl</title><meta name="title" content="Type-stability · Muscade.jl"/><meta property="og:title" content="Type-stability · Muscade.jl"/><meta property="twitter:title" content="Type-stability · Muscade.jl"/><meta name="description" content="Documentation for Muscade.jl."/><meta property="og:description" content="Documentation for Muscade.jl."/><meta property="twitter:description" content="Documentation for Muscade.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Muscade.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="Theory.html">Theory</a></li><li><span class="tocitem">User manual</span><ul><li><a class="tocitem" href="Modelling.html">Creating a model</a></li><li><a class="tocitem" href="Solvers.html">Solvers</a></li><li><a class="tocitem" href="Elements.html">Implementing new elements</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="BeamElements.html">Euler beam element</a></li><li><a class="tocitem" href="StaticBeamAnalysis.html">Static analysis of a beam</a></li><li><a class="tocitem" href="DynamicBeamAnalysis.html">Modal analysis of a beam</a></li><li><a class="tocitem" href="DecayAnalysis.html">Estimating model parameters</a></li><li><a class="tocitem" href="DryFriction.html">DryFriction</a></li></ul></li><li><a class="tocitem" href="reference.html">Reference</a></li><li><span class="tocitem">Appendix</span><ul><li class="is-active"><a class="tocitem" href="TypeStable.html">Type-stability</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#To-type,-or-not-to-type"><span>To type, or not to type</span></a></li><li><a class="tocitem" href="#Julia&#39;s-approach-to-type-specifications"><span>Julia&#39;s approach to type specifications</span></a></li><li><a class="tocitem" href="#What-is-type-stability?"><span>What is type stability?</span></a></li><li><a class="tocitem" href="#If,-then"><span>If, then</span></a></li><li><a class="tocitem" href="#Method-return-value"><span>Method return value</span></a></li><li><a class="tocitem" href="#Array-of-abstract-element-type"><span>Array of abstract element type</span></a></li><li><a class="tocitem" href="#Structure-of-abstract-field-type"><span>Structure of abstract field type</span></a></li><li><a class="tocitem" href="#A-note-on-constructors-for-parametric-types"><span>A note on constructors for parametric types</span></a></li><li><a class="tocitem" href="#StaticArrays"><span>StaticArrays</span></a></li><li><a class="tocitem" href="#Val"><span>Val</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#@code_warntype"><span>@code_warntype</span></a></li><li><a class="tocitem" href="#Profile.jl"><span>Profile.jl</span></a></li></ul></li><li><a class="tocitem" href="Memory.html">Memory management</a></li><li><a class="tocitem" href="Adiff.html">Automatic differentiation</a></li><li><a class="tocitem" href="litterature.html">Literature</a></li></ul></li><li><a class="tocitem" href="LICENSE.html">MIT License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Appendix</a></li><li class="is-active"><a href="TypeStable.html">Type-stability</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="TypeStable.html">Type-stability</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SINTEF/Muscade.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SINTEF/Muscade.jl/blob/main/docs/src/TypeStable.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="typestab"><a class="docs-heading-anchor" href="#typestab">Type-stability</a><a id="typestab-1"></a><a class="docs-heading-anchor-permalink" href="#typestab" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>This text presents <em>type stability</em>, which is one of the important concepts that one needs to understand in order to write high-performance Julia code.</p><p>This text is aimed at Julia users that are familiar with composite types, abstract types, functions, methods and multiple dispatch. At the same time, as little advanced Julia syntax as possible is used, to make the text accessible.</p><h2 id="To-type,-or-not-to-type"><a class="docs-heading-anchor" href="#To-type,-or-not-to-type">To type, or not to type</a><a id="To-type,-or-not-to-type-1"></a><a class="docs-heading-anchor-permalink" href="#To-type,-or-not-to-type" title="Permalink"></a></h2><p>The developers of Julia wanted to solve the two-language problem.  They have achieved this and produced a language that &quot;walks like Python and runs like C&quot;.  Julia &quot;walks like Python&quot;, because it is not necessary to systematically define the type of every variable that appears in the code.  It &quot;runs like C&quot; because it is a compiled language, and produces (or rather, <em>can</em> produce) highly efficient machine code.</p><p>Python and MATLAB are examples of interpreted language.  In a pure interpreted language, the type of the variables is computed at run time, at the same time as the value of the variables.  As long as the values of the inputs to the code are known at the top level (in the REPL or the top script), the interpretation infers, step by step the type of the variables, all the way down the call stack. This allows to write functions without specifying types, and this in turn allows to write generic code (for example an iterative solver that works just as well with <code>Float64</code> and <code>Float32</code> variables).  The disadvantage is that inferring the type of variables on the fly introduces significant overhead at run time.</p><p>At the other end of the scale C and Fortran are examples of strictly typed compiled languages. Because the source code specifies the type of every variable in the function (both variables in the function interface, and local variables), the compiler can create efficient machine code for each function, just by considering the code of that function alone. The disadvantage is that type declaration takes time to write and clutters the source code, and (unless the language offers &quot;templates&quot;, as C++ does), it may be necessary to write several methods, identical in all but types of variables, to make an algorithm available to various data types.</p><h2 id="Julia&#39;s-approach-to-type-specifications"><a class="docs-heading-anchor" href="#Julia&#39;s-approach-to-type-specifications">Julia&#39;s approach to type specifications</a><a id="Julia&#39;s-approach-to-type-specifications-1"></a><a class="docs-heading-anchor-permalink" href="#Julia&#39;s-approach-to-type-specifications" title="Permalink"></a></h2><p>Julia takes the sweet spot in between, not requiring to specify the type of each variable, yet producing fast machine code. The trick is as follows: every time a method is called (so, at run time), with a combination of <em>concrete types</em> of arguments that has not yet been encountered for this method, the compiler quicks in.  A &quot;concrete type&quot; is the information returned by <code>typeof()</code> when called on a variable.  One example is <code>Float64</code>.  This is as opposed to an abstract type, like <code>Real</code>, which is a set of concrete types, and includes <code>Float64</code> and <code>Float32</code>. <em>In the rest of this text &quot;type&quot; will refer to &quot;concrete type&quot;</em>.</p><p>The compiler now has the source code of the method, and the types of all the arguments. The compiler will produce a <em>method instance</em> (or instance, for short), which is machine code for this combination. One interesting implication is that writing strictly typed method interfaces in Julia does not provide any improvement of machine code performance: the compiler takes the type of the arguments from the calling context anyway. A strictly typed interface has the disadvantage of offering no flexibility. A method that only accepts a <code>Vector</code> will not accept other vector-like things like a <code>SubArray</code> (an array view), a <code>Adjoint</code> (a transposed array), a <code>SparseMatrix</code> or a <code>StaticArray</code>, even thought the method probably implements an algorithm that would compile perfectly well for all of these.</p><p>However, providing partial specification of the type of the arguments of a method serves important purposes in Julia:</p><ol><li>If a function has several methods, it allows to specify which method should be executed (multiple dispatch). This is where abstract types like <code>Real</code>,  <code>AbstractVector</code> and <code>AbstractVector{&lt;:Real}</code> come into their own.</li><li>It improves code readability, stating for example &quot;this method expects some vector of some real numbers - but not a string&quot;.</li><li>It provides more graceful failures: &quot;function <code>foo</code> has no method that takes in a string&quot; is more informative that some esoteric failure down the line when attempting to add two strings.</li></ol><h2 id="What-is-type-stability?"><a class="docs-heading-anchor" href="#What-is-type-stability?">What is type stability?</a><a id="What-is-type-stability?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-type-stability?" title="Permalink"></a></h2><p>If the source code of the method is well written, the source code and the concrete type of all arguments is enough information for the compiler to infer the concrete type of every variable and expression within the method.  The method is then said to be &quot;typestable&quot;, and the Julia compiler will produce efficient code.</p><p>If, for a variety of reasons that will be studied in the following, the type of a local variable cannot be inferred from the types of the arguments, the compiler will produce machine code full of &quot;if&quot;s, covering all options of what the type of each variable could be. The loss in performance is often significant, easily by a factor of 10.</p><p><strong>If you are yourself able to infer the type of every local variable, and every expression in a method (or script) from the types (<em>not</em> the values) of the arguments or from constants in the code, the function will be typestable.</strong>  Actually, as will be seen below, this inference of types is also allowed access to <code>struct</code> declarations, and to the types of the return values of functions called by the function you are studying.</p><p>The rest of this text will examine a variety of situations, ranging from obvious to more tricky tricky, in which it is not possible to infer the types of local variables from the types of the arguments, resulting in type instability.</p><p>For this purpose, it will be useful to write down the information available to the compiler.  So for example, if the method</p><pre><code class="language-julia hljs">function add(a::Number,b::Number)
    c = a+b
    return c
end</code></pre><p>is called with <code>a</code> of type <code>Float64</code> and <code>b</code> of type <code>Int32</code>, then we will write the information available to the compiler to create an instance as</p><pre><code class="language-julia hljs">instance add(a::Float64,b::Int32)
    c = a+b
    return c
end</code></pre><p><code>instance</code> is not Julia syntax, it is just a notation introduced in this text to describe an instance.  In such <code>instance</code> description, a <em>concrete</em> type must be associated with every argument.</p><h2 id="If,-then"><a class="docs-heading-anchor" href="#If,-then">If, then</a><a id="If,-then-1"></a><a class="docs-heading-anchor-permalink" href="#If,-then" title="Permalink"></a></h2><p>Consider the following method instance</p><pre><code class="language-julia hljs">instance largest(a::Float64,b::Int64)
    if a &gt; b
        c = a
    else
        c = b
    end
    return c
end</code></pre><p>The variable <code>c</code> will be set to either <code>a</code> or <code>b</code>. <code>c</code> will take the value <em>and the type</em> of either <em>a</em> or <em>b</em>.  The type of <code>c</code> depends on an operation <code>a &gt; b</code> on the <em>values</em> of <code>a</code> and <code>b</code>: the type of <code>c</code> cannot be inferred from the type of arguments alone, and this code is not typestable.</p><p>Several approaches might be relevant to prevent type instability.  The simplest is to code <code>largest</code> so that it only accepts two arguments of the same type.</p><pre><code class="language-julia hljs">function largest(a::R,b::R) where{R&lt;:Real}
    if a &gt; b
        c = a
    else
        c = b
    end
    return c
end</code></pre><p>The method is general, it can result in the generation of method instances like <code>instance largest(a::Float64,b::Float64)</code>, <code>instance largest(a::Int64,b::Int64)</code> and many others. It cannot result in the generation of machine code for <code>instance largest(a::Float64,b::Int64)</code> (because <code>R</code> cannot be both <code>Int64</code> and <code>Float64</code>). If we need to be able to handle variables of different types, yet want type stability, a solution is to use <em>promotion</em> to ensure that <code>c</code> is always of the same type.</p><pre><code class="language-julia hljs">function largest(a,b)
    pa,pb = promote(a,b)
    if a &gt; b
        c = pa
    else
        c = pb
    end
    return c
end</code></pre><p><code>promote</code> is defined so that <code>pa</code> and <code>pb</code> have the same type, and this type is inferred from the types of <code>a</code> and <code>b</code>. For example, for a call <code>instance largest(a::Float64,b::Int64)</code>, the types of <code>pa</code>, <code>pb</code> and <code>c</code> will be <code>Float64</code>, to which one can convert a <code>Int64</code> variable without loss of information (well, mostly).</p><p><strong>Do not allow an if-then construct to return a variable which type depends on the branch taken.</strong></p><h2 id="Method-return-value"><a class="docs-heading-anchor" href="#Method-return-value">Method return value</a><a id="Method-return-value-1"></a><a class="docs-heading-anchor-permalink" href="#Method-return-value" title="Permalink"></a></h2><p>A method <code>foo</code> that would call the above first, not typestable, version of the method instance <code>largest</code> would receive as output a variable of a type that is value dependent: <code>foo</code> itself would not be typestable.  The workaround here is to create typestable methods for <code>largest</code>, as suggested above.</p><p>One example is the method <code>Base.findfirst(A)</code>, which given a <code>Vector{Boolean}</code> returns the index of the first <code>true</code> element of the vector.  The catch is that if all the vector&#39;s elements are <code>false</code>, the method returns <code>nothing</code>. <code>nothing</code> is of type <code>Nothing</code>, while the index is of type <code>Int64</code>.  Using this method will make the calling method not typestable.</p><p><strong>Avoid methods that return variables of value-dependant types.</strong></p><h2 id="Array-of-abstract-element-type"><a class="docs-heading-anchor" href="#Array-of-abstract-element-type">Array of abstract element type</a><a id="Array-of-abstract-element-type-1"></a><a class="docs-heading-anchor-permalink" href="#Array-of-abstract-element-type" title="Permalink"></a></h2><p>Consider the following code</p><pre><code class="language-julia hljs">v = [3.,1,&quot;Hello world!&quot;]
function showall(v)
    for e ∈ v
        @show e
    end
end
showall(v)</code></pre><p>The above call <code>showall(v)</code> generates a method instance</p><pre><code class="language-julia hljs">instance showall(v::Array{Any,1})
    for e ∈ v
        @show e
    end
end</code></pre><p>The concrete type of <code>e</code> cannot be inferred from <code>Array{Any,1}</code>, because <code>Any</code> is not a concrete type. More specifically, the type of <code>e</code> changes from one iteration to the next: the code is not typestable. If <code>v</code> is of type <code>Array{Any,1}</code>, even if <code>V</code> has elements that are all of the same type, this does not help:</p><pre><code class="language-julia hljs">v = Vector{Any}(undef,3)
v[1] = 3.
v[2] = 1.
v[3] = 3.14
showall(v)</code></pre><p><code>e</code> may have the same type at each iteration, but this type still cannot be inferred from the type <code>Array{Any,1}</code> of the argument.</p><p>If we define <code>w = randn(3)</code>, <code>w</code> has type <code>Array{Float64,1}</code>.  This is much more informative: every element of <code>w</code> is known to have the same concrete type <code>Float64</code>. Hence the call <code>showall(w)</code> generates a method instance</p><pre><code class="language-julia hljs">instance showall(v::Array{Float64,1})
    for e ∈ v
        @show e
    end
end</code></pre><p>and the compiler can infer that <code>e</code> is a <code>Float64</code>.</p><p><strong>Wherever possible use arrays with a concrete element type.</strong></p><p>Sometimes, the use of array with abstract element type is deliberate.  One may really wish to iterate over a heterogeneous collection of elements and apply various methods of the same function to them: we design for dynamic dispatch, and must accept that the process of deciding which method to call takes time.  Two techniques can be used to limit the performance penalty.</p><p>The first is the use of a &quot;function barrier&quot;: The loop over the heterogenous array should contain as little code as possible, ideally only the access to the arrays element, and the call to a method.</p><pre><code class="language-julia hljs">for e ∈ v
    foo(e)
end</code></pre><p>If <code>v</code> contains elements of different type, the loop is not typestable and hence slow. Yet each value of <code>e</code> at each iteration has its unique concrete type, for which an instance of <code>foo</code> will be generated: <code>foo</code> can be made typestable and fast.</p><p>The second, a further improvement of the first, is to group elements by concrete type, for example, using a heterogenous arrays of homogeneous arrays.</p><pre><code class="language-julia hljs">vv = [[1.,2.,3.],[1,2]]
for v ∈ vv  # outerloop
    innerloop(v)
end
function innerloop(v)
    for e ∈ v
        foo(e)
    end
end</code></pre><p>Here <code>vv</code> is an <code>Array{Any,1}</code>, containing two vectors of different types. <code>vv[1]</code> is a <code>Array{Float64,1}</code> and <code>vv[2]</code> is a <code>Array{Int64,1}</code>. Function <code>innerloop</code> is called twice and two instances are generated</p><pre><code class="language-julia hljs">instance innerloop(v::Array{Float64,1})
    for e ∈ v  # e is Float64
        foo(e)
    end
end
instance innerloop(v::Array{Int64,1})
    for e ∈ v  # e is Int64
        foo(e)
    end
end</code></pre><p>and in both instances, the type of <code>e</code> is clearly defined: the instances are typestable.</p><p>The with this second approach is that the loop <code>for v ∈ vv</code> has few iterations (if the number of types is small compared to the number of elements in each types).</p><h2 id="Structure-of-abstract-field-type"><a class="docs-heading-anchor" href="#Structure-of-abstract-field-type">Structure of abstract field type</a><a id="Structure-of-abstract-field-type-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-of-abstract-field-type" title="Permalink"></a></h2><p>A similar loss of type stability arises when reading data from structures that have a field of abstract type:</p><pre><code class="language-julia hljs">struct SlowType
    a
end
struct JustAsBad
    a::Real
end
struct MuchBetter
    a::Float64
end
function show_a(s)
    @show s.a
end
show_a(SlowType(3.))
show_a(JustAsBad(3.))
show_a(MuchBetter(3.))</code></pre><p>The first call to <code>show_a</code> generates</p><pre><code class="language-julia hljs">instance show_a(s::SlowType)
    @show s.a # The concrete type of field a of type SlowType cannot be
              # inferred from the definition of SlowType
end</code></pre><p>The second call to <code>show_a</code> has the same problem.  The third call generates a typestable instance</p><pre><code class="language-julia hljs">instance show_a(s::Better)
    @show s.a # That&#39;s a Float64
end</code></pre><p>It is often interesting to create structures with fields that can have various types. A classic example is Julia&#39;s <code>Complex</code> type, which can have real and imaginary components which are either both <code>Float64</code>, both <code>Float32</code> or other more exotic choices. This can be done without losing type stability by using parametric types:</p><pre><code class="language-julia hljs">struct FlexibleAndFast{R}
    a::R
end
show_a(FlexibleAndFast(3.))
show_a(FlexibleAndFast(3 ))</code></pre><p>The above calls generate two typestable instances of <code>show_a</code></p><pre><code class="language-julia hljs">instance show_a(s::FlexibleAndFast{Float64})
    @show s.a # That&#39;s a Float64
end
instance show_a(s::FlexibleAndFast{Int64})
    @show s.a # That&#39;s an Int64
end</code></pre><p><strong>Always use <code>struct</code> with fields of concrete types.  Use parametric structure where necessary</strong>.</p><h2 id="A-note-on-constructors-for-parametric-types"><a class="docs-heading-anchor" href="#A-note-on-constructors-for-parametric-types">A note on constructors for parametric types</a><a id="A-note-on-constructors-for-parametric-types-1"></a><a class="docs-heading-anchor-permalink" href="#A-note-on-constructors-for-parametric-types" title="Permalink"></a></h2><p>Consider a <code>struct</code> definition without inner constructor:</p><pre><code class="language-julia hljs">struct MyType{A,B}
    a::A
    b::B
end</code></pre><p>Julia will automatically generate a constructor <em>method</em> with signature</p><pre><code class="language-julia hljs">MyType{A,B}(a::A,b::B)</code></pre><p>Julia will also produce another method with signature</p><pre><code class="language-julia hljs">MyType(a::A,b::B)</code></pre><p>because for <code>MyType</code>, it is possible to infer all type parameters from the types of the inputs to the constructor. Other constructors like</p><pre><code class="language-julia hljs">MyType{A}(a::A,b::B)</code></pre><p>have to be defined explicitly (how should the compiler decide whether to interpret a single type-parameter input as <code>A</code> or <code>B</code>...).</p><p>Consider another example:</p><pre><code class="language-julia hljs">struct MyType{A,B,C}
    a::A
    b::B
end</code></pre><p>Julia will automatically generate a constructor method with signature</p><pre><code class="language-julia hljs">MyType{A,B,C}(a::A,b::B)</code></pre><p>but will not generate other methods.  A method like</p><pre><code class="language-julia hljs">MyType{C}(a::A,b::B)</code></pre><p>would have to be defined explicitly.</p><h2 id="StaticArrays"><a class="docs-heading-anchor" href="#StaticArrays">StaticArrays</a><a id="StaticArrays-1"></a><a class="docs-heading-anchor-permalink" href="#StaticArrays" title="Permalink"></a></h2><p>Julia <code>Array</code>s are an example of parametric type, where the parameters are the type of elements, and the dimension (the number of indices). Importantly, the <em>size</em> of the array is not part of the <em>type</em>, it is a part of the <em>value</em> of the array.</p><p>The package <code>StaticArrays.jl</code> provides the type <code>StaticArray</code>, useful for avoiding another performance problem: garbage collection that follows the allocation of <code>Array</code>s on the heap. This is because <code>StaticArray</code> are allocated on the stack, simplifying runtime memory management.</p><pre><code class="language-julia hljs">using StaticArrays
SA = SVector{3,Float64}([1.,2.,3.])
SA = SVector(1.,2.,3.)
SA = SVector([1.,2.,3.])</code></pre><p>The first call to <code>SVector</code> is typestable: all the information needed to infer the type of <code>SA</code> is provided in curly braces. The second call is typestable too, because the compiler can deduce the same information from the type and number of inputs. The third call is problematic: while the type of the elements of <code>SA</code> can be inferred by the compiler, the length of <code>[1.,2.,3.]</code> is part of this array&#39;s value, not type. The type of <code>SA</code> has a parameter that depends on the value (the size) of the argument passed to the constructor.  Not only does this generate an instance of the constructor that is not type stable, but the non-inferable type of <code>SA</code> &quot;contaminates&quot; the calling code with type instability.</p><h2 id="Val"><a class="docs-heading-anchor" href="#Val">Val</a><a id="Val-1"></a><a class="docs-heading-anchor-permalink" href="#Val" title="Permalink"></a></h2><p>What if we want to write a function that takes an <code>Vector</code> as an input, processes it (for example just keeps it as it is), and returns a <code>SVector</code> of the same shape. Of course we want this function to be general and not be limited to a given array size <em>and</em> we want this function to be typestable, for good performance.</p><p>First attempt:</p><pre><code class="language-julia hljs">function static(v::Vector)
    return SVector{length(v),eltype(v)}(v)
end</code></pre><p>This function is not typestable. It constructs a variable of type <code>StaticArray{(3,),Float64}</code>, where <code>3</code> is obtained as the <code>length</code> of <code>v</code>, and the length is part of the value of an <code>Array</code>.  Value-to-type alarm!</p><p>One possible solution is to use <code>Val</code>. Let us say that <code>static</code> is called by a function <code>foo</code> within which the length of <code>v</code> can be inferred at compile time.  We could create the following code</p><pre><code class="language-julia hljs">function static(v,::Val{L}) where{L}
    return SVector{L,Float64}(v)
end
function foo()
    Val3 = Val(3)
    Val4 = Val(4)
    @show static([1.,2.,3.]   ,Val3)
    @show static([1.,2.,3.,4.],Val4)
end</code></pre><p>The call <code>Val(3)</code> generates a variable, of type <code>Val{3}</code>. Clearly, <code>Val</code> as a function is not typestable, since it creates a variable of a type depending on the value of its argument.</p><p>However, function <code>foo</code> is typestable.  This may come as a surprise, but two things conspire to allow this:</p><ol><li>The source code of <code>foo</code> explicitly mentions the <em>constants</em> <code>3</code> and <code>4</code>, and the compiler has access to it.</li><li>The compiler is greedy - it evaluates at compile time whenever possible.  Hence the call <code>Val(3)</code> is evaluated during compilation, and <code>Val3</code> is known to the compiler to be a a value-empty variable of type <code>Val{3}</code>.</li></ol><p>In <code>foo</code>, the method <code>static</code> is called twice, leading to the generation of two typestable instances</p><pre><code class="language-julia hljs">instance static(v,::Val{3})
    return SVector{3,Float64}(v)
end
instance static(v,::Val{4})
    return SVector{4,Float64}(v)
end</code></pre><p>What if the length of the vectors is not defined as a constant in <code>foo</code>?  If this length is the result of some computation, the call to <code>Val</code> with not be typestable. If <code>foo</code> is high enough in the call hierarchy, and outside any time-critical loop, this is not an issue: only <code>foo</code> will not be typestable, but functions that it calls can still be typestable (cf. the function barrier pattern).</p><p><strong><code>Val</code> allows to move type instability up the call hierarchy, or eliminate it altogether.</strong></p><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><p>The type <code>Function</code> is an <em>abstract</em> datatype, and every function in Julia has its own type.  Here we refer not to the type of the variables returned by the function, but to the function being a variable in itself.</p><p>The implication is that if we have a scalar-valued function <code>energy</code> that takes a function <code>signal</code> as an input, and computes the energy of the signal over some interval, then a new instance of <code>energy</code> will be compiled every time it is called with an new argument <code>signal</code>.</p><p>This also has implications on how to store functions in a <code>struct</code>. This is not typestable</p><pre><code class="language-julia hljs">struct MyType
    foo::Function
end</code></pre><p>but this is</p><pre><code class="language-julia hljs">struct MyType{Tfoo}
    foo::Tfoo
end</code></pre><h2 id="@code_warntype"><a class="docs-heading-anchor" href="#@code_warntype">@code_warntype</a><a id="@code_warntype-1"></a><a class="docs-heading-anchor-permalink" href="#@code_warntype" title="Permalink"></a></h2><p>One important tool to check that an instance is typestable is the macro <code>@code_warntype</code>. For example</p><pre><code class="language-julia hljs">v = randn(3)
@code_warntype Val(length(v))
@code_warntype static(v,Val(length(v)))</code></pre><p>The first invocation of <code>@code_warntype</code> outputs a semi-compiled code, and highlights some of the types in red: the call <code>Val(3)</code> is not typestable. The second invocation of <code>@code_warntype</code> produces an output in which all types are highlighted in blue: the call to <code>static</code> is typestable.  Note that <code>@code_warntype</code> only analyses the compilation of the outermost function <code>static</code> - given the arguments <code>v</code> and <code>Val(length(v))</code>.</p><h2 id="Profile.jl"><a class="docs-heading-anchor" href="#Profile.jl">Profile.jl</a><a id="Profile.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Profile.jl" title="Permalink"></a></h2><p><code>Profile.jl</code> and <code>ProfileView.jl</code> together provide a &quot;flame graph&quot;, a graphical representation of where processor time goes, in which code that is not typestable is highlighted. Output from the profiler often shows how type instability propagates: a single variable that is not typestable makes &quot;anything it touches&quot; type unstable.</p><p>Particularly useful, one can click on a function, and then type <code>warntype_last()</code> in the REPL to get to see a <code>@code_warntype</code> output for that function.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="reference.html">« Reference</a><a class="docs-footer-nextpage" href="Memory.html">Memory management »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Wednesday 21 May 2025 13:07">Wednesday 21 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
